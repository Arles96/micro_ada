
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Tue Nov 03 07:45:27 CST 2009
//----------------------------------------------------

import java_cup.runtime.*;
import java.util.Stack;
import java.util.ArrayList;
import AdaSemantic.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Tue Nov 03 07:45:27 CST 2009
  */
public class semantic extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public semantic() {super();}

  /** Constructor which sets the default scanner. */
  public semantic(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public semantic(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\375\000\002\002\004\000\002\004\002\000\002\004" +
    "\003\000\002\002\003\000\002\003\002\000\002\006\003" +
    "\000\002\006\003\000\002\005\003\000\002\005\003\000" +
    "\002\007\003\000\002\011\003\000\002\011\005\000\002" +
    "\012\003\000\002\012\005\000\002\013\003\000\002\013" +
    "\003\000\002\013\003\000\002\013\003\000\002\013\003" +
    "\000\002\014\010\000\002\014\010\000\002\015\002\000" +
    "\002\015\004\000\002\016\010\000\002\016\010\000\002" +
    "\010\005\000\002\010\005\000\002\017\010\000\002\017" +
    "\003\000\002\020\002\000\002\020\003\000\002\021\003" +
    "\000\002\022\007\000\002\023\003\000\002\023\003\000" +
    "\002\023\003\000\002\024\004\000\002\024\004\000\002" +
    "\024\004\000\002\024\004\000\002\025\004\000\002\026" +
    "\005\000\002\027\003\000\002\027\003\000\002\030\005" +
    "\000\002\031\002\000\002\031\003\000\002\032\005\000" +
    "\002\033\004\000\002\033\004\000\002\033\003\000\002" +
    "\156\002\000\002\157\002\000\002\034\010\000\002\160" +
    "\002\000\002\035\005\000\002\161\002\000\002\035\005" +
    "\000\002\036\002\000\002\036\004\000\002\037\002\000" +
    "\002\037\003\000\002\162\002\000\002\040\005\000\002" +
    "\040\003\000\002\041\005\000\002\042\003\000\002\042" +
    "\005\000\002\043\006\000\002\043\006\000\002\044\011" +
    "\000\002\045\002\000\002\045\007\000\002\046\003\000" +
    "\002\046\003\000\002\046\004\000\002\046\003\000\002" +
    "\047\003\000\002\047\005\000\002\050\006\000\002\051" +
    "\003\000\002\052\002\000\002\052\004\000\002\053\003" +
    "\000\002\053\003\000\002\053\004\000\002\054\003\000" +
    "\002\054\003\000\002\054\003\000\002\054\003\000\002" +
    "\055\005\000\002\055\005\000\002\055\005\000\002\056" +
    "\003\000\002\056\003\000\002\056\003\000\002\056\003" +
    "\000\002\056\003\000\002\057\005\000\002\057\007\000" +
    "\002\060\005\000\002\060\005\000\002\061\003\000\002" +
    "\061\005\000\002\062\003\000\002\062\003\000\002\062" +
    "\003\000\002\062\003\000\002\062\003\000\002\062\003" +
    "\000\002\063\005\000\002\063\005\000\002\064\005\000" +
    "\002\064\005\000\002\065\005\000\002\065\005\000\002" +
    "\066\005\000\002\066\005\000\002\067\005\000\002\067" +
    "\005\000\002\070\003\000\002\070\005\000\002\070\005" +
    "\000\002\070\005\000\002\071\003\000\002\071\004\000" +
    "\002\072\003\000\002\072\004\000\002\073\003\000\002" +
    "\073\005\000\002\074\003\000\002\074\005\000\002\075" +
    "\003\000\002\075\005\000\002\076\003\000\002\076\003" +
    "\000\002\076\003\000\002\076\003\000\002\076\003\000" +
    "\002\076\005\000\002\077\003\000\002\077\003\000\002" +
    "\077\003\000\002\077\003\000\002\077\003\000\002\077" +
    "\003\000\002\100\003\000\002\100\003\000\002\100\003" +
    "\000\002\101\003\000\002\101\003\000\002\101\003\000" +
    "\002\101\003\000\002\102\003\000\002\102\003\000\002" +
    "\102\003\000\002\102\003\000\002\103\007\000\002\103" +
    "\005\000\002\104\004\000\002\105\003\000\002\105\004" +
    "\000\002\106\004\000\002\106\004\000\002\106\003\000" +
    "\002\107\002\000\002\107\004\000\002\110\003\000\002" +
    "\110\003\000\002\110\003\000\002\110\003\000\002\110" +
    "\003\000\002\110\003\000\002\110\003\000\002\111\003" +
    "\000\002\111\003\000\002\111\003\000\002\112\005\000" +
    "\002\113\004\000\002\114\006\000\002\163\002\000\002" +
    "\164\002\000\002\115\015\000\002\116\002\000\002\116" +
    "\007\000\002\117\002\000\002\117\004\000\002\120\003" +
    "\000\002\165\002\000\002\166\002\000\002\121\010\000" +
    "\002\167\002\000\002\121\011\000\002\170\002\000\002" +
    "\122\007\000\002\123\002\000\002\123\006\000\002\123" +
    "\007\000\002\123\004\000\002\171\002\000\002\124\010" +
    "\000\002\172\002\000\002\124\013\000\002\125\002\000" +
    "\002\125\004\000\002\126\006\000\002\127\002\000\002" +
    "\127\003\000\002\130\002\000\002\130\004\000\002\131" +
    "\004\000\002\131\005\000\002\132\005\000\002\133\004" +
    "\000\002\134\005\000\002\134\007\000\002\135\005\000" +
    "\002\135\006\000\002\135\010\000\002\136\003\000\002" +
    "\136\003\000\002\137\003\000\002\173\002\000\002\140" +
    "\006\000\002\141\002\000\002\141\003\000\002\142\003" +
    "\000\002\142\005\000\002\143\007\000\002\143\007\000" +
    "\002\144\002\000\002\144\003\000\002\144\003\000\002" +
    "\144\004\000\002\174\002\000\002\175\002\000\002\176" +
    "\002\000\002\145\015\000\002\146\002\000\002\146\003" +
    "\000\002\147\004\000\002\150\005\000\002\150\004\000" +
    "\002\150\004\000\002\150\004\000\002\151\005\000\002" +
    "\152\003\000\002\153\003\000\002\153\004\000\002\153" +
    "\003\000\002\154\003\000\002\154\003\000\002\155\004" +
    "" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u01a7\000\010\003\010\036\014\061\005\001\002\000" +
    "\010\002\uff06\036\uff06\061\uff06\001\002\000\004\152\023" +
    "\001\002\000\020\003\uffb0\016\uffb0\036\uffb0\061\uffb0\075" +
    "\uffb0\102\uffb0\152\uffb0\001\002\000\004\002\ufffe\001\002" +
    "\000\010\002\uff08\036\uff08\061\uff08\001\002\000\010\002" +
    "\uff0b\036\014\061\005\001\002\000\010\002\uff07\036\uff07" +
    "\061\uff07\001\002\000\004\002\323\001\002\000\006\152" +
    "\023\156\024\001\002\000\004\124\017\001\002\000\010" +
    "\002\uff0a\036\uff0a\061\uff0a\001\002\000\022\002\uff2c\003" +
    "\uff2c\016\uff2c\036\uff2c\061\uff2c\075\uff2c\102\uff2c\152\uff2c" +
    "\001\002\000\006\071\uff21\113\026\001\002\000\010\071" +
    "\uff26\113\uff26\124\uff26\001\002\000\010\071\uff25\113\uff25" +
    "\124\uff25\001\002\000\124\013\ufff8\024\ufff8\025\ufff8\042" +
    "\ufff8\043\ufff8\045\ufff8\046\ufff8\050\ufff8\053\ufff8\064\ufff8" +
    "\066\ufff8\071\ufff8\101\ufff8\105\ufff8\110\ufff8\111\ufff8\112" +
    "\ufff8\113\ufff8\114\ufff8\115\ufff8\116\ufff8\117\ufff8\120\ufff8" +
    "\121\ufff8\122\ufff8\123\ufff8\124\ufff8\125\ufff8\126\ufff8\127" +
    "\ufff8\130\ufff8\131\ufff8\132\ufff8\133\ufff8\134\ufff8\135\ufff8" +
    "\136\ufff8\137\ufff8\141\ufff8\150\ufff8\151\ufff8\001\002\000" +
    "\120\013\uff24\024\uff24\025\uff24\042\uff24\043\uff24\045\uff24" +
    "\046\uff24\050\uff24\053\uff24\064\uff24\066\uff24\071\uff24\101" +
    "\uff24\105\uff24\110\uff24\111\uff24\112\uff24\113\uff24\114\uff24" +
    "\115\uff24\116\uff24\117\uff24\120\uff24\121\uff24\122\uff24\124" +
    "\uff24\125\uff24\126\uff24\127\uff24\130\uff24\131\uff24\132\uff24" +
    "\133\uff24\134\uff24\135\uff24\136\uff24\137\uff24\150\uff24\151" +
    "\uff24\001\002\000\004\071\uff20\001\002\000\004\152\023" +
    "\001\002\000\004\071\030\001\002\000\020\143\034\144" +
    "\045\145\035\146\033\147\046\152\023\156\024\001\002" +
    "\000\032\013\uffdf\043\uffdf\045\uffdf\053\uffdf\101\uffdf\110" +
    "\uffdf\114\uffdf\121\uffdf\124\uffdf\137\uffdf\150\uffdf\151\uffdf" +
    "\001\002\000\024\024\053\025\050\043\uffe0\064\144\113" +
    "\105\114\uffe0\122\102\124\uffe0\137\uffe0\001\002\000\034" +
    "\013\ufffc\043\ufffc\045\ufffc\053\ufffc\064\ufffc\101\ufffc\110" +
    "\ufffc\114\ufffc\121\ufffc\124\ufffc\137\ufffc\150\ufffc\151\ufffc" +
    "\001\002\000\004\113\266\001\002\000\032\013\ufffa\043" +
    "\ufffa\045\ufffa\053\ufffa\101\ufffa\110\ufffa\114\ufffa\121\ufffa" +
    "\124\ufffa\137\ufffa\150\ufffa\151\ufffa\001\002\000\006\043" +
    "\270\124\uff2a\001\002\000\116\013\uffaa\024\uffaa\025\uffaa" +
    "\042\uffaa\043\uffaa\045\uffaa\046\uffaa\050\uffaa\053\uffaa\064" +
    "\uffaa\066\uffaa\101\uffaa\105\uffaa\110\uffaa\111\uffaa\112\uffaa" +
    "\113\uffaa\114\uffaa\115\uffaa\116\uffaa\117\uffaa\120\uffaa\121" +
    "\uffaa\122\uffaa\124\uffaa\125\uffaa\126\uffaa\127\uffaa\130\uffaa" +
    "\131\uffaa\132\uffaa\133\uffaa\134\uffaa\135\uffaa\136\uffaa\137" +
    "\uffaa\150\uffaa\151\uffaa\001\002\000\116\013\uffa9\024\uffa9" +
    "\025\uffa9\042\uffa9\043\uffa9\045\uffa9\046\uffa9\050\uffa9\053" +
    "\uffa9\064\uffa9\066\uffa9\101\uffa9\105\uffa9\110\uffa9\111\uffa9" +
    "\112\uffa9\113\uffa9\114\uffa9\115\uffa9\116\uffa9\117\uffa9\120" +
    "\uffa9\121\uffa9\122\uffa9\124\uffa9\125\uffa9\126\uffa9\127\uffa9" +
    "\130\uffa9\131\uffa9\132\uffa9\133\uffa9\134\uffa9\135\uffa9\136" +
    "\uffa9\137\uffa9\150\uffa9\151\uffa9\001\002\000\116\013\uffab" +
    "\024\uffab\025\uffab\042\uffab\043\uffab\045\uffab\046\uffab\050" +
    "\uffab\053\uffab\064\uffab\066\uffab\101\uffab\105\uffab\110\uffab" +
    "\111\uffab\112\uffab\113\uffab\114\uffab\115\uffab\116\uffab\117" +
    "\uffab\120\uffab\121\uffab\122\uffab\124\uffab\125\uffab\126\uffab" +
    "\127\uffab\130\uffab\131\uffab\132\uffab\133\uffab\134\uffab\135" +
    "\uffab\136\uffab\137\uffab\150\uffab\151\uffab\001\002\000\032" +
    "\013\uffde\043\uffde\045\uffde\053\uffde\101\uffde\110\uffde\114" +
    "\uffde\121\uffde\124\uffde\137\uffde\150\uffde\151\uffde\001\002" +
    "\000\116\013\uffa8\024\uffa8\025\uffa8\042\uffa8\043\uffa8\045" +
    "\uffa8\046\uffa8\050\uffa8\053\uffa8\064\uffa8\066\uffa8\101\uffa8" +
    "\105\uffa8\110\uffa8\111\uffa8\112\uffa8\113\uffa8\114\uffa8\115" +
    "\uffa8\116\uffa8\117\uffa8\120\uffa8\121\uffa8\122\uffa8\124\uffa8" +
    "\125\uffa8\126\uffa8\127\uffa8\130\uffa8\131\uffa8\132\uffa8\133" +
    "\uffa8\134\uffa8\135\uffa8\136\uffa8\137\uffa8\150\uffa8\151\uffa8" +
    "\001\002\000\034\013\ufff9\043\ufff9\045\ufff9\053\ufff9\064" +
    "\144\101\ufff9\110\ufff9\114\ufff9\121\ufff9\124\ufff9\137\ufff9" +
    "\150\ufff9\151\ufff9\001\002\000\004\113\266\001\002\000" +
    "\040\013\ufffb\024\053\025\050\043\ufffb\045\ufffb\053\ufffb" +
    "\064\ufffb\101\ufffb\110\ufffb\114\ufffb\121\ufffb\124\ufffb\137" +
    "\ufffb\150\ufffb\151\ufffb\001\002\000\032\013\uffda\043\uffda" +
    "\045\uffda\053\uffda\101\uffda\110\uffda\114\uffda\121\uffda\124" +
    "\uffda\137\uffda\150\uffda\151\uffda\001\002\000\040\005\064" +
    "\047\074\050\056\051\100\113\055\117\054\120\067\143" +
    "\034\144\045\152\023\153\073\154\071\155\075\156\024" +
    "\157\057\001\002\000\032\013\uffd7\043\uffd7\045\uffd7\053" +
    "\uffd7\101\uffd7\110\uffd7\114\uffd7\121\uffd7\124\uffd7\137\uffd7" +
    "\150\uffd7\151\uffd7\001\002\000\032\013\uffd6\043\uffd6\045" +
    "\uffd6\053\uffd6\101\uffd6\110\uffd6\114\uffd6\121\uffd6\124\uffd6" +
    "\137\uffd6\150\uffd6\151\uffd6\001\002\000\040\005\064\047" +
    "\074\050\056\051\100\113\055\117\054\120\067\143\034" +
    "\144\045\152\023\153\073\154\071\155\075\156\024\157" +
    "\057\001\002\000\030\047\uff6c\051\uff6c\113\uff6c\143\uff6c" +
    "\144\uff6c\152\uff6c\153\uff6c\154\uff6c\155\uff6c\156\uff6c\157" +
    "\uff6c\001\002\000\042\005\064\047\074\050\056\051\100" +
    "\054\212\113\055\117\054\120\067\143\034\144\045\152" +
    "\023\153\073\154\071\155\075\156\024\157\057\001\002" +
    "\000\030\047\uff6a\051\uff6a\113\uff6a\143\uff6a\144\uff6a\152" +
    "\uff6a\153\uff6a\154\uff6a\155\uff6a\156\uff6a\157\uff6a\001\002" +
    "\000\102\013\uffa1\042\uffa1\043\uffa1\045\uffa1\046\uffa1\050" +
    "\uffa1\053\uffa1\064\uffa1\066\uffa1\101\uffa1\110\uffa1\111\uffa1" +
    "\114\uffa1\115\uffa1\116\uffa1\117\uffa1\120\uffa1\121\uffa1\124" +
    "\uffa1\125\uffa1\126\uffa1\127\uffa1\130\uffa1\131\uffa1\132\uffa1" +
    "\133\uffa1\134\uffa1\135\uffa1\136\uffa1\137\uffa1\150\uffa1\151" +
    "\uffa1\001\002\000\102\013\uff78\042\uff78\043\uff78\045\uff78" +
    "\046\uff78\050\uff78\053\uff78\064\uff78\066\uff78\101\uff78\110" +
    "\uff78\111\uff78\114\uff78\115\uff78\116\uff78\117\uff78\120\uff78" +
    "\121\uff78\124\uff78\125\uff78\126\uff78\127\uff78\130\uff78\131" +
    "\uff78\132\uff78\133\uff78\134\uff78\135\uff78\136\uff78\137\uff78" +
    "\150\uff78\151\uff78\001\002\000\102\013\uff7a\042\uff7a\043" +
    "\uff7a\045\uff7a\046\uff7a\050\uff7a\053\uff7a\064\uff7a\066\uff7a" +
    "\101\uff7a\110\uff7a\111\uff7a\114\uff7a\115\uff7a\116\uff7a\117" +
    "\uff7a\120\uff7a\121\uff7a\124\uff7a\125\uff7a\126\uff7a\127\uff7a" +
    "\130\uff7a\131\uff7a\132\uff7a\133\uff7a\134\uff7a\135\uff7a\136" +
    "\uff7a\137\uff7a\150\uff7a\151\uff7a\001\002\000\100\013\uff7f" +
    "\042\uff7f\043\uff7f\045\uff7f\046\uff7f\050\uff7f\053\uff7f\064" +
    "\uff7f\066\uff7f\101\uff7f\110\uff7f\111\uff7f\114\uff7f\115\uff7f" +
    "\116\uff7f\117\uff7f\120\uff7f\121\uff7f\124\uff7f\125\uff7f\126" +
    "\uff7f\127\uff7f\130\uff7f\131\uff7f\132\uff7f\133\uff7f\134\uff7f" +
    "\135\uff7f\137\uff7f\150\uff7f\151\uff7f\001\002\000\100\013" +
    "\uff81\042\uff81\043\uff81\045\uff81\046\246\050\uff81\053\uff81" +
    "\064\uff81\066\251\101\uff81\110\uff81\111\uff81\114\uff81\115" +
    "\252\116\250\117\uff81\120\uff81\121\uff81\124\uff81\125\uff81" +
    "\126\uff81\127\uff81\130\uff81\131\uff81\132\uff81\133\uff81\134" +
    "\uff81\135\uff81\137\uff81\150\uff81\151\uff81\001\002\000\030" +
    "\047\uff69\051\uff69\113\uff69\143\uff69\144\uff69\152\uff69\153" +
    "\uff69\154\uff69\155\uff69\156\uff69\157\uff69\001\002\000\034" +
    "\013\uffd4\043\uffd4\045\uffd4\053\uffd4\064\144\101\uffd4\110" +
    "\uffd4\114\uffd4\121\uffd4\124\uffd4\137\uffd4\150\uffd4\151\uffd4" +
    "\001\002\000\102\013\uff7d\042\uff7d\043\uff7d\045\uff7d\046" +
    "\uff7d\050\uff7d\053\uff7d\064\uff7d\066\uff7d\101\uff7d\110\uff7d" +
    "\111\uff7d\114\uff7d\115\uff7d\116\uff7d\117\uff7d\120\uff7d\121" +
    "\uff7d\124\uff7d\125\uff7d\126\uff7d\127\uff7d\130\uff7d\131\uff7d" +
    "\132\uff7d\133\uff7d\134\uff7d\135\uff7d\136\255\137\uff7d\150" +
    "\uff7d\151\uff7d\001\002\000\030\047\uff6b\051\uff6b\113\uff6b" +
    "\143\uff6b\144\uff6b\152\uff6b\153\uff6b\154\uff6b\155\uff6b\156" +
    "\uff6b\157\uff6b\001\002\000\070\013\uff83\042\uff83\043\uff83" +
    "\045\uff83\050\uff83\053\uff83\064\uff83\101\uff83\110\uff83\111" +
    "\244\114\uff83\117\241\120\242\121\uff83\124\uff83\125\uff83" +
    "\126\uff83\127\uff83\130\uff83\131\uff83\132\uff83\133\uff83\134" +
    "\uff83\135\uff83\137\uff83\150\uff83\151\uff83\001\002\000\102" +
    "\013\uffa3\042\uffa3\043\uffa3\045\uffa3\046\uffa3\050\uffa3\053" +
    "\uffa3\064\uffa3\066\uffa3\101\uffa3\110\uffa3\111\uffa3\114\uffa3" +
    "\115\uffa3\116\uffa3\117\uffa3\120\uffa3\121\uffa3\124\uffa3\125" +
    "\uffa3\126\uffa3\127\uffa3\130\uffa3\131\uffa3\132\uffa3\133\uffa3" +
    "\134\uffa3\135\uffa3\136\uffa3\137\uffa3\150\uffa3\151\uffa3\001" +
    "\002\000\102\013\uff7b\042\uff7b\043\uff7b\045\uff7b\046\uff7b" +
    "\050\uff7b\053\uff7b\064\uff7b\066\uff7b\101\uff7b\110\uff7b\111" +
    "\uff7b\114\uff7b\115\uff7b\116\uff7b\117\uff7b\120\uff7b\121\uff7b" +
    "\124\uff7b\125\uff7b\126\uff7b\127\uff7b\130\uff7b\131\uff7b\132" +
    "\uff7b\133\uff7b\134\uff7b\135\uff7b\136\uff7b\137\uff7b\150\uff7b" +
    "\151\uff7b\001\002\000\102\013\uffa4\042\uffa4\043\uffa4\045" +
    "\uffa4\046\uffa4\050\uffa4\053\uffa4\064\uffa4\066\uffa4\101\uffa4" +
    "\110\uffa4\111\uffa4\114\uffa4\115\uffa4\116\uffa4\117\uffa4\120" +
    "\uffa4\121\uffa4\124\uffa4\125\uffa4\126\uffa4\127\uffa4\130\uffa4" +
    "\131\uffa4\132\uffa4\133\uffa4\134\uffa4\135\uffa4\136\uffa4\137" +
    "\uffa4\150\uffa4\151\uffa4\001\002\000\012\143\034\144\045" +
    "\152\023\156\024\001\002\000\102\013\uffa2\042\uffa2\043" +
    "\uffa2\045\uffa2\046\uffa2\050\uffa2\053\uffa2\064\uffa2\066\uffa2" +
    "\101\uffa2\110\uffa2\111\uffa2\114\uffa2\115\uffa2\116\uffa2\117" +
    "\uffa2\120\uffa2\121\uffa2\124\uffa2\125\uffa2\126\uffa2\127\uffa2" +
    "\130\uffa2\131\uffa2\132\uffa2\133\uffa2\134\uffa2\135\uffa2\136" +
    "\uffa2\137\uffa2\150\uffa2\151\uffa2\001\002\000\102\013\uff77" +
    "\042\uff77\043\uff77\045\uff77\046\uff77\050\uff77\053\uff77\064" +
    "\uff77\066\uff77\101\uff77\110\uff77\111\uff77\114\uff77\115\uff77" +
    "\116\uff77\117\uff77\120\uff77\121\uff77\124\uff77\125\uff77\126" +
    "\uff77\127\uff77\130\uff77\131\uff77\132\uff77\133\uff77\134\uff77" +
    "\135\uff77\136\uff77\137\uff77\150\uff77\151\uff77\001\002\000" +
    "\030\047\074\051\100\113\055\143\034\144\045\152\023" +
    "\153\073\154\071\155\075\156\024\157\057\001\002\000" +
    "\102\013\uffa0\042\uffa0\043\uffa0\045\uffa0\046\uffa0\050\uffa0" +
    "\053\uffa0\064\uffa0\066\uffa0\101\uffa0\110\uffa0\111\uffa0\114" +
    "\uffa0\115\uffa0\116\uffa0\117\uffa0\120\uffa0\121\uffa0\124\uffa0" +
    "\125\uffa0\126\uffa0\127\uffa0\130\uffa0\131\uffa0\132\uffa0\133" +
    "\uffa0\134\uffa0\135\uffa0\136\uffa0\137\uffa0\150\uffa0\151\uffa0" +
    "\001\002\000\110\013\uff79\042\uff79\043\uff79\045\uff79\046" +
    "\uff79\050\uff79\053\uff79\064\uff79\066\uff79\101\uff79\110\uff79" +
    "\111\uff79\112\104\113\105\114\uff79\115\uff79\116\uff79\117" +
    "\uff79\120\uff79\121\uff79\122\102\124\uff79\125\uff79\126\uff79" +
    "\127\uff79\130\uff79\131\uff79\132\uff79\133\uff79\134\uff79\135" +
    "\uff79\136\uff79\137\uff79\150\uff79\151\uff79\001\002\000\010" +
    "\012\235\152\023\156\024\001\002\000\116\013\uff0f\024" +
    "\uff0f\025\uff0f\042\uff0f\043\uff0f\045\uff0f\046\uff0f\050\uff0f" +
    "\053\uff0f\064\uff0f\066\uff0f\101\uff0f\105\uff0f\110\uff0f\111" +
    "\uff0f\112\uff0f\113\uff0f\114\uff0f\115\uff0f\116\uff0f\117\uff0f" +
    "\120\uff0f\121\uff0f\122\uff0f\124\uff0f\125\uff0f\126\uff0f\127" +
    "\uff0f\130\uff0f\131\uff0f\132\uff0f\133\uff0f\134\uff0f\135\uff0f" +
    "\136\uff0f\137\uff0f\150\uff0f\151\uff0f\001\002\000\004\113" +
    "\202\001\002\000\042\005\064\047\074\050\056\051\100" +
    "\113\055\114\115\117\054\120\067\143\034\144\045\152" +
    "\023\153\073\154\071\155\075\156\024\157\057\001\002" +
    "\000\016\045\uff95\101\uff95\114\uff95\121\uff95\124\uff95\150" +
    "\177\001\002\000\016\045\uff97\053\175\101\uff97\114\uff97" +
    "\121\uff97\124\uff97\001\002\000\070\013\uffab\042\uffab\046" +
    "\uffab\050\uffab\053\uffab\066\uffab\110\uffab\111\uffab\112\uffab" +
    "\113\uffab\114\uffab\115\uffab\116\uffab\117\uffab\120\uffab\121" +
    "\uffab\122\uffab\125\uffab\126\uffab\127\uffab\130\uffab\131\uffab" +
    "\132\uffab\134\173\136\uffab\150\uffab\151\uffab\001\002\000" +
    "\026\013\162\045\uff99\053\165\101\uff99\110\164\114\uff99" +
    "\121\uff99\124\uff99\150\163\151\161\001\002\000\006\114" +
    "\ufff5\121\ufff5\001\002\000\006\114\157\121\156\001\002" +
    "\000\016\045\uff94\101\uff94\114\uff94\121\uff94\124\uff94\151" +
    "\154\001\002\000\116\013\uff10\024\uff10\025\uff10\042\uff10" +
    "\043\uff10\045\uff10\046\uff10\050\uff10\053\uff10\064\uff10\066" +
    "\uff10\101\uff10\105\uff10\110\uff10\111\uff10\112\uff10\113\uff10" +
    "\114\uff10\115\uff10\116\uff10\117\uff10\120\uff10\121\uff10\122" +
    "\uff10\124\uff10\125\uff10\126\uff10\127\uff10\130\uff10\131\uff10" +
    "\132\uff10\133\uff10\134\uff10\135\uff10\136\uff10\137\uff10\150" +
    "\uff10\151\uff10\001\002\000\016\013\152\045\uff98\101\uff98" +
    "\114\uff98\121\uff98\124\uff98\001\002\000\016\045\uff96\101" +
    "\uff96\110\150\114\uff96\121\uff96\124\uff96\001\002\000\006" +
    "\114\ufff7\121\ufff7\001\002\000\046\013\uff89\042\123\045" +
    "\uff89\050\131\053\uff89\101\uff89\110\uff89\114\uff89\121\uff89" +
    "\124\uff89\125\127\126\133\127\125\130\130\131\122\132" +
    "\132\150\uff89\151\uff89\001\002\000\040\005\uff71\047\uff71" +
    "\050\uff71\051\uff71\113\uff71\117\uff71\120\uff71\143\uff71\144" +
    "\uff71\152\uff71\153\uff71\154\uff71\155\uff71\156\uff71\157\uff71" +
    "\001\002\000\046\005\uff85\047\uff85\050\uff85\051\uff85\113" +
    "\uff85\117\uff85\120\uff85\143\uff85\144\uff85\145\uff85\146\uff85" +
    "\147\uff85\152\uff85\153\uff85\154\uff85\155\uff85\156\uff85\157" +
    "\uff85\001\002\000\040\005\064\047\074\050\056\051\100" +
    "\113\055\117\054\120\067\143\034\144\045\152\023\153" +
    "\073\154\071\155\075\156\024\157\057\001\002\000\040" +
    "\005\uff75\047\uff75\050\uff75\051\uff75\113\uff75\117\uff75\120" +
    "\uff75\143\uff75\144\uff75\152\uff75\153\uff75\154\uff75\155\uff75" +
    "\156\uff75\157\uff75\001\002\000\046\005\064\047\074\050" +
    "\056\051\100\113\055\117\054\120\067\143\034\144\045" +
    "\145\035\146\033\147\046\152\023\153\073\154\071\155" +
    "\075\156\024\157\057\001\002\000\040\005\uff72\047\uff72" +
    "\050\uff72\051\uff72\113\uff72\117\uff72\120\uff72\143\uff72\144" +
    "\uff72\152\uff72\153\uff72\154\uff72\155\uff72\156\uff72\157\uff72" +
    "\001\002\000\040\005\uff74\047\uff74\050\uff74\051\uff74\113" +
    "\uff74\117\uff74\120\uff74\143\uff74\144\uff74\152\uff74\153\uff74" +
    "\154\uff74\155\uff74\156\uff74\157\uff74\001\002\000\004\042" +
    "\134\001\002\000\040\005\uff70\047\uff70\050\uff70\051\uff70" +
    "\113\uff70\117\uff70\120\uff70\143\uff70\144\uff70\152\uff70\153" +
    "\uff70\154\uff70\155\uff70\156\uff70\157\uff70\001\002\000\040" +
    "\005\uff73\047\uff73\050\uff73\051\uff73\113\uff73\117\uff73\120" +
    "\uff73\143\uff73\144\uff73\152\uff73\153\uff73\154\uff73\155\uff73" +
    "\156\uff73\157\uff73\001\002\000\046\005\uff84\047\uff84\050" +
    "\uff84\051\uff84\113\uff84\117\uff84\120\uff84\143\uff84\144\uff84" +
    "\145\uff84\146\uff84\147\uff84\152\uff84\153\uff84\154\uff84\155" +
    "\uff84\156\uff84\157\uff84\001\002\000\026\013\uff87\045\uff87" +
    "\053\uff87\101\uff87\110\uff87\114\uff87\121\uff87\124\uff87\150" +
    "\uff87\151\uff87\001\002\000\064\013\uffe0\024\053\025\050" +
    "\045\uffe0\046\uff79\053\uffe0\064\144\066\uff79\101\uffe0\110" +
    "\uffe0\111\uff79\112\104\113\105\114\uffe0\115\uff79\116\uff79" +
    "\117\uff79\120\uff79\121\uffe0\122\102\124\uffe0\135\uff79\136" +
    "\uff79\150\uffe0\151\uffe0\001\002\000\026\013\uff86\045\uff86" +
    "\053\uff86\101\uff86\110\uff86\114\uff86\121\uff86\124\uff86\150" +
    "\uff86\151\uff86\001\002\000\004\135\141\001\002\000\040" +
    "\005\064\047\074\050\056\051\100\113\055\117\054\120" +
    "\067\143\034\144\045\152\023\153\073\154\071\155\075" +
    "\156\024\157\057\001\002\000\036\013\uffd8\043\uffd8\045" +
    "\uffd8\053\uffd8\101\uffd8\110\uffd8\114\uffd8\121\uffd8\124\uffd8" +
    "\133\uffd8\134\uffd8\137\uffd8\150\uffd8\151\uffd8\001\002\000" +
    "\032\013\uffdd\043\uffdd\045\uffdd\053\uffdd\101\uffdd\110\uffdd" +
    "\114\uffdd\121\uffdd\124\uffdd\137\uffdd\150\uffdd\151\uffdd\001" +
    "\002\000\040\005\064\047\074\050\056\051\100\113\055" +
    "\117\054\120\067\143\034\144\045\152\023\153\073\154" +
    "\071\155\075\156\024\157\057\001\002\000\032\013\uffdc" +
    "\043\uffdc\045\uffdc\053\uffdc\101\uffdc\110\uffdc\114\uffdc\121" +
    "\uffdc\124\uffdc\137\uffdc\150\uffdc\151\uffdc\001\002\000\036" +
    "\013\uffd9\043\uffd9\045\uffd9\053\uffd9\101\uffd9\110\uffd9\114" +
    "\uffd9\121\uffd9\124\uffd9\133\uffd9\134\uffd9\137\uffd9\150\uffd9" +
    "\151\uffd9\001\002\000\026\013\uff88\045\uff88\053\uff88\101" +
    "\uff88\110\uff88\114\uff88\121\uff88\124\uff88\150\uff88\151\uff88" +
    "\001\002\000\040\005\064\047\074\050\056\051\100\113" +
    "\055\117\054\120\067\143\034\144\045\152\023\153\073" +
    "\154\071\155\075\156\024\157\057\001\002\000\016\045" +
    "\uff8e\101\uff8e\110\uff8e\114\uff8e\121\uff8e\124\uff8e\001\002" +
    "\000\040\005\064\047\074\050\056\051\100\113\055\117" +
    "\054\120\067\143\034\144\045\152\023\153\073\154\071" +
    "\155\075\156\024\157\057\001\002\000\016\013\uff92\045" +
    "\uff92\101\uff92\114\uff92\121\uff92\124\uff92\001\002\000\040" +
    "\005\064\047\074\050\056\051\100\113\055\117\054\120" +
    "\067\143\034\144\045\152\023\153\073\154\071\155\075" +
    "\156\024\157\057\001\002\000\016\045\uff8a\101\uff8a\114" +
    "\uff8a\121\uff8a\124\uff8a\151\uff8a\001\002\000\040\005\064" +
    "\047\074\050\056\051\100\113\055\117\054\120\067\143" +
    "\034\144\045\152\023\153\073\154\071\155\075\156\024" +
    "\157\057\001\002\000\116\013\uff0c\024\uff0c\025\uff0c\042" +
    "\uff0c\043\uff0c\045\uff0c\046\uff0c\050\uff0c\053\uff0c\064\uff0c" +
    "\066\uff0c\101\uff0c\105\uff0c\110\uff0c\111\uff0c\112\uff0c\113" +
    "\uff0c\114\uff0c\115\uff0c\116\uff0c\117\uff0c\120\uff0c\121\uff0c" +
    "\122\uff0c\124\uff0c\125\uff0c\126\uff0c\127\uff0c\130\uff0c\131" +
    "\uff0c\132\uff0c\133\uff0c\134\uff0c\135\uff0c\136\uff0c\137\uff0c" +
    "\150\uff0c\151\uff0c\001\002\000\006\114\ufff6\121\ufff6\001" +
    "\002\000\040\005\064\047\074\050\056\051\100\113\055" +
    "\117\054\120\067\143\034\144\045\152\023\153\073\154" +
    "\071\155\075\156\024\157\057\001\002\000\040\005\064" +
    "\047\074\050\056\051\100\113\055\117\054\120\067\143" +
    "\034\144\045\152\023\153\073\154\071\155\075\156\024" +
    "\157\057\001\002\000\040\005\064\047\074\050\056\051" +
    "\100\113\055\117\054\120\067\143\034\144\045\152\023" +
    "\153\073\154\071\155\075\156\024\157\057\001\002\000" +
    "\040\005\064\047\074\050\056\051\100\113\055\117\054" +
    "\120\067\143\034\144\045\152\023\153\073\154\071\155" +
    "\075\156\024\157\057\001\002\000\040\005\064\047\074" +
    "\050\056\051\100\113\055\117\054\120\067\143\034\144" +
    "\045\152\023\153\073\154\071\155\075\156\024\157\057" +
    "\001\002\000\016\045\uff91\053\uff91\101\uff91\114\uff91\121" +
    "\uff91\124\uff91\001\002\000\016\045\uff8f\101\uff8f\110\uff8f" +
    "\114\uff8f\121\uff8f\124\uff8f\001\002\000\016\045\uff8d\101" +
    "\uff8d\114\uff8d\121\uff8d\124\uff8d\150\uff8d\001\002\000\016" +
    "\013\uff93\045\uff93\101\uff93\114\uff93\121\uff93\124\uff93\001" +
    "\002\000\016\045\uff8b\101\uff8b\114\uff8b\121\uff8b\124\uff8b" +
    "\151\uff8b\001\002\000\040\005\064\047\074\050\056\051" +
    "\100\113\055\117\054\120\067\143\034\144\045\152\023" +
    "\153\073\154\071\155\075\156\024\157\057\001\002\000" +
    "\006\114\ufff4\121\ufff4\001\002\000\040\005\064\047\074" +
    "\050\056\051\100\113\055\117\054\120\067\143\034\144" +
    "\045\152\023\153\073\154\071\155\075\156\024\157\057" +
    "\001\002\000\016\045\uff90\053\uff90\101\uff90\114\uff90\121" +
    "\uff90\124\uff90\001\002\000\040\005\064\047\074\050\056" +
    "\051\100\113\055\117\054\120\067\143\034\144\045\152" +
    "\023\153\073\154\071\155\075\156\024\157\057\001\002" +
    "\000\016\045\uff8c\101\uff8c\114\uff8c\121\uff8c\124\uff8c\150" +
    "\uff8c\001\002\000\102\013\uff63\042\uff63\043\uff63\045\uff63" +
    "\046\uff63\050\uff63\053\uff63\064\uff63\066\uff63\101\uff63\110" +
    "\uff63\111\uff63\114\uff63\115\uff63\116\uff63\117\uff63\120\uff63" +
    "\121\uff63\124\uff63\125\uff63\126\uff63\127\uff63\130\uff63\131" +
    "\uff63\132\uff63\133\uff63\134\uff63\135\uff63\136\uff63\137\uff63" +
    "\150\uff63\151\uff63\001\002\000\042\005\064\047\074\050" +
    "\056\051\100\054\212\113\055\117\054\120\067\143\034" +
    "\144\045\152\023\153\073\154\071\155\075\156\024\157" +
    "\057\001\002\000\006\114\233\121\232\001\002\000\006" +
    "\133\221\134\227\001\002\000\006\133\uffb5\134\uffb5\001" +
    "\002\000\076\013\uff79\042\uff79\046\uff79\050\uff79\053\uff79" +
    "\064\144\066\uff79\110\uff79\111\uff79\112\104\113\105\114" +
    "\uff79\115\uff79\116\uff79\117\uff79\120\uff79\121\uff79\122\102" +
    "\125\uff79\126\uff79\127\uff79\130\uff79\131\uff79\132\uff79\133" +
    "\uff79\134\uff79\135\uff79\136\uff79\150\uff79\151\uff79\001\002" +
    "\000\006\114\225\121\uff9b\001\002\000\006\133\uffb4\134" +
    "\uffb4\001\002\000\004\121\214\001\002\000\006\133\uffb7" +
    "\134\uffb7\001\002\000\046\013\uff89\042\123\050\131\053" +
    "\uff89\110\uff89\114\uff89\121\uff89\125\127\126\133\127\125" +
    "\130\130\131\122\132\132\133\uffb8\134\uffb8\135\141\150" +
    "\uff89\151\uff89\001\002\000\042\005\064\047\074\050\056" +
    "\051\100\054\212\113\055\117\054\120\067\143\034\144" +
    "\045\152\023\153\073\154\071\155\075\156\024\157\057" +
    "\001\002\000\006\133\221\134\220\001\002\000\006\114" +
    "\uff9b\121\uff9b\001\002\000\006\114\uff9d\121\uff9d\001\002" +
    "\000\040\005\064\047\074\050\056\051\100\113\055\117" +
    "\054\120\067\143\034\144\045\152\023\153\073\154\071" +
    "\155\075\156\024\157\057\001\002\000\042\005\064\047" +
    "\074\050\056\051\100\054\212\113\055\117\054\120\067" +
    "\143\034\144\045\152\023\153\073\154\071\155\075\156" +
    "\024\157\057\001\002\000\006\133\uffb3\134\uffb3\001\002" +
    "\000\010\133\uffb8\134\uffb8\135\141\001\002\000\006\114" +
    "\uff9a\121\uff9a\001\002\000\102\013\uff64\042\uff64\043\uff64" +
    "\045\uff64\046\uff64\050\uff64\053\uff64\064\uff64\066\uff64\101" +
    "\uff64\110\uff64\111\uff64\114\uff64\115\uff64\116\uff64\117\uff64" +
    "\120\uff64\121\uff64\124\uff64\125\uff64\126\uff64\127\uff64\130" +
    "\uff64\131\uff64\132\uff64\133\uff64\134\uff64\135\uff64\136\uff64" +
    "\137\uff64\150\uff64\151\uff64\001\002\000\006\133\uffb6\134" +
    "\uffb6\001\002\000\040\005\064\047\074\050\056\051\100" +
    "\113\055\117\054\120\067\143\034\144\045\152\023\153" +
    "\073\154\071\155\075\156\024\157\057\001\002\000\006" +
    "\114\231\121\uff9a\001\002\000\102\013\uff9e\042\uff9e\043" +
    "\uff9e\045\uff9e\046\uff9e\050\uff9e\053\uff9e\064\uff9e\066\uff9e" +
    "\101\uff9e\110\uff9e\111\uff9e\114\uff9e\115\uff9e\116\uff9e\117" +
    "\uff9e\120\uff9e\121\uff9e\124\uff9e\125\uff9e\126\uff9e\127\uff9e" +
    "\130\uff9e\131\uff9e\132\uff9e\133\uff9e\134\uff9e\135\uff9e\136" +
    "\uff9e\137\uff9e\150\uff9e\151\uff9e\001\002\000\042\005\064" +
    "\047\074\050\056\051\100\054\212\113\055\117\054\120" +
    "\067\143\034\144\045\152\023\153\073\154\071\155\075" +
    "\156\024\157\057\001\002\000\102\013\uff9f\042\uff9f\043" +
    "\uff9f\045\uff9f\046\uff9f\050\uff9f\053\uff9f\064\uff9f\066\uff9f" +
    "\101\uff9f\110\uff9f\111\uff9f\114\uff9f\115\uff9f\116\uff9f\117" +
    "\uff9f\120\uff9f\121\uff9f\124\uff9f\125\uff9f\126\uff9f\127\uff9f" +
    "\130\uff9f\131\uff9f\132\uff9f\133\uff9f\134\uff9f\135\uff9f\136" +
    "\uff9f\137\uff9f\150\uff9f\151\uff9f\001\002\000\006\114\uff9c" +
    "\121\uff9c\001\002\000\116\013\uffa6\024\uffa6\025\uffa6\042" +
    "\uffa6\043\uffa6\045\uffa6\046\uffa6\050\uffa6\053\uffa6\064\uffa6" +
    "\066\uffa6\101\uffa6\105\uffa6\110\uffa6\111\uffa6\112\uffa6\113" +
    "\uffa6\114\uffa6\115\uffa6\116\uffa6\117\uffa6\120\uffa6\121\uffa6" +
    "\122\uffa6\124\uffa6\125\uffa6\126\uffa6\127\uffa6\130\uffa6\131" +
    "\uffa6\132\uffa6\133\uffa6\134\uffa6\135\uffa6\136\uffa6\137\uffa6" +
    "\150\uffa6\151\uffa6\001\002\000\116\013\uffa7\024\uffa7\025" +
    "\uffa7\042\uffa7\043\uffa7\045\uffa7\046\uffa7\050\uffa7\053\uffa7" +
    "\064\uffa7\066\uffa7\101\uffa7\105\uffa7\110\uffa7\111\uffa7\112" +
    "\uffa7\113\uffa7\114\uffa7\115\uffa7\116\uffa7\117\uffa7\120\uffa7" +
    "\121\uffa7\122\uffa7\124\uffa7\125\uffa7\126\uffa7\127\uffa7\130" +
    "\uffa7\131\uffa7\132\uffa7\133\uffa7\134\uffa7\135\uffa7\136\uffa7" +
    "\137\uffa7\150\uffa7\151\uffa7\001\002\000\116\013\uffa5\024" +
    "\uffa5\025\uffa5\042\uffa5\043\uffa5\045\uffa5\046\uffa5\050\uffa5" +
    "\053\uffa5\064\uffa5\066\uffa5\101\uffa5\105\uffa5\110\uffa5\111" +
    "\uffa5\112\uffa5\113\uffa5\114\uffa5\115\uffa5\116\uffa5\117\uffa5" +
    "\120\uffa5\121\uffa5\122\uffa5\124\uffa5\125\uffa5\126\uffa5\127" +
    "\uffa5\130\uffa5\131\uffa5\132\uffa5\133\uffa5\134\uffa5\135\uffa5" +
    "\136\uffa5\137\uffa5\150\uffa5\151\uffa5\001\002\000\070\013" +
    "\uff82\042\uff82\043\uff82\045\uff82\050\uff82\053\uff82\064\uff82" +
    "\101\uff82\110\uff82\111\244\114\uff82\117\241\120\242\121" +
    "\uff82\124\uff82\125\uff82\126\uff82\127\uff82\130\uff82\131\uff82" +
    "\132\uff82\133\uff82\134\uff82\135\uff82\137\uff82\150\uff82\151" +
    "\uff82\001\002\000\030\047\uff6f\051\uff6f\113\uff6f\143\uff6f" +
    "\144\uff6f\152\uff6f\153\uff6f\154\uff6f\155\uff6f\156\uff6f\157" +
    "\uff6f\001\002\000\030\047\uff6e\051\uff6e\113\uff6e\143\uff6e" +
    "\144\uff6e\152\uff6e\153\uff6e\154\uff6e\155\uff6e\156\uff6e\157" +
    "\uff6e\001\002\000\030\047\074\051\100\113\055\143\034" +
    "\144\045\152\023\153\073\154\071\155\075\156\024\157" +
    "\057\001\002\000\030\047\uff6d\051\uff6d\113\uff6d\143\uff6d" +
    "\144\uff6d\152\uff6d\153\uff6d\154\uff6d\155\uff6d\156\uff6d\157" +
    "\uff6d\001\002\000\100\013\uff80\042\uff80\043\uff80\045\uff80" +
    "\046\246\050\uff80\053\uff80\064\uff80\066\251\101\uff80\110" +
    "\uff80\111\uff80\114\uff80\115\252\116\250\117\uff80\120\uff80" +
    "\121\uff80\124\uff80\125\uff80\126\uff80\127\uff80\130\uff80\131" +
    "\uff80\132\uff80\133\uff80\134\uff80\135\uff80\137\uff80\150\uff80" +
    "\151\uff80\001\002\000\030\047\uff66\051\uff66\113\uff66\143" +
    "\uff66\144\uff66\152\uff66\153\uff66\154\uff66\155\uff66\156\uff66" +
    "\157\uff66\001\002\000\030\047\074\051\100\113\055\143" +
    "\034\144\045\152\023\153\073\154\071\155\075\156\024" +
    "\157\057\001\002\000\030\047\uff67\051\uff67\113\uff67\143" +
    "\uff67\144\uff67\152\uff67\153\uff67\154\uff67\155\uff67\156\uff67" +
    "\157\uff67\001\002\000\030\047\uff65\051\uff65\113\uff65\143" +
    "\uff65\144\uff65\152\uff65\153\uff65\154\uff65\155\uff65\156\uff65" +
    "\157\uff65\001\002\000\030\047\uff68\051\uff68\113\uff68\143" +
    "\uff68\144\uff68\152\uff68\153\uff68\154\uff68\155\uff68\156\uff68" +
    "\157\uff68\001\002\000\100\013\uff7e\042\uff7e\043\uff7e\045" +
    "\uff7e\046\uff7e\050\uff7e\053\uff7e\064\uff7e\066\uff7e\101\uff7e" +
    "\110\uff7e\111\uff7e\114\uff7e\115\uff7e\116\uff7e\117\uff7e\120" +
    "\uff7e\121\uff7e\124\uff7e\125\uff7e\126\uff7e\127\uff7e\130\uff7e" +
    "\131\uff7e\132\uff7e\133\uff7e\134\uff7e\135\uff7e\137\uff7e\150" +
    "\uff7e\151\uff7e\001\002\000\106\013\uff62\042\uff62\043\uff62" +
    "\045\uff62\046\uff62\050\uff62\053\uff62\064\uff62\066\uff62\101" +
    "\uff62\110\uff62\111\uff62\113\105\114\uff62\115\uff62\116\uff62" +
    "\117\uff62\120\uff62\121\uff62\122\102\124\uff62\125\uff62\126" +
    "\uff62\127\uff62\130\uff62\131\uff62\132\uff62\133\uff62\134\uff62" +
    "\135\uff62\136\uff62\137\uff62\150\uff62\151\uff62\001\002\000" +
    "\030\047\074\051\100\113\055\143\034\144\045\152\023" +
    "\153\073\154\071\155\075\156\024\157\057\001\002\000" +
    "\100\013\uff7c\042\uff7c\043\uff7c\045\uff7c\046\uff7c\050\uff7c" +
    "\053\uff7c\064\uff7c\066\uff7c\101\uff7c\110\uff7c\111\uff7c\114" +
    "\uff7c\115\uff7c\116\uff7c\117\uff7c\120\uff7c\121\uff7c\124\uff7c" +
    "\125\uff7c\126\uff7c\127\uff7c\130\uff7c\131\uff7c\132\uff7c\133" +
    "\uff7c\134\uff7c\135\uff7c\137\uff7c\150\uff7c\151\uff7c\001\002" +
    "\000\032\013\uffd2\043\uffd2\045\uffd2\053\uffd2\101\uffd2\110" +
    "\uffd2\114\uffd2\121\uffd2\124\uffd2\137\uffd2\150\uffd2\151\uffd2" +
    "\001\002\000\032\013\uffd3\043\uffd3\045\uffd3\053\uffd3\101" +
    "\uffd3\110\uffd3\114\uffd3\121\uffd3\124\uffd3\137\uffd3\150\uffd3" +
    "\151\uffd3\001\002\000\006\114\262\121\uff9b\001\002\000" +
    "\102\013\uff76\042\uff76\043\uff76\045\uff76\046\uff76\050\uff76" +
    "\053\uff76\064\uff76\066\uff76\101\uff76\110\uff76\111\uff76\114" +
    "\uff76\115\uff76\116\uff76\117\uff76\120\uff76\121\uff76\124\uff76" +
    "\125\uff76\126\uff76\127\uff76\130\uff76\131\uff76\132\uff76\133" +
    "\uff76\134\uff76\135\uff76\136\uff76\137\uff76\150\uff76\151\uff76" +
    "\001\002\000\034\013\uffd4\043\uffd4\045\uffd4\053\uffd4\064" +
    "\144\101\uffd4\110\uffd4\114\uffd4\121\uffd4\124\uffd4\137\uffd4" +
    "\150\uffd4\151\uffd4\001\002\000\032\013\uffd5\043\uffd5\045" +
    "\uffd5\053\uffd5\101\uffd5\110\uffd5\114\uffd5\121\uffd5\124\uffd5" +
    "\137\uffd5\150\uffd5\151\uffd5\001\002\000\116\013\uff0d\024" +
    "\uff0d\025\uff0d\042\uff0d\043\uff0d\045\uff0d\046\uff0d\050\uff0d" +
    "\053\uff0d\064\uff0d\066\uff0d\101\uff0d\105\uff0d\110\uff0d\111" +
    "\uff0d\112\uff0d\113\uff0d\114\uff0d\115\uff0d\116\uff0d\117\uff0d" +
    "\120\uff0d\121\uff0d\122\uff0d\124\uff0d\125\uff0d\126\uff0d\127" +
    "\uff0d\130\uff0d\131\uff0d\132\uff0d\133\uff0d\134\uff0d\135\uff0d" +
    "\136\uff0d\137\uff0d\150\uff0d\151\uff0d\001\002\000\040\005" +
    "\064\047\074\050\056\051\100\113\055\117\054\120\067" +
    "\143\034\144\045\152\023\153\073\154\071\155\075\156" +
    "\024\157\057\001\002\000\032\013\uffdb\043\uffdb\045\uffdb" +
    "\053\uffdb\101\uffdb\110\uffdb\114\uffdb\121\uffdb\124\uffdb\137" +
    "\uffdb\150\uffdb\151\uffdb\001\002\000\020\003\uff27\016\uff27" +
    "\036\uff27\061\uff27\075\uff27\102\uff27\152\uff27\001\002\000" +
    "\116\013\uff0e\024\uff0e\025\uff0e\042\uff0e\043\uff0e\045\uff0e" +
    "\046\uff0e\050\uff0e\053\uff0e\064\uff0e\066\uff0e\101\uff0e\105" +
    "\uff0e\110\uff0e\111\uff0e\112\uff0e\113\uff0e\114\uff0e\115\uff0e" +
    "\116\uff0e\117\uff0e\120\uff0e\121\uff0e\122\uff0e\124\uff0e\125" +
    "\uff0e\126\uff0e\127\uff0e\130\uff0e\131\uff0e\132\uff0e\133\uff0e" +
    "\134\uff0e\135\uff0e\136\uff0e\137\uff0e\150\uff0e\151\uff0e\001" +
    "\002\000\006\114\uff23\124\317\001\002\000\006\121\311" +
    "\123\312\001\002\000\006\114\uff1f\124\uff1f\001\002\000" +
    "\006\121\276\123\277\001\002\000\004\152\023\001\002" +
    "\000\024\042\301\055\300\143\uff1b\144\uff1b\145\uff1b\146" +
    "\uff1b\147\uff1b\152\uff1b\156\uff1b\001\002\000\020\143\uff19" +
    "\144\uff19\145\uff19\146\uff19\147\uff19\152\uff19\156\uff19\001" +
    "\002\000\022\055\307\143\uff1a\144\uff1a\145\uff1a\146\uff1a" +
    "\147\uff1a\152\uff1a\156\uff1a\001\002\000\020\143\034\144" +
    "\045\145\035\146\033\147\046\152\023\156\024\001\002" +
    "\000\010\114\uffec\124\uffec\137\304\001\002\000\040\005" +
    "\064\047\074\050\056\051\100\113\055\117\054\120\067" +
    "\143\034\144\045\152\023\153\073\154\071\155\075\156" +
    "\024\157\057\001\002\000\006\114\uff1c\124\uff1c\001\002" +
    "\000\006\114\uffeb\124\uffeb\001\002\000\020\143\uff18\144" +
    "\uff18\145\uff18\146\uff18\147\uff18\152\uff18\156\uff18\001\002" +
    "\000\006\121\uffe7\123\uffe7\001\002\000\004\152\023\001" +
    "\002\000\024\042\301\055\300\143\uff1b\144\uff1b\145\uff1b" +
    "\146\uff1b\147\uff1b\152\uff1b\156\uff1b\001\002\000\020\143" +
    "\034\144\045\145\035\146\033\147\046\152\023\156\024" +
    "\001\002\000\010\114\uffec\124\uffec\137\304\001\002\000" +
    "\006\114\uff1d\124\uff1d\001\002\000\006\121\uffe8\123\uffe8" +
    "\001\002\000\004\152\023\001\002\000\004\114\321\001" +
    "\002\000\010\043\uff22\071\uff22\124\uff22\001\002\000\006" +
    "\114\uff1e\124\uff1e\001\002\000\004\002\001\001\002\000" +
    "\010\002\uff09\036\uff09\061\uff09\001\002\000\004\016\u012f" +
    "\001\002\000\020\003\340\016\uffb1\036\014\061\005\075" +
    "\333\102\335\152\023\001\002\000\020\003\uffef\016\uffef" +
    "\036\uffef\061\uffef\075\uffef\102\uffef\152\uffef\001\002\000" +
    "\020\003\uffae\016\uffae\036\uffae\061\uffae\075\uffae\102\uffae" +
    "\152\uffae\001\002\000\020\003\ufff3\016\ufff3\036\ufff3\061" +
    "\ufff3\075\ufff3\102\ufff3\152\ufff3\001\002\000\006\121\311" +
    "\123\u0126\001\002\000\004\152\023\001\002\000\020\003" +
    "\uffaf\016\uffaf\036\uffaf\061\uffaf\075\uffaf\102\uffaf\152\uffaf" +
    "\001\002\000\004\152\023\001\002\000\020\003\ufff0\016" +
    "\ufff0\036\ufff0\061\ufff0\075\ufff0\102\ufff0\152\ufff0\001\002" +
    "\000\020\003\ufff2\016\ufff2\036\ufff2\061\ufff2\075\ufff2\102" +
    "\ufff2\152\ufff2\001\002\000\004\124\356\001\002\000\006" +
    "\121\276\123\345\001\002\000\020\003\ufff1\016\ufff1\036" +
    "\ufff1\061\ufff1\075\ufff1\102\ufff1\152\ufff1\001\002\000\020" +
    "\003\uffe5\016\uffe5\036\uffe5\061\uffe5\075\uffe5\102\uffe5\152" +
    "\uffe5\001\002\000\020\003\uffad\016\uffad\036\uffad\061\uffad" +
    "\075\uffad\102\uffad\152\uffad\001\002\000\022\021\346\143" +
    "\000\144\000\145\000\146\000\147\000\152\000\156\000" +
    "\001\002\000\022\137\353\143\uffff\144\uffff\145\uffff\146" +
    "\uffff\147\uffff\152\uffff\156\uffff\001\002\000\020\143\034" +
    "\144\045\145\035\146\033\147\046\152\023\156\024\001" +
    "\002\000\006\124\uffec\137\304\001\002\000\004\124\352" +
    "\001\002\000\020\003\uffed\016\uffed\036\uffed\061\uffed\075" +
    "\uffed\102\uffed\152\uffed\001\002\000\040\005\064\047\074" +
    "\050\056\051\100\113\055\117\054\120\067\143\034\144" +
    "\045\152\023\153\073\154\071\155\075\156\024\157\057" +
    "\001\002\000\004\124\355\001\002\000\020\003\uffe9\016" +
    "\uffe9\036\uffe9\061\uffe9\075\uffe9\102\uffe9\152\uffe9\001\002" +
    "\000\020\003\uffac\016\uffac\036\uffac\061\uffac\075\uffac\102" +
    "\uffac\152\uffac\001\002\000\010\043\uffe4\113\361\124\uffe4" +
    "\001\002\000\006\043\u0101\124\u0100\001\002\000\004\152" +
    "\023\001\002\000\006\043\uffe3\124\uffe3\001\002\000\006" +
    "\114\uffbf\124\uffbf\001\002\000\006\114\375\124\376\001" +
    "\002\000\006\121\311\123\372\001\002\000\006\121\276" +
    "\123\367\001\002\000\020\143\034\144\045\145\035\146" +
    "\033\147\046\152\023\156\024\001\002\000\010\114\uffec" +
    "\124\uffec\137\304\001\002\000\006\114\uffbc\124\uffbc\001" +
    "\002\000\020\143\034\144\045\145\035\146\033\147\046" +
    "\152\023\156\024\001\002\000\010\114\uffec\124\uffec\137" +
    "\304\001\002\000\006\114\uffbd\124\uffbd\001\002\000\006" +
    "\043\uffc0\124\uffc0\001\002\000\004\152\023\001\002\000" +
    "\006\114\uffbe\124\uffbe\001\002\000\020\003\uffb2\016\uffb2" +
    "\036\uffb2\061\uffb2\075\uffb2\102\uffb2\152\uffb2\001\002\000" +
    "\004\065\u0102\001\002\000\014\003\uffce\020\uffce\031\uffce" +
    "\051\uffce\152\uffce\001\002\000\004\124\u0105\001\002\000" +
    "\004\124\uffe2\001\002\000\020\003\uffe6\016\uffe6\036\uffe6" +
    "\061\uffe6\075\uffe6\102\uffe6\152\uffe6\001\002\000\014\003" +
    "\uffc7\020\uffc7\031\uffc7\051\u0109\152\uffc7\001\002\000\014" +
    "\003\u0110\020\uffcb\031\uffcb\105\uffcb\152\023\001\002\000" +
    "\004\031\uffcd\001\002\000\004\124\uffc9\001\002\000\004" +
    "\124\u010b\001\002\000\006\031\uffc8\105\uffc8\001\002\000" +
    "\004\031\u010d\001\002\000\004\065\u010e\001\002\000\004" +
    "\124\uffcc\001\002\000\010\020\u0117\031\uffc5\105\uffc5\001" +
    "\002\000\014\003\uffc1\020\uffc1\031\uffc1\105\uffc1\152\uffc1" +
    "\001\002\000\004\124\uffc3\001\002\000\014\003\uffc6\020" +
    "\uffc6\031\uffc6\105\uffc6\152\uffc6\001\002\000\004\124\u0114" +
    "\001\002\000\014\003\uffc2\020\uffc2\031\uffc2\105\uffc2\152" +
    "\uffc2\001\002\000\006\031\uffc4\105\uffc4\001\002\000\006" +
    "\031\uffca\105\uffca\001\002\000\012\143\034\144\045\152" +
    "\023\156\024\001\002\000\010\043\u0119\113\105\122\102" +
    "\001\002\000\006\031\uffba\105\uffba\001\002\000\006\031" +
    "\u011c\105\u011b\001\002\000\042\005\064\047\074\050\056" +
    "\051\100\054\212\113\055\117\054\120\067\143\034\144" +
    "\045\152\023\153\073\154\071\155\075\156\024\157\057" +
    "\001\002\000\004\020\u011d\001\002\000\004\124\u011e\001" +
    "\002\000\006\031\uffbb\105\uffbb\001\002\000\006\133\221" +
    "\134\u0120\001\002\000\016\003\uffc7\020\uffc7\031\uffc7\051" +
    "\u0109\105\uffc7\152\uffc7\001\002\000\006\031\uffb9\105\uffb9" +
    "\001\002\000\004\043\u0123\001\002\000\020\143\034\144" +
    "\045\145\035\146\033\147\046\152\023\156\024\001\002" +
    "\000\004\124\u0125\001\002\000\020\003\uffe1\016\uffe1\036" +
    "\uffe1\061\uffe1\075\uffe1\102\uffe1\152\uffe1\001\002\000\022" +
    "\021\u0127\143\000\144\000\145\000\146\000\147\000\152" +
    "\000\156\000\001\002\000\022\137\u012c\143\uffff\144\uffff" +
    "\145\uffff\146\uffff\147\uffff\152\uffff\156\uffff\001\002\000" +
    "\020\143\034\144\045\145\035\146\033\147\046\152\023" +
    "\156\024\001\002\000\006\124\uffec\137\304\001\002\000" +
    "\004\124\u012b\001\002\000\020\003\uffee\016\uffee\036\uffee" +
    "\061\uffee\075\uffee\102\uffee\152\uffee\001\002\000\040\005" +
    "\064\047\074\050\056\051\100\113\055\117\054\120\067" +
    "\143\034\144\045\152\023\153\073\154\071\155\075\156" +
    "\024\157\057\001\002\000\004\124\u012e\001\002\000\020" +
    "\003\uffea\016\uffea\036\uffea\061\uffea\075\uffea\102\uffea\152" +
    "\uffea\001\002\000\042\003\uff17\016\uff17\022\uff17\034\uff17" +
    "\035\uff17\040\uff17\041\uff17\045\uff17\051\uff17\071\uff17\106" +
    "\uff17\140\uff17\143\uff17\144\uff17\152\uff17\156\uff17\001\002" +
    "\000\042\003\u0132\016\uff5c\022\uff5c\034\uff5c\035\uff5c\040" +
    "\uff5c\041\uff5c\045\uff5c\051\uff5c\071\uff5c\106\uff5c\140\uff5c" +
    "\143\uff5c\144\uff5c\152\uff5c\156\uff5c\001\002\000\044\003" +
    "\u0132\016\uff5c\022\uff5c\031\uff16\034\uff5c\035\uff5c\040\uff5c" +
    "\041\uff5c\045\uff5c\051\uff5c\071\uff5c\106\uff5c\140\uff5c\143" +
    "\uff5c\144\uff5c\152\uff5c\156\uff5c\001\002\000\050\003\uff5d" +
    "\016\uff5d\022\uff5d\027\uff5d\030\uff5d\031\uff5d\034\uff5d\035" +
    "\uff5d\040\uff5d\041\uff5d\045\uff5d\051\uff5d\071\uff5d\106\uff5d" +
    "\140\uff5d\143\uff5d\144\uff5d\152\uff5d\156\uff5d\001\002\000" +
    "\040\016\uff36\022\u014e\034\u0135\035\u014a\040\u0139\041\u013e" +
    "\045\uff3e\051\u014b\071\u013c\106\u013a\140\u0147\143\034\144" +
    "\045\152\023\156\024\001\002\000\050\003\uff61\016\uff61" +
    "\022\uff61\027\uff61\030\uff61\031\uff61\034\uff61\035\uff61\040" +
    "\uff61\041\uff61\045\uff61\051\uff61\071\uff61\106\uff61\140\uff61" +
    "\143\uff61\144\uff61\152\uff61\156\uff61\001\002\000\016\105" +
    "\uff33\124\uff33\143\034\144\045\152\023\156\024\001\002" +
    "\000\050\003\uff54\016\uff54\022\uff54\027\uff54\030\uff54\031" +
    "\uff54\034\uff54\035\uff54\040\uff54\041\uff54\045\uff54\051\uff54" +
    "\071\uff54\106\uff54\140\uff54\143\uff54\144\uff54\152\uff54\156" +
    "\uff54\001\002\000\016\112\uffab\113\uffab\122\uffab\123\u018b" +
    "\124\uffab\137\uffab\001\002\000\050\003\uff53\016\uff53\022" +
    "\uff53\027\uff53\030\uff53\031\uff53\034\uff53\035\uff53\040\uff53" +
    "\041\uff53\045\uff53\051\uff53\071\uff53\106\uff53\140\uff53\143" +
    "\uff53\144\uff53\152\uff53\156\uff53\001\002\000\012\143\034" +
    "\144\045\152\023\156\024\001\002\000\040\005\064\047" +
    "\074\050\056\051\100\113\055\117\054\120\067\143\034" +
    "\144\045\152\023\153\073\154\071\155\075\156\024\157" +
    "\057\001\002\000\050\003\uff5a\016\uff5a\022\uff5a\027\uff5a" +
    "\030\uff5a\031\uff5a\034\uff5a\035\uff5a\040\uff5a\041\uff5a\045" +
    "\uff5a\051\uff5a\071\uff5a\106\uff5a\140\uff5a\143\uff5a\144\uff5a" +
    "\152\uff5a\156\uff5a\001\002\000\042\005\064\047\074\050" +
    "\056\051\100\113\055\117\054\120\067\124\u0185\143\034" +
    "\144\045\152\023\153\073\154\071\155\075\156\024\157" +
    "\057\001\002\000\050\003\uff59\016\uff59\022\uff59\027\uff59" +
    "\030\uff59\031\uff59\034\uff59\035\uff59\040\uff59\041\uff59\045" +
    "\uff59\051\uff59\071\uff59\106\uff59\140\uff59\143\uff59\144\uff59" +
    "\152\uff59\156\uff59\001\002\000\040\005\064\047\074\050" +
    "\056\051\100\113\055\117\054\120\067\143\034\144\045" +
    "\152\023\153\073\154\071\155\075\156\024\157\057\001" +
    "\002\000\050\003\uff51\016\uff51\022\uff51\027\uff51\030\uff51" +
    "\031\uff51\034\uff51\035\uff51\040\uff51\041\uff51\045\uff51\051" +
    "\uff51\071\uff51\106\uff51\140\uff51\143\uff51\144\uff51\152\uff51" +
    "\156\uff51\001\002\000\040\016\uff5b\022\uff5b\034\uff5b\035" +
    "\uff5b\040\uff5b\041\uff5b\045\uff5b\051\uff5b\071\uff5b\106\uff5b" +
    "\140\uff5b\143\uff5b\144\uff5b\152\uff5b\156\uff5b\001\002\000" +
    "\050\003\uff5e\016\uff5e\022\uff5e\027\uff5e\030\uff5e\031\uff5e" +
    "\034\uff5e\035\uff5e\040\uff5e\041\uff5e\045\uff5e\051\uff5e\071" +
    "\uff5e\106\uff5e\140\uff5e\143\uff5e\144\uff5e\152\uff5e\156\uff5e" +
    "\001\002\000\050\003\uff52\016\uff52\022\uff52\027\uff52\030" +
    "\uff52\031\uff52\034\uff52\035\uff52\040\uff52\041\uff52\045\uff52" +
    "\051\uff52\071\uff52\106\uff52\140\uff52\143\uff52\144\uff52\152" +
    "\uff52\156\uff52\001\002\000\050\003\uff55\016\uff55\022\uff55" +
    "\027\uff55\030\uff55\031\uff55\034\uff55\035\uff55\040\uff55\041" +
    "\uff55\045\uff55\051\uff55\071\uff55\106\uff55\140\uff55\143\uff55" +
    "\144\uff55\152\uff55\156\uff55\001\002\000\004\045\uff45\001" +
    "\002\000\004\016\u0164\001\002\000\050\003\uff56\016\uff56" +
    "\022\uff56\027\uff56\030\uff56\031\uff56\034\uff56\035\uff56\040" +
    "\uff56\041\uff56\045\uff56\051\uff56\071\uff56\106\uff56\140\uff56" +
    "\143\uff56\144\uff56\152\uff56\156\uff56\001\002\000\004\152" +
    "\023\001\002\000\050\003\uff58\016\uff58\022\uff58\027\uff58" +
    "\030\uff58\031\uff58\034\uff58\035\uff58\040\uff58\041\uff58\045" +
    "\uff58\051\uff58\071\uff58\106\uff58\140\uff58\143\uff58\144\uff58" +
    "\152\uff58\156\uff58\001\002\000\004\124\u0161\001\002\000" +
    "\004\152\023\001\002\000\004\124\u0155\001\002\000\050" +
    "\003\uff5f\016\uff5f\022\uff5f\027\uff5f\030\uff5f\031\uff5f\034" +
    "\uff5f\035\uff5f\040\uff5f\041\uff5f\045\uff5f\051\uff5f\071\uff5f" +
    "\106\uff5f\140\uff5f\143\uff5f\144\uff5f\152\uff5f\156\uff5f\001" +
    "\002\000\050\003\uff57\016\uff57\022\uff57\027\uff57\030\uff57" +
    "\031\uff57\034\uff57\035\uff57\040\uff57\041\uff57\045\uff57\051" +
    "\uff57\071\uff57\106\uff57\140\uff57\143\uff57\144\uff57\152\uff57" +
    "\156\uff57\001\002\000\020\003\uffb0\016\uffb0\036\uffb0\061" +
    "\uffb0\075\uffb0\102\uffb0\152\uffb0\001\002\000\014\112\104" +
    "\113\105\122\102\124\u0151\137\u0150\001\002\000\040\005" +
    "\064\047\074\050\056\051\100\113\055\117\054\120\067" +
    "\143\034\144\045\152\023\153\073\154\071\155\075\156" +
    "\024\157\057\001\002\000\050\003\uff11\016\uff11\022\uff11" +
    "\027\uff11\030\uff11\031\uff11\034\uff11\035\uff11\040\uff11\041" +
    "\uff11\045\uff11\051\uff11\071\uff11\106\uff11\140\uff11\143\uff11" +
    "\144\uff11\152\uff11\156\uff11\001\002\000\004\124\u0153\001" +
    "\002\000\050\003\uff4e\016\uff4e\022\uff4e\027\uff4e\030\uff4e" +
    "\031\uff4e\034\uff4e\035\uff4e\040\uff4e\041\uff4e\045\uff4e\051" +
    "\uff4e\071\uff4e\106\uff4e\140\uff4e\143\uff4e\144\uff4e\152\uff4e" +
    "\156\uff4e\001\002\000\004\016\uff35\001\002\000\050\003" +
    "\uff4f\016\uff4f\022\uff4f\027\uff4f\030\uff4f\031\uff4f\034\uff4f" +
    "\035\uff4f\040\uff4f\041\uff4f\045\uff4f\051\uff4f\071\uff4f\106" +
    "\uff4f\140\uff4f\143\uff4f\144\uff4f\152\uff4f\156\uff4f\001\002" +
    "\000\004\042\u0157\001\002\000\046\005\064\047\074\050" +
    "\056\051\100\072\u0159\113\055\117\054\120\067\143\034" +
    "\144\045\146\033\147\u015c\152\023\153\073\154\071\155" +
    "\075\156\024\157\057\001\002\000\004\045\uffcf\001\002" +
    "\000\044\005\064\047\074\050\056\051\100\113\055\117" +
    "\054\120\067\143\034\144\045\146\033\147\u015c\152\023" +
    "\153\073\154\071\155\075\156\024\157\057\001\002\000" +
    "\036\045\uffd4\046\uff79\064\144\066\uff79\111\uff79\112\104" +
    "\113\105\115\uff79\116\uff79\117\uff79\120\uff79\122\102\135" +
    "\uff79\136\uff79\001\002\000\006\045\uffd4\064\144\001\002" +
    "\000\006\045\ufffb\064\ufffb\001\002\000\004\045\uff3d\001" +
    "\002\000\004\045\uffd0\001\002\000\004\045\uffd1\001\002" +
    "\000\004\045\uff3c\001\002\000\050\003\uff05\016\uff05\022" +
    "\uff05\027\uff05\030\uff05\031\uff05\034\uff05\035\uff05\040\uff05" +
    "\041\uff05\045\uff05\051\uff05\071\uff05\106\uff05\140\uff05\143" +
    "\uff05\144\uff05\152\uff05\156\uff05\001\002\000\004\141\u0163" +
    "\001\002\000\040\016\uff50\022\uff50\034\uff50\035\uff50\040" +
    "\uff50\041\uff50\045\uff50\051\uff50\071\uff50\106\uff50\140\uff50" +
    "\143\uff50\144\uff50\152\uff50\156\uff50\001\002\000\042\003" +
    "\uff3a\016\uff3a\022\uff3a\034\uff3a\035\uff3a\040\uff3a\041\uff3a" +
    "\045\uff3a\051\uff3a\071\uff3a\106\uff3a\140\uff3a\143\uff3a\144" +
    "\uff3a\152\uff3a\156\uff3a\001\002\000\042\003\u0132\016\uff5c" +
    "\022\uff5c\034\uff5c\035\uff5c\040\uff5c\041\uff5c\045\uff5c\051" +
    "\uff5c\071\uff5c\106\uff5c\140\uff5c\143\uff5c\144\uff5c\152\uff5c" +
    "\156\uff5c\001\002\000\044\003\u0132\016\uff5c\022\uff5c\031" +
    "\u0168\034\uff5c\035\uff5c\040\uff5c\041\uff5c\045\uff5c\051\uff5c" +
    "\071\uff5c\106\uff5c\140\uff5c\143\uff5c\144\uff5c\152\uff5c\156" +
    "\uff5c\001\002\000\050\003\uff60\016\uff60\022\uff60\027\uff60" +
    "\030\uff60\031\uff60\034\uff60\035\uff60\040\uff60\041\uff60\045" +
    "\uff60\051\uff60\071\uff60\106\uff60\140\uff60\143\uff60\144\uff60" +
    "\152\uff60\156\uff60\001\002\000\004\124\u0169\001\002\000" +
    "\050\003\uff39\016\uff39\022\uff39\027\uff39\030\uff39\031\uff39" +
    "\034\uff39\035\uff39\040\uff39\041\uff39\045\uff39\051\uff39\071" +
    "\uff39\106\uff39\140\uff39\143\uff39\144\uff39\152\uff39\156\uff39" +
    "\001\002\000\004\045\u016c\001\002\000\004\124\u0171\001" +
    "\002\000\042\003\uff40\016\uff40\022\uff40\034\uff40\035\uff40" +
    "\040\uff40\041\uff40\045\uff40\051\uff40\071\uff40\106\uff40\140" +
    "\uff40\143\uff40\144\uff40\152\uff40\156\uff40\001\002\000\042" +
    "\003\u0132\016\uff5c\022\uff5c\034\uff5c\035\uff5c\040\uff5c\041" +
    "\uff5c\045\uff5c\051\uff5c\071\uff5c\106\uff5c\140\uff5c\143\uff5c" +
    "\144\uff5c\152\uff5c\156\uff5c\001\002\000\044\003\u0132\016" +
    "\uff5c\022\uff5c\031\u016f\034\uff5c\035\uff5c\040\uff5c\041\uff5c" +
    "\045\uff5c\051\uff5c\071\uff5c\106\uff5c\140\uff5c\143\uff5c\144" +
    "\uff5c\152\uff5c\156\uff5c\001\002\000\004\045\u0170\001\002" +
    "\000\006\124\uff3f\152\uff3f\001\002\000\050\003\uff44\016" +
    "\uff44\022\uff44\027\uff44\030\uff44\031\uff44\034\uff44\035\uff44" +
    "\040\uff44\041\uff44\045\uff44\051\uff44\071\uff44\106\uff44\140" +
    "\uff44\143\uff44\144\uff44\152\uff44\156\uff44\001\002\000\050" +
    "\003\ufffd\016\ufffd\022\ufffd\027\ufffd\030\ufffd\031\ufffd\034" +
    "\ufffd\035\ufffd\040\ufffd\041\ufffd\045\ufffd\051\ufffd\071\ufffd" +
    "\106\ufffd\140\ufffd\143\ufffd\144\ufffd\152\ufffd\156\ufffd\001" +
    "\002\000\050\003\uff43\016\uff43\022\uff43\027\uff43\030\uff43" +
    "\031\uff43\034\uff43\035\uff43\040\uff43\041\uff43\045\uff43\051" +
    "\uff43\071\uff43\106\uff43\140\uff43\143\uff43\144\uff43\152\uff43" +
    "\156\uff43\001\002\000\004\101\uff4d\001\002\000\010\045" +
    "\uff46\101\uff46\124\uff46\001\002\000\004\101\u0177\001\002" +
    "\000\042\003\uff4c\016\uff4c\022\uff4c\034\uff4c\035\uff4c\040" +
    "\uff4c\041\uff4c\045\uff4c\051\uff4c\071\uff4c\106\uff4c\140\uff4c" +
    "\143\uff4c\144\uff4c\152\uff4c\156\uff4c\001\002\000\042\003" +
    "\u0132\016\uff5c\022\uff5c\034\uff5c\035\uff5c\040\uff5c\041\uff5c" +
    "\045\uff5c\051\uff5c\071\uff5c\106\uff5c\140\uff5c\143\uff5c\144" +
    "\uff5c\152\uff5c\156\uff5c\001\002\000\050\003\u0132\016\uff5c" +
    "\022\uff5c\027\uff4a\030\uff4a\031\uff4a\034\uff5c\035\uff5c\040" +
    "\uff5c\041\uff5c\045\uff5c\051\uff5c\071\uff5c\106\uff5c\140\uff5c" +
    "\143\uff5c\144\uff5c\152\uff5c\156\uff5c\001\002\000\010\027" +
    "\u017b\030\u017c\031\uff48\001\002\000\042\003\u0132\016\uff5c" +
    "\022\uff5c\034\uff5c\035\uff5c\040\uff5c\041\uff5c\045\uff5c\051" +
    "\uff5c\071\uff5c\106\uff5c\140\uff5c\143\uff5c\144\uff5c\152\uff5c" +
    "\156\uff5c\001\002\000\040\005\064\047\074\050\056\051" +
    "\100\113\055\117\054\120\067\143\034\144\045\152\023" +
    "\153\073\154\071\155\075\156\024\157\057\001\002\000" +
    "\004\031\u017e\001\002\000\004\041\u017f\001\002\000\004" +
    "\124\u0180\001\002\000\050\003\uff4b\016\uff4b\022\uff4b\027" +
    "\uff4b\030\uff4b\031\uff4b\034\uff4b\035\uff4b\040\uff4b\041\uff4b" +
    "\045\uff4b\051\uff4b\071\uff4b\106\uff4b\140\uff4b\143\uff4b\144" +
    "\uff4b\152\uff4b\156\uff4b\001\002\000\004\101\u0182\001\002" +
    "\000\042\003\u0132\016\uff5c\022\uff5c\034\uff5c\035\uff5c\040" +
    "\uff5c\041\uff5c\045\uff5c\051\uff5c\071\uff5c\106\uff5c\140\uff5c" +
    "\143\uff5c\144\uff5c\152\uff5c\156\uff5c\001\002\000\050\003" +
    "\u0132\016\uff5c\022\uff5c\027\uff49\030\uff49\031\uff49\034\uff5c" +
    "\035\uff5c\040\uff5c\041\uff5c\045\uff5c\051\uff5c\071\uff5c\106" +
    "\uff5c\140\uff5c\143\uff5c\144\uff5c\152\uff5c\156\uff5c\001\002" +
    "\000\044\003\u0132\016\uff5c\022\uff5c\031\uff47\034\uff5c\035" +
    "\uff5c\040\uff5c\041\uff5c\045\uff5c\051\uff5c\071\uff5c\106\uff5c" +
    "\140\uff5c\143\uff5c\144\uff5c\152\uff5c\156\uff5c\001\002\000" +
    "\050\003\uff2f\016\uff2f\022\uff2f\027\uff2f\030\uff2f\031\uff2f" +
    "\034\uff2f\035\uff2f\040\uff2f\041\uff2f\045\uff2f\051\uff2f\071" +
    "\uff2f\106\uff2f\140\uff2f\143\uff2f\144\uff2f\152\uff2f\156\uff2f" +
    "\001\002\000\004\124\u0187\001\002\000\050\003\uff2e\016" +
    "\uff2e\022\uff2e\027\uff2e\030\uff2e\031\uff2e\034\uff2e\035\uff2e" +
    "\040\uff2e\041\uff2e\045\uff2e\051\uff2e\071\uff2e\106\uff2e\140" +
    "\uff2e\143\uff2e\144\uff2e\152\uff2e\156\uff2e\001\002\000\004" +
    "\045\uff3b\001\002\000\010\113\105\122\102\124\u018a\001" +
    "\002\000\050\003\uff2d\016\uff2d\022\uff2d\027\uff2d\030\uff2d" +
    "\031\uff2d\034\uff2d\035\uff2d\040\uff2d\041\uff2d\045\uff2d\051" +
    "\uff2d\071\uff2d\106\uff2d\140\uff2d\143\uff2d\144\uff2d\152\uff2d" +
    "\156\uff2d\001\002\000\014\016\uff36\022\u014e\035\u014a\045" +
    "\uff3e\106\u013a\001\002\000\004\045\uff42\001\002\000\004" +
    "\016\u018e\001\002\000\042\003\uff38\016\uff38\022\uff38\034" +
    "\uff38\035\uff38\040\uff38\041\uff38\045\uff38\051\uff38\071\uff38" +
    "\106\uff38\140\uff38\143\uff38\144\uff38\152\uff38\156\uff38\001" +
    "\002\000\042\003\u0132\016\uff5c\022\uff5c\034\uff5c\035\uff5c" +
    "\040\uff5c\041\uff5c\045\uff5c\051\uff5c\071\uff5c\106\uff5c\140" +
    "\uff5c\143\uff5c\144\uff5c\152\uff5c\156\uff5c\001\002\000\044" +
    "\003\u0132\016\uff5c\022\uff5c\031\u0191\034\uff5c\035\uff5c\040" +
    "\uff5c\041\uff5c\045\uff5c\051\uff5c\071\uff5c\106\uff5c\140\uff5c" +
    "\143\uff5c\144\uff5c\152\uff5c\156\uff5c\001\002\000\004\152" +
    "\023\001\002\000\004\124\u0193\001\002\000\050\003\uff37" +
    "\016\uff37\022\uff37\027\uff37\030\uff37\031\uff37\034\uff37\035" +
    "\uff37\040\uff37\041\uff37\045\uff37\051\uff37\071\uff37\106\uff37" +
    "\140\uff37\143\uff37\144\uff37\152\uff37\156\uff37\001\002\000" +
    "\004\045\u016c\001\002\000\004\152\023\001\002\000\004" +
    "\124\u0197\001\002\000\050\003\uff41\016\uff41\022\uff41\027" +
    "\uff41\030\uff41\031\uff41\034\uff41\035\uff41\040\uff41\041\uff41" +
    "\045\uff41\051\uff41\071\uff41\106\uff41\140\uff41\143\uff41\144" +
    "\uff41\152\uff41\156\uff41\001\002\000\012\105\uff32\113\105" +
    "\122\102\124\uff32\001\002\000\006\105\u019a\124\uff31\001" +
    "\002\000\040\005\064\047\074\050\056\051\100\113\055" +
    "\117\054\120\067\143\034\144\045\152\023\153\073\154" +
    "\071\155\075\156\024\157\057\001\002\000\004\124\u019c" +
    "\001\002\000\050\003\uff34\016\uff34\022\uff34\027\uff34\030" +
    "\uff34\031\uff34\034\uff34\035\uff34\040\uff34\041\uff34\045\uff34" +
    "\051\uff34\071\uff34\106\uff34\140\uff34\143\uff34\144\uff34\152" +
    "\uff34\156\uff34\001\002\000\004\124\uff30\001\002\000\004" +
    "\031\u019f\001\002\000\010\124\uff13\152\023\156\024\001" +
    "\002\000\004\124\uff12\001\002\000\004\124\u01a2\001\002" +
    "\000\022\002\uff15\003\uff15\016\uff15\036\uff15\061\uff15\075" +
    "\uff15\102\uff15\152\uff15\001\002\000\022\002\ufffd\003\ufffd" +
    "\016\ufffd\036\ufffd\061\ufffd\075\ufffd\102\ufffd\152\ufffd\001" +
    "\002\000\022\002\uff14\003\uff14\016\uff14\036\uff14\061\uff14" +
    "\075\uff14\102\uff14\152\uff14\001\002\000\010\043\u01a6\113" +
    "\026\124\uff21\001\002\000\020\003\uff29\016\uff29\036\uff29" +
    "\061\uff29\075\uff29\102\uff29\152\uff29\001\002\000\006\043" +
    "\u01a9\124\uff20\001\002\000\004\124\uff2b\001\002\000\020" +
    "\003\uff28\016\uff28\036\uff28\061\uff28\075\uff28\102\uff28\152" +
    "\uff28\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u01a7\000\022\002\012\133\011\134\014\135\005\145" +
    "\003\152\006\153\010\154\015\001\001\000\002\001\001" +
    "\000\004\007\u01a4\001\001\000\006\051\324\052\325\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\133\011" +
    "\134\014\135\005\145\003\154\323\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\007\020\136\017\137\021" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\140\024\141\026\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\012\007\272\010\274\142\271\143\273" +
    "\001\001\000\002\001\001\000\024\005\041\006\043\007" +
    "\040\023\035\024\030\054\031\055\036\137\042\150\037" +
    "\001\001\000\002\001\001\000\014\025\142\027\144\030" +
    "\050\032\051\151\102\001\001\000\002\001\001\000\004" +
    "\151\270\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\025\266\001\001\000" +
    "\004\151\264\001\001\000\010\027\046\030\050\032\051" +
    "\001\001\000\002\001\001\000\040\007\040\054\100\055" +
    "\036\056\071\057\060\072\262\073\067\074\062\075\061" +
    "\076\065\101\076\103\075\104\057\137\042\150\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\040\007\040" +
    "\054\100\055\036\056\071\057\060\072\064\073\067\074" +
    "\062\075\061\076\065\101\076\103\075\104\057\137\042" +
    "\150\037\001\001\000\002\001\001\000\070\007\040\026" +
    "\204\046\207\047\203\054\205\055\036\056\071\057\060" +
    "\060\202\061\210\062\260\063\115\064\106\065\116\066" +
    "\105\067\113\070\110\072\212\073\067\074\062\075\061" +
    "\076\065\101\076\103\075\104\057\137\042\150\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\102\246\001" +
    "\001\000\002\001\001\000\006\025\257\031\256\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\100\242\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\014\007\040\054\253\055\036\137\042\150\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\034\007\040" +
    "\054\100\055\036\056\071\057\060\073\237\074\062\075" +
    "\061\076\065\103\075\104\057\137\042\150\037\001\001" +
    "\000\002\001\001\000\004\151\102\001\001\000\006\007" +
    "\235\137\236\001\001\000\002\001\001\000\004\057\200" +
    "\001\001\000\062\007\107\011\112\012\117\054\100\055" +
    "\036\056\071\057\060\062\111\063\115\064\106\065\116" +
    "\066\105\067\113\070\110\072\120\073\067\074\062\075" +
    "\061\076\065\101\076\103\075\104\057\137\042\150\037" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\071\125\077\123" +
    "\001\001\000\002\001\001\000\002\001\001\000\040\007" +
    "\040\054\100\055\036\056\071\057\060\072\146\073\067" +
    "\074\062\075\061\076\065\101\076\103\075\104\057\137" +
    "\042\150\037\001\001\000\002\001\001\000\052\005\041" +
    "\006\043\007\040\023\136\024\030\026\134\054\135\055" +
    "\036\056\071\057\060\072\137\073\067\074\062\075\061" +
    "\076\065\101\076\103\075\104\057\137\042\150\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\014\025\142\027\144\030\050\032\051" +
    "\151\102\001\001\000\002\001\001\000\002\001\001\000" +
    "\040\007\040\054\100\055\036\056\071\057\060\072\141" +
    "\073\067\074\062\075\061\076\065\101\076\103\075\104" +
    "\057\137\042\150\037\001\001\000\002\001\001\000\002" +
    "\001\001\000\042\007\040\026\145\054\100\055\036\056" +
    "\071\057\060\072\137\073\067\074\062\075\061\076\065" +
    "\101\076\103\075\104\057\137\042\150\037\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\042" +
    "\007\040\054\100\055\036\056\071\057\060\070\150\072" +
    "\120\073\067\074\062\075\061\076\065\101\076\103\075" +
    "\104\057\137\042\150\037\001\001\000\002\001\001\000" +
    "\042\007\040\054\100\055\036\056\071\057\060\070\152" +
    "\072\120\073\067\074\062\075\061\076\065\101\076\103" +
    "\075\104\057\137\042\150\037\001\001\000\002\001\001" +
    "\000\042\007\040\054\100\055\036\056\071\057\060\070" +
    "\154\072\120\073\067\074\062\075\061\076\065\101\076" +
    "\103\075\104\057\137\042\150\037\001\001\000\002\001" +
    "\001\000\060\007\107\012\157\054\100\055\036\056\071" +
    "\057\060\062\111\063\115\064\106\065\116\066\105\067" +
    "\113\070\110\072\120\073\067\074\062\075\061\076\065" +
    "\101\076\103\075\104\057\137\042\150\037\001\001\000" +
    "\002\001\001\000\002\001\001\000\042\007\040\054\100" +
    "\055\036\056\071\057\060\070\171\072\120\073\067\074" +
    "\062\075\061\076\065\101\076\103\075\104\057\137\042" +
    "\150\037\001\001\000\042\007\040\054\100\055\036\056" +
    "\071\057\060\070\170\072\120\073\067\074\062\075\061" +
    "\076\065\101\076\103\075\104\057\137\042\150\037\001" +
    "\001\000\042\007\040\054\100\055\036\056\071\057\060" +
    "\070\167\072\120\073\067\074\062\075\061\076\065\101" +
    "\076\103\075\104\057\137\042\150\037\001\001\000\042" +
    "\007\040\054\100\055\036\056\071\057\060\070\166\072" +
    "\120\073\067\074\062\075\061\076\065\101\076\103\075" +
    "\104\057\137\042\150\037\001\001\000\042\007\040\054" +
    "\100\055\036\056\071\057\060\070\165\072\120\073\067" +
    "\074\062\075\061\076\065\101\076\103\075\104\057\137" +
    "\042\150\037\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\056\007\040\054\100\055\036\056\071\057\060\062\173" +
    "\063\115\064\106\065\116\066\105\067\113\070\110\072" +
    "\120\073\067\074\062\075\061\076\065\101\076\103\075" +
    "\104\057\137\042\150\037\001\001\000\002\001\001\000" +
    "\042\007\040\054\100\055\036\056\071\057\060\070\175" +
    "\072\120\073\067\074\062\075\061\076\065\101\076\103" +
    "\075\104\057\137\042\150\037\001\001\000\002\001\001" +
    "\000\042\007\040\054\100\055\036\056\071\057\060\070" +
    "\177\072\120\073\067\074\062\075\061\076\065\101\076" +
    "\103\075\104\057\137\042\150\037\001\001\000\002\001" +
    "\001\000\002\001\001\000\070\007\040\026\204\046\207" +
    "\047\203\054\205\055\036\056\071\057\060\060\202\061" +
    "\210\062\206\063\115\064\106\065\116\066\105\067\113" +
    "\070\110\072\212\073\067\074\062\075\061\076\065\101" +
    "\076\103\075\104\057\137\042\150\037\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\025" +
    "\225\151\102\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\071\125\077" +
    "\123\001\001\000\066\007\040\026\204\046\207\047\214" +
    "\054\205\055\036\056\071\057\060\061\216\062\215\063" +
    "\115\064\106\065\116\066\105\067\113\070\110\072\212" +
    "\073\067\074\062\075\061\076\065\101\076\103\075\104" +
    "\057\137\042\150\037\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\056\007\040\054\100\055" +
    "\036\056\071\057\060\062\223\063\115\064\106\065\116" +
    "\066\105\067\113\070\110\072\120\073\067\074\062\075" +
    "\061\076\065\101\076\103\075\104\057\137\042\150\037" +
    "\001\001\000\044\007\040\026\204\046\221\054\205\055" +
    "\036\056\071\057\060\072\222\073\067\074\062\075\061" +
    "\076\065\101\076\103\075\104\057\137\042\150\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\056\007\040\054" +
    "\100\055\036\056\071\057\060\062\227\063\115\064\106" +
    "\065\116\066\105\067\113\070\110\072\120\073\067\074" +
    "\062\075\061\076\065\101\076\103\075\104\057\137\042" +
    "\150\037\001\001\000\002\001\001\000\002\001\001\000" +
    "\066\007\040\026\204\046\207\047\214\054\205\055\036" +
    "\056\071\057\060\061\233\062\215\063\115\064\106\065" +
    "\116\066\105\067\113\070\110\072\212\073\067\074\062" +
    "\075\061\076\065\101\076\103\075\104\057\137\042\150" +
    "\037\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\100" +
    "\242\001\001\000\002\001\001\000\002\001\001\000\032" +
    "\007\040\054\100\055\036\056\071\057\060\074\244\075" +
    "\061\076\065\103\075\104\057\137\042\150\037\001\001" +
    "\000\002\001\001\000\004\102\246\001\001\000\002\001" +
    "\001\000\030\007\040\054\100\055\036\056\071\057\060" +
    "\075\252\076\065\103\075\104\057\137\042\150\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\151\102\001\001\000\026\007" +
    "\040\054\100\055\036\056\071\057\060\076\255\103\075" +
    "\104\057\137\042\150\037\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\025\257\031\263\001\001\000\002\001" +
    "\001\000\002\001\001\000\062\007\107\011\112\012\117" +
    "\054\100\055\036\056\071\057\060\062\111\063\115\064" +
    "\106\065\116\066\105\067\113\070\110\072\120\073\067" +
    "\074\062\075\061\076\065\101\076\103\075\104\057\137" +
    "\042\150\037\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\173\317\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\007\307" +
    "\001\001\000\004\144\301\001\001\000\002\001\001\000" +
    "\002\001\001\000\024\005\041\006\043\007\040\023\302" +
    "\024\030\054\031\055\036\137\042\150\037\001\001\000" +
    "\004\015\304\001\001\000\056\007\040\054\100\055\036" +
    "\056\071\057\060\062\305\063\115\064\106\065\116\066" +
    "\105\067\113\070\110\072\120\073\067\074\062\075\061" +
    "\076\065\101\076\103\075\104\057\137\042\150\037\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\007\315\001\001\000\004\144" +
    "\312\001\001\000\024\005\041\006\043\007\040\023\313" +
    "\024\030\054\031\055\036\137\042\150\037\001\001\000" +
    "\004\015\314\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\007\272\010\274\143\321\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\034\007\331\010" +
    "\340\013\327\014\330\016\326\017\336\022\335\050\342" +
    "\053\333\133\341\134\014\135\005\145\343\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\007\u0121\001\001\000\002\001\001\000" +
    "\004\007\356\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\004\346\001\001" +
    "\000\002\001\001\000\024\005\041\006\043\007\040\023" +
    "\347\024\030\054\031\055\036\137\042\150\037\001\001" +
    "\000\004\015\350\001\001\000\002\001\001\000\002\001" +
    "\001\000\056\007\040\054\100\055\036\056\071\057\060" +
    "\062\353\063\115\064\106\065\116\066\105\067\113\070" +
    "\110\072\120\073\067\074\062\075\061\076\065\101\076" +
    "\103\075\104\057\137\042\150\037\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\020\357" +
    "\041\361\001\001\000\002\001\001\000\012\007\364\010" +
    "\365\042\363\043\362\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\024\005\041\006\043\007\040\023\367\024\030" +
    "\054\031\055\036\137\042\150\037\001\001\000\004\015" +
    "\370\001\001\000\002\001\001\000\024\005\041\006\043" +
    "\007\040\023\372\024\030\054\031\055\036\137\042\150" +
    "\037\001\001\000\004\015\373\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\007\364\010\365\043\376\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\021\u0102" +
    "\034\u0103\001\001\000\004\156\u0105\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\035\u0107" +
    "\036\u0106\001\001\000\014\007\364\010\365\040\u0111\043" +
    "\u0110\160\u010e\001\001\000\004\157\u010b\001\001\000\004" +
    "\161\u0109\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\037\u0115\044\u0114\001\001\000\002\001\001\000\004\162" +
    "\u0112\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\007" +
    "\040\054\u0117\055\036\137\042\150\037\001\001\000\004" +
    "\151\102\001\001\000\004\045\u0119\001\001\000\002\001" +
    "\001\000\046\007\040\026\204\046\207\047\u011e\054\205" +
    "\055\036\056\071\057\060\072\222\073\067\074\062\075" +
    "\061\076\065\101\076\103\075\104\057\137\042\150\037" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\035\u0120\036\u0106\001\001" +
    "\000\002\001\001\000\002\001\001\000\024\005\041\006" +
    "\043\007\040\023\u0123\024\030\054\031\055\036\137\042" +
    "\150\037\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\004\u0127\001\001\000\002\001\001\000\024\005\041" +
    "\006\043\007\040\023\u0128\024\030\054\031\055\036\137" +
    "\042\150\037\001\001\000\004\015\u0129\001\001\000\002" +
    "\001\001\000\002\001\001\000\056\007\040\054\100\055" +
    "\036\056\071\057\060\062\u012c\063\115\064\106\065\116" +
    "\066\105\067\113\070\110\072\120\073\067\074\062\075" +
    "\061\076\065\101\076\103\075\104\057\137\042\150\037" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\174" +
    "\u012f\001\001\000\010\105\u0130\106\u0133\107\u0132\001\001" +
    "\000\010\106\u0166\107\u0132\175\u019d\001\001\000\002\001" +
    "\001\000\054\007\u0136\054\u014e\055\036\103\u0148\110\u014b" +
    "\111\u0140\112\u013f\113\u013a\114\u013c\115\u0137\121\u0141\123" +
    "\u0143\124\u013e\125\u0144\126\u0147\131\u014c\132\u0145\137\042" +
    "\147\u0142\150\037\155\u0135\001\001\000\002\001\001\000" +
    "\016\007\040\054\u0197\055\036\127\u0198\137\042\150\037" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\014\007\040\054\u0188\055\036\137\042\150\037" +
    "\001\001\000\060\007\040\054\100\055\036\056\071\057" +
    "\060\062\u0174\063\115\064\106\065\116\066\105\067\113" +
    "\070\110\072\120\073\067\074\062\075\061\076\065\101" +
    "\076\103\075\104\057\120\u0187\137\042\150\037\001\001" +
    "\000\002\001\001\000\056\007\040\054\100\055\036\056" +
    "\071\057\060\062\u0185\063\115\064\106\065\116\066\105" +
    "\067\113\070\110\072\120\073\067\074\062\075\061\076" +
    "\065\101\076\103\075\104\057\137\042\150\037\001\001" +
    "\000\002\001\001\000\060\007\040\054\100\055\036\056" +
    "\071\057\060\062\u0174\063\115\064\106\065\116\066\105" +
    "\067\113\070\110\072\120\073\067\074\062\075\061\076" +
    "\065\101\076\103\075\104\057\120\u0173\137\042\150\037" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\165\u0169" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\007" +
    "\u0161\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\007\u0155\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\051\u0153\052\325\001\001\000\004" +
    "\151\102\001\001\000\056\007\040\054\100\055\036\056" +
    "\071\057\060\062\u0151\063\115\064\106\065\116\066\105" +
    "\067\113\070\110\072\120\073\067\074\062\075\061\076" +
    "\065\101\076\103\075\104\057\137\042\150\037\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\046" +
    "\006\u015a\007\040\026\u0157\033\u015c\054\u0159\055\036\056" +
    "\071\057\060\072\137\073\067\074\062\075\061\076\065" +
    "\101\076\103\075\104\057\137\042\150\037\001\001\000" +
    "\002\001\001\000\046\006\u015a\007\040\026\u0157\033\u015f" +
    "\054\u0159\055\036\056\071\057\060\072\137\073\067\074" +
    "\062\075\061\076\065\101\076\103\075\104\057\137\042" +
    "\150\037\001\001\000\010\025\257\031\u015e\151\102\001" +
    "\001\000\006\025\257\031\u015d\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\171\u0164\001\001\000\010\105\u0165\106" +
    "\u0133\107\u0132\001\001\000\006\106\u0166\107\u0132\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\122\u016a\001\001\000\002\001\001\000\004\170\u016c" +
    "\001\001\000\010\105\u016d\106\u0133\107\u0132\001\001\000" +
    "\006\106\u0166\107\u0132\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\166\u0171\001\001\000\004\003\u0172\001" +
    "\001\000\002\001\001\000\004\163\u0175\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\164\u0177\001\001\000" +
    "\010\105\u0178\106\u0133\107\u0132\001\001\000\010\106\u0166" +
    "\107\u0132\116\u0179\001\001\000\004\117\u017c\001\001\000" +
    "\010\105\u0183\106\u0133\107\u0132\001\001\000\060\007\040" +
    "\054\100\055\036\056\071\057\060\062\u0174\063\115\064" +
    "\106\065\116\066\105\067\113\070\110\072\120\073\067" +
    "\074\062\075\061\076\065\101\076\103\075\104\057\120" +
    "\u0180\137\042\150\037\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\010\105\u0182\106\u0133\107\u0132\001\001\000\006" +
    "\106\u0166\107\u0132\001\001\000\006\106\u0166\107\u0132\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\151\102\001\001\000\002\001" +
    "\001\000\006\123\u018b\125\u018c\001\001\000\004\167\u0193" +
    "\001\001\000\002\001\001\000\004\172\u018e\001\001\000" +
    "\010\105\u018f\106\u0133\107\u0132\001\001\000\006\106\u0166" +
    "\107\u0132\001\001\000\004\007\u0191\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\122\u0194\001\001\000\004" +
    "\007\u0195\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\151\102\001\001\000\004\130\u019a\001\001\000\060" +
    "\007\040\054\100\055\036\056\071\057\060\062\u0174\063" +
    "\115\064\106\065\116\066\105\067\113\070\110\072\120" +
    "\073\067\074\062\075\061\076\065\101\076\103\075\104" +
    "\057\120\u019c\137\042\150\037\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\007\020\136\u019f\137\021\146\u01a0\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\176\u01a2\001\001\000" +
    "\004\003\u01a3\001\001\000\002\001\001\000\006\140\u01a6" +
    "\141\u01a7\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$semantic$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$semantic$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$semantic$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    /**Lista donde se guardan los errores encontrados*/
    public ArrayList<String> errores=new ArrayList<String>();
    /**Método para devolver tanto los errores del parser como los  del lexer, si los hay*/
    public ArrayList<String> getErrores(){
		if(getScanner() instanceof Ada95Lexer){
			errores.addAll(((Ada95Lexer)getScanner()).lexical_errors);		
		}
		return errores;

	}
    /**Método que devuelve las advertencias, hasta esta versión, sólo el lexer tiene advertencias...*/
    public ArrayList<String> getAdvertencias(){
	ArrayList<String> warnings=new ArrayList<String>();
	if(getScanner() instanceof Ada95Lexer){
		warnings.addAll(((Ada95Lexer)getScanner()).lexical_warnings);		
	}
	return warnings;
		
    }
    boolean EOFReported=false;
    Stack<String> unClosed=new Stack<String>();
    public String getUnclosed(){return unClosed.pop();}
    public void setUnclosed(String faltante,String abierto, int line, int col){
	String addToUnClosed="'"+faltante+"'"+" faltante para el '"+abierto+"' abierto en línea "+(line+1)+", columna "+(col+1);
	unClosed.push(addToUnClosed);

    }
    public void emptyLastUnclosed(){String tempUnClosed=unClosed.pop();tempUnClosed=null;}
    	
    /**Guardar los errores en un stringBuffer*/
    //StringBuffer errorMessages=new StringBuffer();
    /* Change the method report_error so it will display the line and
       column of where the error occurred in the input as well as the
       reason for the error which is passed into the method in the
       String 'message'. */
    public void report_error(String message, Object info) {
   	
	/*If the EOF was already reported, just return (to avoid that horrible unexpected EOF...)*/
	if(EOFReported)
		return;
        /* Create a StringBuffer called 'm' with the string 'Error' in it. */
        StringBuffer m = new StringBuffer();
        /* Add to the end of the StringBuffer error message created in
           this method the message that was passed into this method. */
	if(message.equalsIgnoreCase("Syntax error")){
		message="Error Sintáctico  ";
	}else if(message.equalsIgnoreCase("Couldn't repair and continue parse")){
		message="Error ";
	}	
        m.append(message);
   
        /* Check if the information passed to the method is the same
           type as the type java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {
            /* Declare a java_cup.runtime.Symbol object 's' with the
               information in the object info that is being typecasted
               as a java_cup.runtime.Symbol object. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            /* Check if the line number in the input is greater or
               equal to zero. */
            if (s.left >= 0) {                
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(": en línea "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0) {                   
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", columna "+(s.right+1));
		   //ver si se puede sacar el texto:
		   if(getScanner() instanceof Ada95Lexer){
			m.append("; no se esperaba '"+((Ada95Lexer)getScanner()).getCurrentText()+"'");
		   }
		}
	///guardar el error en la variable de errores:
            }else if(s.toString().equals("#0")){
			if(unClosed.empty()){				
				m.append(": final de archivo inesperado");
			}else{
				m.append(": "+getUnclosed());
				EOFReported=true;
			}

		}

        }
   
   
        /* Print the contents of the StringBuffer 'm', which contains
           an error message, out on a line. */
        //System.err.println(m);
	errores.add(m.toString());
	/*Guardar el error en el buffer, mas un salto de línea:*/
	//	errorMessages.append(m+"\n");
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);

        //System.exit(1);
    }
 /**La función que guarda errores para luego ser impresos por el front-end
*@param line, column la línea y columna del error/
public void push_error(int line, int column){
	errores.add(new String(String.valueOf(line)+"_"+String.valueOf(column)));
	System.out.println(errores);
}*/


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$semantic$actions {



/**The current symbol table*/
LinkedSymbolTable currentScope = new LinkedSymbolTable();
//pongo cualquier cosa, sólo para que ya estén en la st (y no deje declarar otras fn con estos nombres):
boolean neverused=currentScope.put("put", new AdaSymbol(new IntegerType()));
boolean neveruser2=currentScope.put("get", new AdaSymbol(new IntegerType()));


 /**Esta función chequea que un subprograma que tiene nombre al principio y final tenga exactamente el mismo nombre
   * @param start la palabra del inicio
     @param sline, scolumn el left y right del símbolo start
     @param end la palabra del final
     @param eline, ecolumn el left y right del símbolo end
 */

 public void check_coherence(Object start, int sline, int scolumn, Object end, int eline, int ecolumn){
	 String s=(String)start;
	 String sInfo="inicio: "+s+" ["+String.valueOf(sline+1)+" , "+String.valueOf((scolumn-s.length()))+"]";
	//la funciones pueden no tener el del final:
	 if(end==null){return;}
	 String e=(String)end;
	 String eInfo=" y fin: "+e+" ["+String.valueOf(eline+1)+" , "+String.valueOf(ecolumn+1)+"]";
	 //ver si son lo mismo:
	if(!s.equals(e)){
		//System.err.println("Error sintáctico  : el nombre del subprograma debe coincidir entre "+sInfo+eInfo);
		parser.errores.add("Error sintáctico  : el nombre del subprograma debe coincidir entre "+sInfo+eInfo);
	}
	

 }
/**Método para comprobar errores semánticos de tipo. Los agrega también a la lista de errores. Se vale del método equals de las clases
   que heredan de Type.
   @param expected el tipo esperado
   @param found el tipo encontrado
   @param foundLine, foundColumn, etc la línea y columna donde se encuentra la declaración.
*/
public boolean compare_types(Object expected, Object found, int foundLine, int foundColumn){
	Type e=(Type)expected;
	Type f=(Type)found;
	if(! e.equals(f)){
		StringBuffer errorMessage=new StringBuffer();
		errorMessage.append("Error semántico  : ");
		errorMessage.append(" Se esperaba el tipo "+e.toString());
		errorMessage.append(" Y se encontró "+f.toString());
		errorMessage.append(" En línea "+String.valueOf(foundLine+1)+", columna "+String.valueOf(foundColumn+1));
		parser.errores.add(errorMessage.toString());
		return false;		
	}
	return true;
}
/**Método para determinar si un símbolo está o no declarado*/
public AdaSymbol findSymbol(Object id, int line, int column){
	AdaSymbol found;
	found=currentScope.get(id);
	if(found == null){
		parser.errores.add(" No se encuentra el símbolo '"+(String)id+"'. En línea "+(String.valueOf(line+1))+", columna "+String.valueOf(column+1));
		return null;
	}
	return found;
	
}
/*Agrega un error a los errores del parser*/
public void agregarError(String mensaje, int linea, int columna){
	parser.errores.add(mensaje+". En línea "+String.valueOf(linea+1)+", columna "+String.valueOf(columna+1));
}

public boolean validateBuiltIn(String method, Object val, int line, int col){
	if(method.equalsIgnoreCase("put") || method.equalsIgnoreCase("get")){
	//the value must be an arraylist of Parser Results:
		if(!(val instanceof ArrayList))
			return false;
	//if it is, cast:
		ArrayList<ParserResult> l=(ArrayList<ParserResult>)val;
	//now, check that it has only one parameter:
		if(l.size()!=1){
			agregarError("La función '"+method+"' solamente admite 1 parámetro, "+String.valueOf(l.size())+" suministrados.", line, col);
			return false;
		}
	//it has, so, check that the type is valid: it must be one of the primitive types:
		return l.get(0).type.isPrimitive();
		
	}	

	
	//invalid method:
	return false;
}


  private final semantic parser;

  /** Constructor */
  CUP$semantic$actions(semantic parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$semantic$do_action(
    int                        CUP$semantic$act_num,
    java_cup.runtime.lr_parser CUP$semantic$parser,
    java.util.Stack            CUP$semantic$stack,
    int                        CUP$semantic$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$semantic$result;

      /* select the action based on the action number */
      switch (CUP$semantic$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 252: // code_statement ::= qualified_expression SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("code_statement",107, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 251: // compilation_unit ::= subprogram_body 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_unit",106, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 250: // compilation_unit ::= subprogram_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_unit",106, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 249: // compilation_list ::= error 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_list",105, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 248: // compilation_list ::= compilation_list compilation_unit 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_list",105, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 247: // compilation_list ::= compilation_unit 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_list",105, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 246: // compilation ::= compilation_list 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation",104, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 245: // actual_parameter_part ::= LEFTPAR argument_list RIGHTPAR 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT=a;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("actual_parameter_part",103, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 244: // function_call ::= GET actual_parameter_part 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//mismos criterios que el put...
						boolean v=validateBuiltIn("GET", p, pleft, pright);
						if(!v){
							RESULT=new ParserResult("get");							
						}else{
							//assume it has only one element:
							ParserResult uP=((ArrayList<ParserResult>)p).get(0);
							RESULT=new ParserResult("get", uP.type);
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("function_call",102, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 243: // function_call ::= PUT actual_parameter_part 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//ver si cumple con: sólo un parámetro, el tipo es o String, int, float o boolean
						boolean v=validateBuiltIn("PUT", p, pleft, pright);						
						if(!v){
							RESULT=new ParserResult("put");							
						}else{
							//assume it has only one element:
							ParserResult uP=((ArrayList<ParserResult>)p).get(0);
							RESULT=new ParserResult("put", uP.type);
						}
						
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("function_call",102, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 242: // function_call ::= name actual_parameter_part 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					AdaSymbol f=findSymbol(n, nleft, nright);
					if(f==null)
						RESULT=new ParserResult(n);
					else{
						if(!(f.type instanceof FunctionType)){
							agregarError("Error Semántico  : '"+((String)n)+"' no es una función", nleft, nright);
							RESULT=new ParserResult(n);
						}else{//la función existe: 
						//ver si está llamado con el número correcto de parámetros:
							if(!(f.type.getProduct().size()==((ArrayList<ParserResult>)p).size())){
								agregarError("Error Semántico  : la función '"+((String)n)+
								"' recibe "+(f.type.getProduct().size())+" parámetros."+
								String.valueOf(((ArrayList<ParserResult>)p).size())
								+"  suministrados", nleft, nright);
								
							}else{//el número de parámetros es correcto, vamos a ver si son iguales:
								int i=0;
								ArrayList<ParserResult> pr=(ArrayList<ParserResult>)p;
								Type found;Type expected;			
								for(;i<f.type.getProduct().size();i++){
									found=pr.get(i).type;
									expected=f.type.getProduct().get(i);		
									if(!expected.equals(found)){
										agregarError("Argumento incorrecto para la función '"+((String)n)+"'"+
										" encontrado '"+found.toString()+"', se esperaba '"+expected.toString()+"'",
										nleft, nright);
										break;			
									}
								}//si termina, el tipo de los parámetros es correcto
								if(i==f.type.getProduct().size())
									RESULT=new ParserResult(n, f.type);
								else
									RESULT=new ParserResult(n);
								
							}//el número de parámetros es correcto 
								
						}//es una función
					}//se encontró el id
					//create a new dummy function to compare it with this.
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("function_call",102, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 241: // function_call ::= name LEFTPAR RIGHTPAR 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
			
						AdaSymbol f=findSymbol(n, nleft, nright);	
					        if (f==null)
							RESULT=new ParserResult(n);
					  	else{//found, check if the function complies...
						//check if it IS a function:
							if(!(f.type instanceof FunctionType)){
								agregarError("Error Semántico  : '"+((String)n)+"' no es una función", nleft, nright);
								RESULT=new ParserResult(n);
						//check if it is an empty parameter function:
							}else if(!f.type.getProduct().isEmpty()){
								agregarError("Error Semántico  : la función '"+((String)n)+
								"' recibe "+(f.type.getProduct().size())+" parámetros. O suministrados", nleft, nright);
								RESULT=new ParserResult(n);
						//if it is a function with empty parameters, but no return type, is a procedure!
							}else if(((FunctionType)f.type).getRange() == null){
								agregarError("No se puede usar una llamada a procedimiento como operando", nleft, nright);
								RESULT=new ParserResult(n);
						//it IS a function (i.e it HAS return type:)
							}else{
								RESULT=new ParserResult(n, f.type);
							}
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("function_call",102, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 240: // procedure_call ::= name SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("procedure_call",101, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 239: // designator_option ::= designator 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=d;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("designator_option",100, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 238: // designator_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("designator_option",100, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 237: // subprogram_body ::= subprogram_specification_is declarative_part BEGIN NT$14 sequence_of_statements NT$15 END designator_option SEMICOLON NT$16 placeholder 
            {
              Object RESULT =null;
              // propagate RESULT from NT$16
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-10)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-10)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-10)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-8)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-6)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		check_coherence(s,sleft, sright, e, eleft, eright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_body",99, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-10)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 236: // NT$16 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-8)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-6)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
currentScope=currentScope.getAncestor();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$16",124, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 235: // NT$15 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
/*ver que el return coincida con el declarado*/
					if((s != null) && (s instanceof ParserResult) ){
						ParserResult ps=(ParserResult)s;
						if(t != null){
						    ParserResult pt=(ParserResult)t;
						    compare_types(ps.type, pt.type, tleft, tright);	
						}else{
        					    agregarError("Sentencia de retorno faltante para la función '"+((String)ps.value)+"' ", sleft, sright);
						}
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$15",123, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 234: // NT$14 ::= 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
parser.setUnclosed((" end "+((String)s)+";"), "begin",bleft, bright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$14",122, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 233: // mode ::= IN OUT 
            {
              Object RESULT =null;
		RESULT="INOUT";
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("mode",98, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 232: // mode ::= OUT 
            {
              Object RESULT =null;
		RESULT="OUT";
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("mode",98, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 231: // mode ::= IN 
            {
              Object RESULT =null;
		RESULT="IN";
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("mode",98, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 230: // mode ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("mode",98, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 229: // parameter_declaration ::= identifier_list COLON mode subtype_indication initialization_option 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					
					ParserResult ps=(ParserResult)s;
                                	//if the type is null, there was an error down the tree (and is already reported)
	                                if (ps.type != null){
					ArrayList<String> il=(ArrayList<String>)l;
					ArrayList<ParserResult> r=new ArrayList<ParserResult>();
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
							String nombre="";
							String mode=(String)m;
							if(o != null){
								ParserResult po=(ParserResult)o;
								boolean compare=compare_types(ps.type, po.type, oleft, oright);
								Type tipo=compare ? ps.type : new ErrorType(ps.type);
								for(String id :il){									
									nombre=(mode.equalsIgnoreCase("in")) ? id+"$constant" : id;
									r.add(new ParserResult(nombre, tipo));
								}
								RESULT=r;
							}else{//there's no initialization expression:
								for(String id: il){
									nombre=(mode.equalsIgnoreCase("in")) ? id+"$constant" : id;
									r.add(new ParserResult(id, ps.type));
								}
								RESULT=r;
							}
						}else{
							for(String id: il)
								r.add(new ParserResult(id, null));
							RESULT=r;
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
						}
                	                }else{
						RESULT=null;
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("parameter_declaration",97, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 228: // parameter_declaration ::= identifier COLON mode subtype_indication initialization_option 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					ParserResult ps=(ParserResult)s;
					String mode=(String)m;
                                	//if the type is null, there was an error down the tree (and is already reported)
	                                if (ps.type != null){
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
							String nombre=(mode.equalsIgnoreCase("in")) ? ((String)i)+"$constant" : (String)i;
							if(o != null){
								ParserResult po=(ParserResult)o;
								boolean compare=compare_types(ps.type, po.type, oleft, oright);
								Type tipo=compare ? ps.type : new ErrorType(ps.type);
								ParserResult r=new ParserResult(i, tipo);
								RESULT=r;
							}else{//there's no initialization expression:
								RESULT=new ParserResult(i, ps.type);
							}
						}else{
							RESULT=new ParserResult(i, null);
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);							     }
                	                }else{
						RESULT=null;
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("parameter_declaration",97, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 227: // parameter_declaration_list ::= parameter_declaration_list SEMICOLON parameter_declaration 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(l != null){
						ArrayList<ParserResult> ll=(ArrayList<ParserResult>)l;
						//puede venir un solo elemento o una lista:
						if(d != null){
							if(!(d instanceof ArrayList)){
								ll.add((ParserResult)d);
							}else{
								ll.addAll((ArrayList<ParserResult>)d);
							}
						}
						RESULT=ll;
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("parameter_declaration_list",96, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // parameter_declaration_list ::= parameter_declaration 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(d != null){
						ArrayList<ParserResult> r=new ArrayList<ParserResult>();
					if (!(d instanceof ArrayList)){
						//asumimos que, si no es una lista, es un parser result
						r.add((ParserResult)d);
						RESULT=r;
					}else{
						RESULT=r;
					}
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("parameter_declaration_list",96, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // formal_part_option ::= formal_part 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=f;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("formal_part_option",95, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // formal_part_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("formal_part_option",95, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // formal_part ::= LEFTPAR parameter_declaration_list NT$13 RIGHTPAR 
            {
              Object RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("formal_part",94, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // NT$13 ::= 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
RESULT=l;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$13",121, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // operator_symbol ::= STRING_LITERAL 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(s, new StringType(((String)s).length()));
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("operator_symbol",93, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // designator ::= operator_symbol 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=o;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("designator",92, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // designator ::= identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=i;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("designator",92, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // subprogram_specification_is ::= FUNCTION designator formal_part_option RETURN subtype_indication IS 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					ParserResult ps=(ParserResult)s;
					if(ps.type != null){
					if(f != null){
						
						ArrayList<ParserResult> fl=(ArrayList<ParserResult>)f;
						ArrayList<Type> ft=new ArrayList<Type>();
						for (ParserResult p:fl)
							ft.add(p.type);							
						if(ps.type != null){
							if(!currentScope.put(i, new AdaSymbol(new FunctionType(ps.type, ft)))){
								agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
							}else{
								currentScope=new LinkedSymbolTable(currentScope);
								String nombre="";
								boolean cons=false;
								for(ParserResult p: fl){
									nombre=((String)p.value).split("$")[0];
									cons=((String)p.value).contains("$constant");
									currentScope.put(nombre, new AdaSymbol(p.type, cons));
								}
							}
						}
						
					}else{
						if(!currentScope.put(i, new AdaSymbol(new FunctionType(ps.type))))
							agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
						else{
							currentScope=new LinkedSymbolTable(currentScope);
						}
						
					}
 					RESULT=new ParserResult(i,ps.type);
					}
					 RESULT=i;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification_is",91, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // subprogram_specification_is ::= PROCEDURE identifier formal_part IS 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					  //formal part es una lista de parser results:
					  if( f!= null){											  	
						ArrayList<ParserResult> fl=(ArrayList<ParserResult>)f;
						ArrayList<Type> ft=new ArrayList<Type>();
						for (ParserResult p:fl)
							ft.add(p.type);												                                             if(!currentScope.put(i, new AdaSymbol(new FunctionType(ft)))){
							agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
						}else{
							currentScope=new LinkedSymbolTable(currentScope);
							String nombre="";
							boolean cons=false;
							for(ParserResult p: fl){
								nombre=((String)p.value).split("$")[0];
								cons=((String)p.value).contains("$constant");
								currentScope.put(nombre, new AdaSymbol(p.type, cons));
							}
						}
					  }
					
					RESULT=i;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification_is",91, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // subprogram_specification_is ::= PROCEDURE identifier IS 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					if(!currentScope.put(i, new AdaSymbol(new FunctionType()))){
						agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
					}else{
					  currentScope=new LinkedSymbolTable(currentScope);
					}
					  RESULT=i;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification_is",91, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // subprogram_specification ::= FUNCTION designator formal_part_option RETURN subtype_indication 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
						ParserResult ps=(ParserResult)s;
						if(f != null){//si la formal part está correcta:
							/*Si los nombres de los parámetros me importaran: */
							//ArrayList<ParserResult> pf=(ArrayList<ParserResult>)f;
							//sólo me importan los types?
							//LinkedSymbolTable ft=(LinkedSymbolTable)f;	 
							ArrayList<ParserResult> fl=(ArrayList<ParserResult>)f;
							ArrayList<Type> ft=new ArrayList<Type>();
							for (ParserResult p:fl)
								ft.add(p.type);							
							if(ps.type != null){
								if(!currentScope.put(d, new AdaSymbol(new FunctionType(ps.type, ft))))
									agregarError("'"+((String)d)+"' ya ha sido declarado.", dleft, dright);
							}
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification",90, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // subprogram_specification ::= PROCEDURE identifier formal_part_option 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
						if(f != null){
							ArrayList<ParserResult> fl=(ArrayList<ParserResult>)f;
							ArrayList<Type> ft=new ArrayList<Type>();
							for (ParserResult p:fl)
								ft.add(p.type);
							if(!currentScope.put(i, new AdaSymbol(new FunctionType(ft))))
								agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification",90, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // subprogram_declaration ::= subprogram_specification SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_declaration",89, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // goto_statement ::= GOTO name SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("goto_statement",88, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // return_statement ::= RETURN expression SEMICOLON 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("return_statement",87, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // return_statement ::= RETURN SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("return_statement",87, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // when_option ::= WHEN condition 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType))
							agregarError("Se esperaba un tipo booleano y se encontró"+pc.type.toString(), cleft, cright);
					 }
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("when_option",86, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // when_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("when_option",86, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // name_option ::= name 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name_option",85, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // name_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name_option",85, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // exit_statement ::= EXIT name_option when_option SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("exit_statement",84, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // declare_part_option ::= DECLARE declarative_part 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declare_part_option",83, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // declare_part_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declare_part_option",83, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // block ::= identifier COLON declare_part_option BEGIN NT$12 sequence_of_statements END identifier SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-8)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("block",82, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // NT$12 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
parser.setUnclosed((" end "+((String)i)+ ";"), ("begin del bloque "+((String)i)),ileft, iright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$12",120, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // block ::= declare_part_option BEGIN NT$11 sequence_of_statements END SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("block",82, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // NT$11 ::= 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
parser.setUnclosed("end;", "begin del bloque",bleft, bright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$11",119, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // iteration_clause_option ::= WHILE condition 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType))
							agregarError("Se esperaba un tipo booleano y se encontró"+pc.type.toString(), cleft, cright);
					 }
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",81, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // iteration_clause_option ::= FOR identifier IN REVERSE discrete_range 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",81, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // iteration_clause_option ::= FOR identifier IN discrete_range 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",81, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // iteration_clause_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",81, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // basic_loop ::= LOOP NT$10 sequence_of_statements END LOOP 
            {
              Object RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("basic_loop",80, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // NT$10 ::= 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
parser.setUnclosed("end loop;", "loop",lleft,lright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$10",118, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // loop_statement ::= identifier COLON iteration_clause_option NT$9 basic_loop identifier SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-6)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int jleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object j = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					String si=(String)i; 
					String sj=(String)j;
					if(!si.equalsIgnoreCase(sj))
						agregarError("Se esperaba 'end loop "+si+"' y se encontró 'end loop "+sj+"'", jleft, jright);
					if(o != null){						
						currentScope=new LinkedSymbolTable(currentScope); 
					  }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("loop_statement",79, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // NT$9 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;

					if(o != null){						
						currentScope=new LinkedSymbolTable(currentScope); 
					  }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$9",117, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // loop_statement ::= iteration_clause_option NT$7 basic_loop SEMICOLON NT$8 placeholder 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("loop_statement",79, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // NT$8 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;

					 if(o != null)
						currentScope=currentScope.getAncestor();
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$8",116, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // NT$7 ::= 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;

					if(o != null){						
						currentScope=new LinkedSymbolTable(currentScope); 
					  }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$7",115, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // condition ::= expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("condition",78, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // else_option ::= ELSE sequence_of_statements 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("else_option",77, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // else_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("else_option",77, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // elsif_list ::= elsif_list ELSIF condition THEN sequence_of_statements 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType))
							agregarError("Se esperaba un tipo booleano y se encontró"+pc.type.toString(), cleft, cright);
					 }
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("elsif_list",76, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // elsif_list ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("elsif_list",76, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // if_statement ::= IF condition NT$5 THEN NT$6 sequence_of_statements elsif_list else_option END IF SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-6)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-10)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-10)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-10)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-9)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-9)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-9)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("if_statement",75, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-10)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // NT$6 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
parser.setUnclosed("end if;", "if", ileft, iright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$6",114, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // NT$5 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType))
							agregarError("Se esperaba un tipo booleano y se encontró"+pc.type.toString(), cleft, cright);
					 }
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$5",113, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // assignment_statement ::= name ASSIGNMENT expression SEMICOLON 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					if(e != null){
						ParserResult pe=(ParserResult)e;
						ParserResult pn=(ParserResult)n;
						//AdaSymbol gn=currentScope.get(pn.value);
						
						if(pn.type != null){
						//get it:
						AdaSymbol gn=currentScope.get(pn.value);
						//if it is a function, a record or a constant, then it's not eligible:
						if(gn.type instanceof FunctionType)
						agregarError("El lado izquierdo de la asignación debe ser una variable, no una función", nleft, nright);
						else if(gn.type instanceof RecordType)						
						agregarError("El lado izquierdo de la asignación debe ser una variable, no un registro", nleft, nright);
						else if(gn.constant)
					agregarError("El lado izquierdo de la asignación debe ser una variable, no un objeto constante", nleft, nright);
						else//si todo sale bien, entonces sí comparar:					
						    compare_types(pn.type, pe.type, eleft, eright);
						}
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("assignment_statement",74, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // null_statement ::= NULL SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("null_statement",73, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // label ::= LEFTLABEL identifier RIGHTLABEL 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("label",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // compound_statement ::= block 
            {
              Object RESULT =null;
		parser.emptyLastUnclosed();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compound_statement",71, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // compound_statement ::= loop_statement 
            {
              Object RESULT =null;
		parser.emptyLastUnclosed();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compound_statement",71, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // compound_statement ::= if_statement 
            {
              Object RESULT =null;
		parser.emptyLastUnclosed();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compound_statement",71, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // simple_statement ::= code_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // simple_statement ::= procedure_call 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // simple_statement ::= goto_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // simple_statement ::= return_statement 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // simple_statement ::= exit_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // simple_statement ::= assignment_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // simple_statement ::= null_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // label_list ::= label_list label 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("label_list",69, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // label_list ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("label_list",69, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // statement ::= error 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("statement",68, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // statement ::= label_list compound_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("statement",68, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // statement ::= label_list simple_statement 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("statement",68, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // sequence_of_statements ::= sequence_of_statements statement 
            {
              Object RESULT =null;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(q != null)
						RESULT=q;
					else
						RESULT=s;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("sequence_of_statements",67, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // sequence_of_statements ::= statement 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=s;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("sequence_of_statements",67, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // allocator ::= NEW name 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("allocator",66, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // qualified_expression ::= name TICK aggregate 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("qualified_expression",65, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // qualified_expression ::= name TICK LEFTPAR expression RIGHTPAR 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("qualified_expression",65, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // multiplying_operator ::= REM 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("multiplying_operator",64, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // multiplying_operator ::= MOD 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("multiplying_operator",64, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // multiplying_operator ::= DIVIDE 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("multiplying_operator",64, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // multiplying_operator ::= MULTIPLY 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("multiplying_operator",64, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // unary_operator ::= ABS 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(a, new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("unary_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // unary_operator ::= NOT 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(n, new BooleanType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("unary_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // unary_operator ::= MINUS 
            {
              Object RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(m, new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("unary_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // unary_operator ::= PLUS 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(p, new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("unary_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // adding_operator ::= CONCATENATE 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("adding_operator",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // adding_operator ::= MINUS 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("adding_operator",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // adding_operator ::= PLUS 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("adding_operator",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // relational_operator ::= LTEQ 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",61, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // relational_operator ::= GTEQ 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",61, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // relational_operator ::= GT 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",61, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // relational_operator ::= LT 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",61, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // relational_operator ::= INEQUALITY 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",61, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // relational_operator ::= EQUAL 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",61, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // primary ::= LEFTPAR expression RIGHTPAR 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",60, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // primary ::= qualified_expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",60, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // primary ::= allocator 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",60, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // primary ::= name 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=n;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",60, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // primary ::= aggregate 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",60, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // primary ::= literal 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=l;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",60, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // factor ::= primary EXPONENTIATE primary 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numérico y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo numérico y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("factor",59, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // factor ::= primary 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					   ParserResult pr=(ParserResult)p;
					   if(pr.type != null){
						RESULT=pr;						
					   }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("factor",59, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // term ::= term multiplying_operator factor 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if ((p != null) && (q != null)){
							
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numérico y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo numérico y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					}	
					}	
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("term",58, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // term ::= factor 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(f != null){					  
					   ParserResult pr=(ParserResult)f;
					   if(pr.type != null){
						RESULT=pr;						
					   }
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("term",58, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // term_list ::= term_list adding_operator term 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numérico y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo numérico y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("term_list",57, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // term_list ::= term 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(t != null){					  
					   ParserResult pr=(ParserResult)t;
					   if(pr.type != null){
						RESULT=pr;						
					   }
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("term_list",57, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // simple_expression ::= unary_operator term_list 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(t != null){
						ParserResult pt=(ParserResult)t;
					if(pt.type != null){						
					 Type ptipo=(pt.type instanceof FunctionType)? (((FunctionType)pt.type).getRange()) : pt.type;
						Type so=(Type)o;
						if(so.isNumeric()){
							if(ptipo.isNumeric()){
							    RESULT=pt;
							}else{								
							    agregarError("Se esperaba un tipo numérico y se encontró "+ptipo.toString(), oleft, oright);
							    RESULT=null;
							}	
						}else{//the operator is boolean!
							if(ptipo instanceof BooleanType){
								RESULT=pt;
							}else{
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), oleft, oright);
							    RESULT=null;
							}
						}						
					}
					}

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_expression",56, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // simple_expression ::= term_list 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(t != null){					  
					   ParserResult pr=(ParserResult)t;
					   if(pr.type != null){
						RESULT=pr;						
					   }
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_expression",56, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // membership_operator ::= NOT IN 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("membership_operator",55, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // membership_operator ::= IN 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("membership_operator",55, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // relation ::= simple_expression membership_operator subtype_indication 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					  if(p != null){
						ParserResult pr=(ParserResult)p;
						ParserResult ps=(ParserResult)s;
						if ((ps.type != null) && (pr.type != null)){
						 	Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
							if(compare_types(ptipo, ps.type, sleft, sright)){
								RESULT=pr;
							}else{
								RESULT=null;
							}						
						}
					  }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relation",54, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // relation ::= simple_expression membership_operator range 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numérico y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo numérico y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
					 
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relation",54, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // relation ::= simple_expression relational_operator simple_expression 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 //si no son null, vienen buenos:
						RESULT=new ParserResult(pr.value, new BooleanType());
						}
						
					 }
				

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relation",54, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // relation ::= simple_expression 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(s != null){
						ParserResult ps=(ParserResult)s;
						if(ps.type !=null)
							RESULT=new ParserResult(ps.value, new BooleanType());
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relation",54, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // orelse_expression ::= orelse_expression OR_ELSE relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("orelse_expression",53, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // orelse_expression ::= relation OR_ELSE relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
						
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("orelse_expression",53, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // andthen_expression ::= andthen_expression AND_THEN relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("andthen_expression",52, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // andthen_expression ::= relation AND_THEN relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("andthen_expression",52, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // xor_expression ::= xor_expression XOR relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("xor_expression",51, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // xor_expression ::= relation XOR relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("xor_expression",51, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // or_expression ::= or_expression OR relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("or_expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // or_expression ::= relation OR relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("or_expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // and_expression ::= and_expression AND relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("and_expression",49, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // and_expression ::= relation AND relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("and_expression",49, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // expression ::= orelse_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",48, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // expression ::= andthen_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",48, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // expression ::= xor_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",48, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // expression ::= or_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",48, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // expression ::= and_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",48, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // expression ::= relation 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",48, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // component_association ::= choice_list ARROW expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_association",47, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // component_association ::= expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_association",47, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // component_association_list ::= component_association_list COMMA component_association 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_association_list",46, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // component_association_list ::= component_association COMMA component_association 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_association_list",46, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // aggregate ::= LEFTPAR choice_list ARROW expression RIGHTPAR 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("aggregate",45, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // aggregate ::= LEFTPAR component_association_list RIGHTPAR 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("aggregate",45, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // literal ::= NULL 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT= new ParserResult(n);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // literal ::= BOOLEAN_LITERAL 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT= new ParserResult(b, new BooleanType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // literal ::= CHARACTER_LITERAL 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT= new ParserResult(c, new StringType(1));
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // literal ::= FLOATING_POINT_LITERAL 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Float f = (Float)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT= new ParserResult(f, new FloatType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // literal ::= INTEGER_LITERAL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(i, new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // selected_component ::= name POINT operator_symbol 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("selected_component",43, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // selected_component ::= name POINT ALL 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		
					AdaSymbol f=findSymbol(n, nleft, nright);
					if(f != null)
						RESULT=new ParserResult(n, f.type);
					else
						RESULT=new ParserResult(n);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("selected_component",43, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // selected_component ::= name POINT identifier 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					//the selected component query:
						ParserResult namen=(ParserResult)n;
						String valex=((String)namen.value)+"."+((String)i);
						Type t=null;
					//query for it in the current scope:
						AdaSymbol f=currentScope.get(valex);		
						if (f !=null)//found:
							t=f.type;
						else
							parser.errores.add("Error Semántico  : No se puede encontrar el componente "+((String)i)+
							" para el prefijo "+((String)namen.value)+ ". En línea "+String.valueOf(nleft+1)+
							", columna "+String.valueOf(nright+1));
						RESULT=new ParserResult(valex, t);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("selected_component",43, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // name ::= operator_symbol 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//buscar el nombre en la tabla de símbolos:
					  AdaSymbol f=findSymbol(i, ileft, iright);
					  if(f!= null)
						RESULT=new ParserResult(i, f.type);						 
					  else
						RESULT=new ParserResult(i);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name",42, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // name ::= function_call 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=f;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name",42, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // name ::= selected_component 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=s;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name",42, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // name ::= identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//buscar el nombre en la tabla de símbolos:
					  AdaSymbol f=findSymbol(i, ileft, iright);
					  if(f!= null)
						RESULT=new ParserResult(i, f.type);						 
					  else
						RESULT=new ParserResult(i);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name",42, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // declarative_item ::= error SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item",41, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // declarative_item ::= subprogram_body 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item",41, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // declarative_item ::= declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item",41, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // declarative_item_list ::= declarative_item_list declarative_item 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item_list",40, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // declarative_item_list ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item_list",40, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // declarative_part ::= declarative_item_list 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_part",39, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // incomplete_type_declaration ::= TYPE identifier discriminant_part_option SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("incomplete_type_declaration",38, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // choice_list ::= choice_list VERTICAL_LINE choice 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice_list",37, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // choice_list ::= choice 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice_list",37, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // choice ::= range 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice",36, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // choice ::= name range_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice",36, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // choice ::= OTHERS 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice",36, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // choice ::= simple_expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice",36, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // variant_list ::= variant_list WHEN choice_list ARROW component_list 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_list",35, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // variant_list ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_list",35, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // variant_part ::= CASE name IS variant_list END CASE SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_part",34, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // discriminant_declaration ::= identifier_list COLON subtype_indication initialization_option 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					  ParserResult ps=(ParserResult)s;
					  ArrayList<String> il=(ArrayList<String>)l;
					  if(ps.type != null){//si el tipo sí fue encontrado:
						ArrayList<ParserResult> r=new ArrayList<ParserResult>();
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
							if(o != null){//ver si el tipo de o coincide con el de s:
								 ParserResult po=(ParserResult)o;
								 boolean compare=compare_types(ps.type, po.type, oleft, oright);
								 Type tipo=compare ? ps.type : new ErrorType(ps.type);
								 for(String id: il){						
									r.add(new ParserResult(id, tipo));					
								 }
								 RESULT=r;
							}else{//no hay inicialización:
								 for(String id: il){						
									r.add(new ParserResult(id, ps.type));					
								 }
								 RESULT=r;
							}
						}else{
							for(String id:il){
								r.add(new ParserResult(id, null));
							}
							RESULT=r;
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
						}
					  }else{
						RESULT=null;
					  }
						
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_declaration",33, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // discriminant_declaration ::= identifier COLON subtype_indication initialization_option 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//ver si el tipo existe. Si existe, ver si coincide con la inicialización.
					  //si algo malo pasa, devolver null.
					  ParserResult ps=(ParserResult)s;
					  if(ps.type != null){//si el tipo sí fue encontrado:
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)) //si el tipo ES un tipo:
							if(o != null){//ver si el tipo de o coincide con el de s:
								 ParserResult po=(ParserResult)o;
								 boolean compare=compare_types(ps.type, po.type, oleft, oright);
								 Type tipo=compare ? ps.type : new ErrorType(ps.type);
								 RESULT=new ParserResult(i, tipo);
							}else{//no hay inicialización:
								RESULT=new ParserResult(i, ps.type);
							}
						  else{
							RESULT=new ParserResult(i, null);
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
						  }
					  }else{//el tipo no fue encontrado
						RESULT=null;
					  }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_declaration",33, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // discriminant_declaration_list ::= discriminant_declaration_list SEMICOLON discriminant_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_declaration_list",32, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // discriminant_declaration_list ::= discriminant_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_declaration_list",32, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // discriminant_part ::= LEFTPAR discriminant_declaration_list RIGHTPAR 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_part",31, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // component_declaration ::= error 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_declaration",30, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // component_declaration ::= discriminant_declaration NT$4 SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_declaration",30, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // NT$4 ::= 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
RESULT=d;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$4",112, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // variant_part_option ::= variant_part 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_part_option",29, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // variant_part_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_part_option",29, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // component_declaration_list ::= component_declaration_list component_declaration 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		LinkedSymbolTable t=(LinkedSymbolTable)l;
					  //the components are parserResults: en el valor viene el nombre.
					//c puede ser una lista o un solo elemento:
					if(c != null){	
					  if(!(c instanceof ArrayList)){
					 	 ParserResult p=(ParserResult)c;
						  if(!t.put(p.value, new AdaSymbol(p.type))){
							agregarError("El componente '"+((String)p.value)+
							"' ya ha sido declarado en este registro.", cleft, cright);
						  }
					  }else{//sí es una lista:
						ArrayList<ParserResult> lc=(ArrayList<ParserResult>)c;
						for(ParserResult p: lc){
						  if(!t.put(p.value, new AdaSymbol(p.type))){
							agregarError("El componente '"+((String)p.value)+
							"' ya ha sido declarado en este registro.", cleft, cright);
						  }//no se pudo meter el id
							
						}//iterar en c
					  }//c es una lista
				
					}//c existe
					//subir la tabla de símbolos:
					RESULT=t;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_declaration_list",28, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // component_declaration_list ::= 
            {
              Object RESULT =null;
		RESULT=new LinkedSymbolTable();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_declaration_list",28, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // component_list ::= NULL NT$3 SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_list",27, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // NT$3 ::= 
            {
              Object RESULT =null;
RESULT=new LinkedSymbolTable();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$3",111, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // component_list ::= component_declaration_list NT$2 variant_part_option 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_list",27, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // NT$2 ::= 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
RESULT=l;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$2",110, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // record_type_definition ::= RECORD NT$0 component_list NT$1 END RECORD 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("record_type_definition",26, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // NT$1 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
RESULT=l;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$1",109, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // NT$0 ::= 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
parser.setUnclosed("end record;", "record", rleft,rright );
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$0",108, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // discrete_range ::= range 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discrete_range",25, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // discrete_range ::= numeric_type range_constraint_option 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discrete_range",25, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // discrete_range ::= name range_constraint_option 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discrete_range",25, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // fixed_point_constraint ::= DELTA simple_expression range_constraint_option 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("fixed_point_constraint",24, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // range_constraint_option ::= range_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("range_constraint_option",23, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // range_constraint_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("range_constraint_option",23, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // floating_point_constraint ::= DIGITS simple_expression range_constraint_option 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("floating_point_constraint",22, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // accuracy_constraint ::= fixed_point_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("accuracy_constraint",21, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // accuracy_constraint ::= floating_point_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("accuracy_constraint",21, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // range ::= simple_expression DOUBLEDOT simple_expression 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if ((t != null) && (f != null)){
							
					 ParserResult pr=(ParserResult)t;
					 ParserResult qr=(ParserResult)f;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, fleft, fright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numérico y se encontró "+ptipo.toString(), tleft, tright);
							else 
							    agregarError("Se esperaba un tipo numérico y se encontró "+qtipo.toString(), fleft, fright);
							RESULT=null;
						}
						
					}	
					}	
		
		
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("range",20, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // range_constraint ::= RANGE range 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("range_constraint",19, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // subtype_indication_with_constraint ::= FLOAT accuracy_constraint 
            {
              Object RESULT =null;
		RESULT=new ParserResult(new FloatType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",18, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // subtype_indication_with_constraint ::= numeric_type range_constraint 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT=n;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",18, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // subtype_indication_with_constraint ::= name accuracy_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",18, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // subtype_indication_with_constraint ::= name range_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",18, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // subtype_indication ::= primitive_type 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=t;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication",17, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // subtype_indication ::= subtype_indication_with_constraint 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=c;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication",17, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // subtype_indication ::= name 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=n;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication",17, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // subtype_declaration ::= SUBTYPE identifier IS subtype_indication SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					ParserResult ps=(ParserResult)s;
					if(ps.type!= null){
					if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
						Type t=ps.type;
						t.name=(String)i;
						//se pone un nuevo tipo con otro nombre:
						if(!currentScope.put(i, new AdaSymbol(t, true))){
							agregarError("Error semántico  : el tipo '"+((String)i)+"' ya ha sido declarado", ileft, iright);
						}
					}
					}else{
						agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
					}
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_declaration",16, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // type_definition ::= record_type_definition 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		parser.emptyLastUnclosed();RESULT=r;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("type_definition",15, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // discriminant_part_option ::= discriminant_part 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_part_option",14, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // discriminant_part_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_part_option",14, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // type_declaration ::= incomplete_type_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("type_declaration",13, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // type_declaration ::= TYPE identifier discriminant_part_option IS type_definition SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
				//viene una tabla de símbolos: porque siempre son records
				LinkedSymbolTable table=(LinkedSymbolTable)t;				
				if(!currentScope.put(i, new AdaSymbol(new RecordType(((String)i),table))))
					agregarError("Error semántico  : el tipo '"+((String)i)+"' ya ha sido declarado", ileft, iright);
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("type_declaration",13, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // identifier_list ::= identifier_list COMMA identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int jleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int jright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object j = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		ArrayList<String> r =new ArrayList<String>();
				  r.addAll((ArrayList<String>)i);r.add((String)j);	
				  RESULT=r;	
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("identifier_list",6, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // identifier_list ::= identifier COMMA identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int jleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int jright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object j = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		ArrayList<String>r=new ArrayList<String>();
				  r.add((String)i); r.add((String)j);
				  RESULT=r;		
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("identifier_list",6, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // number_declaration ::= identifier_list COLON CONSTANT ASSIGNMENT expression SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		if(o != null){
				ParserResult po=(ParserResult)o;ArrayList<String> pi=(ArrayList<String>)i;
				for(String id:pi){
					if(!currentScope.put(id, new AdaSymbol(po.type, true)))
						agregarError("Error semántico  : el identificador "+id+" ya ha sido declarado", ileft, iright);
				}	
				}  		
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("number_declaration",12, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // number_declaration ::= identifier COLON CONSTANT ASSIGNMENT expression SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		if(o != null){
				  ParserResult po=(ParserResult)o;
			          if(!currentScope.put(i, new AdaSymbol(po.type, true)))
					agregarError("Error semántico  : el identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
				  }
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("number_declaration",12, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // initialization_option ::= ASSIGNMENT expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("initialization_option",11, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // initialization_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("initialization_option",11, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // object_declaration ::= identifier_list COLON constant_option subtype_indication initialization_option SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
				ParserResult ps=(ParserResult)s; 
				if (ps.type != null){
				ArrayList<String> il=(ArrayList<String>)i;
				boolean isConstant=(c != null); 
				if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
				if(o != null){				
					ParserResult po=(ParserResult)o;
					boolean compare=compare_types(ps.type, po.type, oleft, oright);
					Type tipo=compare ? ps.type : new ErrorType(ps.type);					
					for(String id:il){
						if(!currentScope.put(id, new AdaSymbol(tipo, isConstant)))
							agregarError("Error semántico  : el identificador "+id+" ya ha sido declarado", ileft, iright);
					}	
				}else{//there's no initialization expression:
				   if(isConstant)
					agregarError("La declaración de un objeto constante requiere una expresión de inicialización", ileft, iright);	  
				   for(String id:il){
					if(!currentScope.put(id, new AdaSymbol(ps.type)))
						agregarError("Error semántico  : el identificador "+id+" ya ha sido declarado", ileft, iright);
				   }	
				}
				}else{
					agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
	
				}
				}
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("object_declaration",10, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // object_declaration ::= identifier COLON constant_option subtype_indication initialization_option SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		ParserResult ps=(ParserResult)s; 
				//if the type is null, there was an error down the tree (and is already reported)
				if (ps.type != null){				
				boolean isConstant=(c != null); 
				if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
				if(o != null){			
					ParserResult po=(ParserResult)o;
					boolean compare=compare_types(ps.type, po.type, oleft, oright);
					Type tipo=compare ? ps.type : new ErrorType(ps.type);					
					if(!currentScope.put(i, new AdaSymbol(tipo, isConstant)))
						agregarError("Error semántico  : el identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
						
				}else{//there's no initialization expression:
				   if(isConstant)
					agregarError("La declaración de un objeto constante requiere una expresión de inicialización", ileft, iright);					        if(!currentScope.put(i, new AdaSymbol(ps.type)))
					agregarError("Error semántico  : el identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
				   	
				}
				}else{//s no es un subtipo de nada:
					agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);	
				}
					
				}
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("object_declaration",10, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // declaration ::= number_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",9, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // declaration ::= subtype_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",9, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // declaration ::= subprogram_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",9, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // declaration ::= type_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",9, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // declaration ::= object_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",9, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // argument ::= identifier ARROW expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("argument",8, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // argument ::= expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("argument",8, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // argument_list ::= argument_list COMMA argument 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		if(a != null){
			  ArrayList<ParserResult> r=new ArrayList<ParserResult>();
			  r.addAll((ArrayList<ParserResult>)l);
			  r.add((ParserResult)a);
			  RESULT=r;
			 }else{RESULT=l;}			
			
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("argument_list",7, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // argument_list ::= argument 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		if(a != null){
			 ArrayList<ParserResult> r=new ArrayList<ParserResult>();
			  r.add((ParserResult)a);
			  RESULT=r;
			}
			
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("argument_list",7, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // identifier ::= IDENTIFIER 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=i;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("identifier",5, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // primitive_type ::= numeric_type 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=(ParserResult)t;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primitive_type",3, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // primitive_type ::= BOOLEAN 
            {
              Object RESULT =null;
		RESULT=new ParserResult("boolean",new BooleanType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primitive_type",3, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // numeric_type ::= FLOAT 
            {
              Object RESULT =null;
		RESULT=new ParserResult("float", new FloatType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("numeric_type",4, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // numeric_type ::= INTEGER 
            {
              Object RESULT =null;
		RESULT=new ParserResult("integer", new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("numeric_type",4, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // placeholder ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("placeholder",1, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // goal ::= compilation 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("goal",0, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // constant_option ::= CONSTANT 
            {
              Object RESULT =null;
		RESULT=true;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("constant_option",2, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // constant_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("constant_option",2, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= goal EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT = start_val;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$semantic$parser.done_parsing();
          return CUP$semantic$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

