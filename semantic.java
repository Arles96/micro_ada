
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Fri Dec 11 17:22:55 CST 2009
//----------------------------------------------------

import java_cup.runtime.*;
import java.util.Stack;
import java.util.ArrayList;
import java.util.HashMap;
import AdaSemantic.*;
import CodeGeneration.FlatSymbolTable;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Fri Dec 11 17:22:55 CST 2009
  */
public class semantic extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public semantic() {super();}

  /** Constructor which sets the default scanner. */
  public semantic(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public semantic(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\377\000\002\002\004\000\002\006\002\000\002\006" +
    "\003\000\002\002\003\000\002\003\002\000\002\004\002" +
    "\000\002\005\002\000\002\010\003\000\002\010\003\000" +
    "\002\007\003\000\002\007\003\000\002\011\003\000\002" +
    "\013\003\000\002\013\005\000\002\014\003\000\002\014" +
    "\005\000\002\015\003\000\002\015\003\000\002\015\003" +
    "\000\002\015\003\000\002\015\003\000\002\016\010\000" +
    "\002\016\010\000\002\017\002\000\002\017\004\000\002" +
    "\020\010\000\002\020\010\000\002\012\005\000\002\012" +
    "\005\000\002\161\002\000\002\021\011\000\002\021\003" +
    "\000\002\022\002\000\002\022\003\000\002\023\003\000" +
    "\002\024\007\000\002\025\003\000\002\025\003\000\002" +
    "\025\003\000\002\026\004\000\002\026\004\000\002\026" +
    "\004\000\002\026\004\000\002\027\004\000\002\030\005" +
    "\000\002\031\003\000\002\031\003\000\002\032\005\000" +
    "\002\033\002\000\002\033\003\000\002\034\005\000\002" +
    "\035\004\000\002\035\004\000\002\035\003\000\002\162" +
    "\002\000\002\163\002\000\002\036\010\000\002\164\002" +
    "\000\002\037\005\000\002\165\002\000\002\037\005\000" +
    "\002\040\002\000\002\040\004\000\002\041\002\000\002" +
    "\041\003\000\002\166\002\000\002\042\005\000\002\042" +
    "\003\000\002\043\005\000\002\044\003\000\002\044\005" +
    "\000\002\045\006\000\002\045\006\000\002\046\011\000" +
    "\002\047\002\000\002\047\007\000\002\050\003\000\002" +
    "\050\003\000\002\050\004\000\002\050\003\000\002\051" +
    "\003\000\002\051\005\000\002\052\006\000\002\053\003" +
    "\000\002\054\002\000\002\054\004\000\002\055\003\000" +
    "\002\055\003\000\002\055\004\000\002\056\003\000\002" +
    "\056\003\000\002\056\003\000\002\056\003\000\002\057" +
    "\005\000\002\057\005\000\002\057\005\000\002\060\003" +
    "\000\002\060\003\000\002\060\003\000\002\060\003\000" +
    "\002\060\003\000\002\061\005\000\002\061\007\000\002" +
    "\062\005\000\002\062\005\000\002\063\003\000\002\063" +
    "\005\000\002\064\003\000\002\064\003\000\002\064\003" +
    "\000\002\064\003\000\002\064\003\000\002\064\003\000" +
    "\002\065\006\000\002\065\006\000\002\066\006\000\002" +
    "\066\006\000\002\067\005\000\002\067\005\000\002\070" +
    "\006\000\002\070\006\000\002\071\006\000\002\071\006" +
    "\000\002\072\003\000\002\072\005\000\002\072\005\000" +
    "\002\072\005\000\002\073\003\000\002\073\004\000\002" +
    "\074\003\000\002\074\004\000\002\075\003\000\002\075" +
    "\005\000\002\076\003\000\002\076\005\000\002\077\003" +
    "\000\002\077\005\000\002\100\003\000\002\100\003\000" +
    "\002\100\003\000\002\100\003\000\002\100\003\000\002" +
    "\100\005\000\002\101\003\000\002\101\003\000\002\101" +
    "\003\000\002\101\003\000\002\101\003\000\002\101\003" +
    "\000\002\102\003\000\002\102\003\000\002\102\003\000" +
    "\002\103\003\000\002\103\003\000\002\103\003\000\002" +
    "\103\003\000\002\104\003\000\002\104\003\000\002\104" +
    "\003\000\002\104\003\000\002\105\007\000\002\105\005" +
    "\000\002\106\004\000\002\107\003\000\002\107\005\000" +
    "\002\110\004\000\002\110\004\000\002\110\003\000\002" +
    "\111\002\000\002\111\004\000\002\112\003\000\002\112" +
    "\003\000\002\112\003\000\002\112\003\000\002\112\003" +
    "\000\002\112\003\000\002\112\003\000\002\113\003\000" +
    "\002\113\003\000\002\113\003\000\002\114\005\000\002" +
    "\115\004\000\002\116\006\000\002\167\002\000\002\123" +
    "\010\000\002\117\007\000\002\117\012\000\002\120\007" +
    "\000\002\120\012\000\002\121\002\000\002\121\006\000" +
    "\002\122\003\000\002\170\002\000\002\124\010\000\002" +
    "\124\011\000\002\171\002\000\002\125\007\000\002\126" +
    "\002\000\002\126\007\000\002\126\010\000\002\126\005" +
    "\000\002\172\002\000\002\127\010\000\002\173\002\000" +
    "\002\127\013\000\002\130\002\000\002\130\004\000\002" +
    "\131\006\000\002\132\002\000\002\132\003\000\002\133" +
    "\002\000\002\133\005\000\002\134\004\000\002\134\005" +
    "\000\002\135\005\000\002\136\004\000\002\137\005\000" +
    "\002\137\007\000\002\140\005\000\002\140\006\000\002" +
    "\140\010\000\002\141\003\000\002\141\003\000\002\142" +
    "\003\000\002\174\002\000\002\143\006\000\002\144\002" +
    "\000\002\144\003\000\002\145\003\000\002\145\005\000" +
    "\002\146\007\000\002\146\007\000\002\147\002\000\002" +
    "\147\003\000\002\147\003\000\002\147\004\000\002\175" +
    "\002\000\002\176\002\000\002\150\014\000\002\151\002" +
    "\000\002\151\003\000\002\152\004\000\002\152\005\000" +
    "\002\152\007\000\002\152\007\000\002\153\005\000\002" +
    "\153\004\000\002\154\005\000\002\155\003\000\002\156" +
    "\003\000\002\156\004\000\002\156\003\000\002\157\003" +
    "\000\002\157\003\000\002\160\004" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u01cc\000\010\003\010\036\014\061\005\001\002\000" +
    "\010\002\uff04\036\uff04\061\uff04\001\002\000\004\152\022" +
    "\001\002\000\020\003\uffad\016\uffad\036\uffad\061\uffad\075" +
    "\uffad\102\uffad\152\uffad\001\002\000\004\002\ufffe\001\002" +
    "\000\010\002\uff06\036\uff06\061\uff06\001\002\000\010\002" +
    "\uff09\036\014\061\005\001\002\000\010\002\uff05\036\uff05" +
    "\061\uff05\001\002\000\004\002\326\001\002\000\006\152" +
    "\022\156\024\001\002\000\004\124\017\001\002\000\010" +
    "\002\uff08\036\uff08\061\uff08\001\002\000\022\002\uff2a\003" +
    "\uff2a\016\uff2a\036\uff2a\061\uff2a\075\uff2a\102\uff2a\152\uff2a" +
    "\001\002\000\006\071\uff1f\113\027\001\002\000\010\071" +
    "\uff24\113\uff24\124\uff24\001\002\000\124\013\ufff6\024\ufff6" +
    "\025\ufff6\042\ufff6\043\ufff6\045\ufff6\046\ufff6\050\ufff6\053" +
    "\ufff6\064\ufff6\066\ufff6\071\ufff6\101\ufff6\105\ufff6\110\ufff6" +
    "\111\ufff6\112\ufff6\113\ufff6\114\ufff6\115\ufff6\116\ufff6\117" +
    "\ufff6\120\ufff6\121\ufff6\122\ufff6\123\ufff6\124\ufff6\125\ufff6" +
    "\126\ufff6\127\ufff6\130\ufff6\131\ufff6\132\ufff6\133\ufff6\134" +
    "\ufff6\135\ufff6\136\ufff6\137\ufff6\141\ufff6\150\ufff6\151\ufff6" +
    "\001\002\000\010\071\uff23\113\uff23\124\uff23\001\002\000" +
    "\120\013\uff22\024\uff22\025\uff22\042\uff22\043\uff22\045\uff22" +
    "\046\uff22\050\uff22\053\uff22\064\uff22\066\uff22\071\uff22\101" +
    "\uff22\105\uff22\110\uff22\111\uff22\112\uff22\113\uff22\114\uff22" +
    "\115\uff22\116\uff22\117\uff22\120\uff22\121\uff22\122\uff22\124" +
    "\uff22\125\uff22\126\uff22\127\uff22\130\uff22\131\uff22\132\uff22" +
    "\133\uff22\134\uff22\135\uff22\136\uff22\137\uff22\150\uff22\151" +
    "\uff22\001\002\000\004\071\uff1e\001\002\000\004\071\323" +
    "\001\002\000\004\152\022\001\002\000\006\114\uff21\124" +
    "\317\001\002\000\006\121\311\123\312\001\002\000\006" +
    "\121\034\123\035\001\002\000\006\114\uff1d\124\uff1d\001" +
    "\002\000\004\152\022\001\002\000\020\042\037\055\036" +
    "\145\uff19\146\uff19\147\uff19\152\uff19\156\uff19\001\002\000" +
    "\014\145\uff17\146\uff17\147\uff17\152\uff17\156\uff17\001\002" +
    "\000\016\055\307\145\uff18\146\uff18\147\uff18\152\uff18\156" +
    "\uff18\001\002\000\014\145\044\146\043\147\054\152\022" +
    "\156\024\001\002\000\032\013\uffdc\043\uffdc\045\uffdc\053" +
    "\uffdc\101\uffdc\110\uffdc\114\uffdc\121\uffdc\124\uffdc\137\uffdc" +
    "\150\uffdc\151\uffdc\001\002\000\024\024\061\025\056\043" +
    "\uffdd\064\152\113\113\114\uffdd\122\110\124\uffdd\137\uffdd" +
    "\001\002\000\034\013\ufffa\043\ufffa\045\ufffa\053\ufffa\064" +
    "\ufffa\101\ufffa\110\ufffa\114\ufffa\121\ufffa\124\ufffa\137\ufffa" +
    "\150\ufffa\151\ufffa\001\002\000\032\013\ufff8\043\ufff8\045" +
    "\ufff8\053\ufff8\101\ufff8\110\ufff8\114\ufff8\121\ufff8\124\ufff8" +
    "\137\ufff8\150\ufff8\151\ufff8\001\002\000\010\114\uffea\124" +
    "\uffea\137\304\001\002\000\116\013\uffa7\024\uffa7\025\uffa7" +
    "\042\uffa7\043\uffa7\045\uffa7\046\uffa7\050\uffa7\053\uffa7\064" +
    "\uffa7\066\uffa7\101\uffa7\105\uffa7\110\uffa7\111\uffa7\112\uffa7" +
    "\113\uffa7\114\uffa7\115\uffa7\116\uffa7\117\uffa7\120\uffa7\121" +
    "\uffa7\122\uffa7\124\uffa7\125\uffa7\126\uffa7\127\uffa7\130\uffa7" +
    "\131\uffa7\132\uffa7\133\uffa7\134\uffa7\135\uffa7\136\uffa7\137" +
    "\uffa7\150\uffa7\151\uffa7\001\002\000\116\013\uffa6\024\uffa6" +
    "\025\uffa6\042\uffa6\043\uffa6\045\uffa6\046\uffa6\050\uffa6\053" +
    "\uffa6\064\uffa6\066\uffa6\101\uffa6\105\uffa6\110\uffa6\111\uffa6" +
    "\112\uffa6\113\uffa6\114\uffa6\115\uffa6\116\uffa6\117\uffa6\120" +
    "\uffa6\121\uffa6\122\uffa6\124\uffa6\125\uffa6\126\uffa6\127\uffa6" +
    "\130\uffa6\131\uffa6\132\uffa6\133\uffa6\134\uffa6\135\uffa6\136" +
    "\uffa6\137\uffa6\150\uffa6\151\uffa6\001\002\000\116\013\uffa8" +
    "\024\uffa8\025\uffa8\042\uffa8\043\uffa8\045\uffa8\046\uffa8\050" +
    "\uffa8\053\uffa8\064\uffa8\066\uffa8\101\uffa8\105\uffa8\110\uffa8" +
    "\111\uffa8\112\uffa8\113\uffa8\114\uffa8\115\uffa8\116\uffa8\117" +
    "\uffa8\120\uffa8\121\uffa8\122\uffa8\124\uffa8\125\uffa8\126\uffa8" +
    "\127\uffa8\130\uffa8\131\uffa8\132\uffa8\133\uffa8\134\uffa8\135" +
    "\uffa8\136\uffa8\137\uffa8\150\uffa8\151\uffa8\001\002\000\032" +
    "\013\uffdb\043\uffdb\045\uffdb\053\uffdb\101\uffdb\110\uffdb\114" +
    "\uffdb\121\uffdb\124\uffdb\137\uffdb\150\uffdb\151\uffdb\001\002" +
    "\000\116\013\uffa5\024\uffa5\025\uffa5\042\uffa5\043\uffa5\045" +
    "\uffa5\046\uffa5\050\uffa5\053\uffa5\064\uffa5\066\uffa5\101\uffa5" +
    "\105\uffa5\110\uffa5\111\uffa5\112\uffa5\113\uffa5\114\uffa5\115" +
    "\uffa5\116\uffa5\117\uffa5\120\uffa5\121\uffa5\122\uffa5\124\uffa5" +
    "\125\uffa5\126\uffa5\127\uffa5\130\uffa5\131\uffa5\132\uffa5\133" +
    "\uffa5\134\uffa5\135\uffa5\136\uffa5\137\uffa5\150\uffa5\151\uffa5" +
    "\001\002\000\034\013\ufff7\043\ufff7\045\ufff7\053\ufff7\064" +
    "\152\101\ufff7\110\ufff7\114\ufff7\121\ufff7\124\ufff7\137\ufff7" +
    "\150\ufff7\151\ufff7\001\002\000\040\013\ufff9\024\061\025" +
    "\056\043\ufff9\045\ufff9\053\ufff9\064\ufff9\101\ufff9\110\ufff9" +
    "\114\ufff9\121\ufff9\124\ufff9\137\ufff9\150\ufff9\151\ufff9\001" +
    "\002\000\032\013\uffd7\043\uffd7\045\uffd7\053\uffd7\101\uffd7" +
    "\110\uffd7\114\uffd7\121\uffd7\124\uffd7\137\uffd7\150\uffd7\151" +
    "\uffd7\001\002\000\034\005\073\047\101\050\065\051\106" +
    "\113\063\117\062\120\074\152\022\153\102\154\077\155" +
    "\103\156\024\157\064\001\002\000\032\013\uffd4\043\uffd4" +
    "\045\uffd4\053\uffd4\101\uffd4\110\uffd4\114\uffd4\121\uffd4\124" +
    "\uffd4\137\uffd4\150\uffd4\151\uffd4\001\002\000\032\013\uffd3" +
    "\043\uffd3\045\uffd3\053\uffd3\101\uffd3\110\uffd3\114\uffd3\121" +
    "\uffd3\124\uffd3\137\uffd3\150\uffd3\151\uffd3\001\002\000\034" +
    "\005\073\047\101\050\065\051\106\113\063\117\062\120" +
    "\074\152\022\153\102\154\077\155\103\156\024\157\064" +
    "\001\002\000\024\047\uff69\051\uff69\113\uff69\152\uff69\153" +
    "\uff69\154\uff69\155\uff69\156\uff69\157\uff69\001\002\000\036" +
    "\005\073\047\101\050\065\051\106\054\230\113\063\117" +
    "\062\120\074\152\022\153\102\154\077\155\103\156\024" +
    "\157\064\001\002\000\102\013\uff9e\042\uff9e\043\uff9e\045" +
    "\uff9e\046\uff9e\050\uff9e\053\uff9e\064\uff9e\066\uff9e\101\uff9e" +
    "\110\uff9e\111\uff9e\114\uff9e\115\uff9e\116\uff9e\117\uff9e\120" +
    "\uff9e\121\uff9e\124\uff9e\125\uff9e\126\uff9e\127\uff9e\130\uff9e" +
    "\131\uff9e\132\uff9e\133\uff9e\134\uff9e\135\uff9e\136\uff9e\137" +
    "\uff9e\150\uff9e\151\uff9e\001\002\000\024\047\uff67\051\uff67" +
    "\113\uff67\152\uff67\153\uff67\154\uff67\155\uff67\156\uff67\157" +
    "\uff67\001\002\000\102\013\uff75\042\uff75\043\uff75\045\uff75" +
    "\046\uff75\050\uff75\053\uff75\064\uff75\066\uff75\101\uff75\110" +
    "\uff75\111\uff75\114\uff75\115\uff75\116\uff75\117\uff75\120\uff75" +
    "\121\uff75\124\uff75\125\uff75\126\uff75\127\uff75\130\uff75\131" +
    "\uff75\132\uff75\133\uff75\134\uff75\135\uff75\136\uff75\137\uff75" +
    "\150\uff75\151\uff75\001\002\000\102\013\uff77\042\uff77\043" +
    "\uff77\045\uff77\046\uff77\050\uff77\053\uff77\064\uff77\066\uff77" +
    "\101\uff77\110\uff77\111\uff77\114\uff77\115\uff77\116\uff77\117" +
    "\uff77\120\uff77\121\uff77\124\uff77\125\uff77\126\uff77\127\uff77" +
    "\130\uff77\131\uff77\132\uff77\133\uff77\134\uff77\135\uff77\136" +
    "\uff77\137\uff77\150\uff77\151\uff77\001\002\000\100\013\uff7c" +
    "\042\uff7c\043\uff7c\045\uff7c\046\uff7c\050\uff7c\053\uff7c\064" +
    "\uff7c\066\uff7c\101\uff7c\110\uff7c\111\uff7c\114\uff7c\115\uff7c" +
    "\116\uff7c\117\uff7c\120\uff7c\121\uff7c\124\uff7c\125\uff7c\126" +
    "\uff7c\127\uff7c\130\uff7c\131\uff7c\132\uff7c\133\uff7c\134\uff7c" +
    "\135\uff7c\137\uff7c\150\uff7c\151\uff7c\001\002\000\100\013" +
    "\uff7e\042\uff7e\043\uff7e\045\uff7e\046\264\050\uff7e\053\uff7e" +
    "\064\uff7e\066\267\101\uff7e\110\uff7e\111\uff7e\114\uff7e\115" +
    "\270\116\266\117\uff7e\120\uff7e\121\uff7e\124\uff7e\125\uff7e" +
    "\126\uff7e\127\uff7e\130\uff7e\131\uff7e\132\uff7e\133\uff7e\134" +
    "\uff7e\135\uff7e\137\uff7e\150\uff7e\151\uff7e\001\002\000\034" +
    "\013\uffd1\043\uffd1\045\uffd1\053\uffd1\064\152\101\uffd1\110" +
    "\uffd1\114\uffd1\121\uffd1\124\uffd1\137\uffd1\150\uffd1\151\uffd1" +
    "\001\002\000\024\047\uff66\051\uff66\113\uff66\152\uff66\153" +
    "\uff66\154\uff66\155\uff66\156\uff66\157\uff66\001\002\000\024" +
    "\047\uff68\051\uff68\113\uff68\152\uff68\153\uff68\154\uff68\155" +
    "\uff68\156\uff68\157\uff68\001\002\000\102\013\uff7a\042\uff7a" +
    "\043\uff7a\045\uff7a\046\uff7a\050\uff7a\053\uff7a\064\uff7a\066" +
    "\uff7a\101\uff7a\110\uff7a\111\uff7a\114\uff7a\115\uff7a\116\uff7a" +
    "\117\uff7a\120\uff7a\121\uff7a\124\uff7a\125\uff7a\126\uff7a\127" +
    "\uff7a\130\uff7a\131\uff7a\132\uff7a\133\uff7a\134\uff7a\135\uff7a" +
    "\136\273\137\uff7a\150\uff7a\151\uff7a\001\002\000\070\013" +
    "\uff80\042\uff80\043\uff80\045\uff80\050\uff80\053\uff80\064\uff80" +
    "\101\uff80\110\uff80\111\262\114\uff80\117\257\120\260\121" +
    "\uff80\124\uff80\125\uff80\126\uff80\127\uff80\130\uff80\131\uff80" +
    "\132\uff80\133\uff80\134\uff80\135\uff80\137\uff80\150\uff80\151" +
    "\uff80\001\002\000\102\013\uffa0\042\uffa0\043\uffa0\045\uffa0" +
    "\046\uffa0\050\uffa0\053\uffa0\064\uffa0\066\uffa0\101\uffa0\110" +
    "\uffa0\111\uffa0\114\uffa0\115\uffa0\116\uffa0\117\uffa0\120\uffa0" +
    "\121\uffa0\124\uffa0\125\uffa0\126\uffa0\127\uffa0\130\uffa0\131" +
    "\uffa0\132\uffa0\133\uffa0\134\uffa0\135\uffa0\136\uffa0\137\uffa0" +
    "\150\uffa0\151\uffa0\001\002\000\102\013\uff78\042\uff78\043" +
    "\uff78\045\uff78\046\uff78\050\uff78\053\uff78\064\uff78\066\uff78" +
    "\101\uff78\110\uff78\111\uff78\114\uff78\115\uff78\116\uff78\117" +
    "\uff78\120\uff78\121\uff78\124\uff78\125\uff78\126\uff78\127\uff78" +
    "\130\uff78\131\uff78\132\uff78\133\uff78\134\uff78\135\uff78\136" +
    "\uff78\137\uff78\150\uff78\151\uff78\001\002\000\006\152\022" +
    "\156\024\001\002\000\102\013\uffa1\042\uffa1\043\uffa1\045" +
    "\uffa1\046\uffa1\050\uffa1\053\uffa1\064\uffa1\066\uffa1\101\uffa1" +
    "\110\uffa1\111\uffa1\114\uffa1\115\uffa1\116\uffa1\117\uffa1\120" +
    "\uffa1\121\uffa1\124\uffa1\125\uffa1\126\uffa1\127\uffa1\130\uffa1" +
    "\131\uffa1\132\uffa1\133\uffa1\134\uffa1\135\uffa1\136\uffa1\137" +
    "\uffa1\150\uffa1\151\uffa1\001\002\000\102\013\uff9f\042\uff9f" +
    "\043\uff9f\045\uff9f\046\uff9f\050\uff9f\053\uff9f\064\uff9f\066" +
    "\uff9f\101\uff9f\110\uff9f\111\uff9f\114\uff9f\115\uff9f\116\uff9f" +
    "\117\uff9f\120\uff9f\121\uff9f\124\uff9f\125\uff9f\126\uff9f\127" +
    "\uff9f\130\uff9f\131\uff9f\132\uff9f\133\uff9f\134\uff9f\135\uff9f" +
    "\136\uff9f\137\uff9f\150\uff9f\151\uff9f\001\002\000\102\013" +
    "\uff74\042\uff74\043\uff74\045\uff74\046\uff74\050\uff74\053\uff74" +
    "\064\uff74\066\uff74\101\uff74\110\uff74\111\uff74\114\uff74\115" +
    "\uff74\116\uff74\117\uff74\120\uff74\121\uff74\124\uff74\125\uff74" +
    "\126\uff74\127\uff74\130\uff74\131\uff74\132\uff74\133\uff74\134" +
    "\uff74\135\uff74\136\uff74\137\uff74\150\uff74\151\uff74\001\002" +
    "\000\024\047\101\051\106\113\063\152\022\153\102\154" +
    "\077\155\103\156\024\157\064\001\002\000\102\013\uff9d" +
    "\042\uff9d\043\uff9d\045\uff9d\046\uff9d\050\uff9d\053\uff9d\064" +
    "\uff9d\066\uff9d\101\uff9d\110\uff9d\111\uff9d\114\uff9d\115\uff9d" +
    "\116\uff9d\117\uff9d\120\uff9d\121\uff9d\124\uff9d\125\uff9d\126" +
    "\uff9d\127\uff9d\130\uff9d\131\uff9d\132\uff9d\133\uff9d\134\uff9d" +
    "\135\uff9d\136\uff9d\137\uff9d\150\uff9d\151\uff9d\001\002\000" +
    "\110\013\uff76\042\uff76\043\uff76\045\uff76\046\uff76\050\uff76" +
    "\053\uff76\064\uff76\066\uff76\101\uff76\110\uff76\111\uff76\112" +
    "\112\113\113\114\uff76\115\uff76\116\uff76\117\uff76\120\uff76" +
    "\121\uff76\122\110\124\uff76\125\uff76\126\uff76\127\uff76\130" +
    "\uff76\131\uff76\132\uff76\133\uff76\134\uff76\135\uff76\136\uff76" +
    "\137\uff76\150\uff76\151\uff76\001\002\000\010\012\253\152" +
    "\022\156\024\001\002\000\116\013\uff0b\024\uff0b\025\uff0b" +
    "\042\uff0b\043\uff0b\045\uff0b\046\uff0b\050\uff0b\053\uff0b\064" +
    "\uff0b\066\uff0b\101\uff0b\105\uff0b\110\uff0b\111\uff0b\112\uff0b" +
    "\113\uff0b\114\uff0b\115\uff0b\116\uff0b\117\uff0b\120\uff0b\121" +
    "\uff0b\122\uff0b\124\uff0b\125\uff0b\126\uff0b\127\uff0b\130\uff0b" +
    "\131\uff0b\132\uff0b\133\uff0b\134\uff0b\135\uff0b\136\uff0b\137" +
    "\uff0b\150\uff0b\151\uff0b\001\002\000\004\113\220\001\002" +
    "\000\036\005\073\047\101\050\065\051\106\113\063\114" +
    "\123\117\062\120\074\152\022\153\102\154\077\155\103" +
    "\156\024\157\064\001\002\000\016\045\uff92\101\uff92\114" +
    "\uff92\121\uff92\124\uff92\150\214\001\002\000\016\045\uff94" +
    "\053\211\101\uff94\114\uff94\121\uff94\124\uff94\001\002\000" +
    "\070\013\uffa8\042\uffa8\046\uffa8\050\uffa8\053\uffa8\066\uffa8" +
    "\110\uffa8\111\uffa8\112\uffa8\113\uffa8\114\uffa8\115\uffa8\116" +
    "\uffa8\117\uffa8\120\uffa8\121\uffa8\122\uffa8\125\uffa8\126\uffa8" +
    "\127\uffa8\130\uffa8\131\uffa8\132\uffa8\134\207\136\uffa8\150" +
    "\uffa8\151\uffa8\001\002\000\026\013\172\045\uff96\053\175" +
    "\101\uff96\110\174\114\uff96\121\uff96\124\uff96\150\173\151" +
    "\171\001\002\000\006\114\ufff3\121\ufff3\001\002\000\006" +
    "\114\167\121\166\001\002\000\016\045\uff91\101\uff91\114" +
    "\uff91\121\uff91\124\uff91\151\163\001\002\000\116\013\uff0c" +
    "\024\uff0c\025\uff0c\042\uff0c\043\uff0c\045\uff0c\046\uff0c\050" +
    "\uff0c\053\uff0c\064\uff0c\066\uff0c\101\uff0c\105\uff0c\110\uff0c" +
    "\111\uff0c\112\uff0c\113\uff0c\114\uff0c\115\uff0c\116\uff0c\117" +
    "\uff0c\120\uff0c\121\uff0c\122\uff0c\124\uff0c\125\uff0c\126\uff0c" +
    "\127\uff0c\130\uff0c\131\uff0c\132\uff0c\133\uff0c\134\uff0c\135" +
    "\uff0c\136\uff0c\137\uff0c\150\uff0c\151\uff0c\001\002\000\016" +
    "\013\160\045\uff95\101\uff95\114\uff95\121\uff95\124\uff95\001" +
    "\002\000\016\045\uff93\101\uff93\110\156\114\uff93\121\uff93" +
    "\124\uff93\001\002\000\006\114\ufff5\121\ufff5\001\002\000" +
    "\046\013\uff86\042\131\045\uff86\050\137\053\uff86\101\uff86" +
    "\110\uff86\114\uff86\121\uff86\124\uff86\125\135\126\141\127" +
    "\133\130\136\131\130\132\140\150\uff86\151\uff86\001\002" +
    "\000\034\005\uff6e\047\uff6e\050\uff6e\051\uff6e\113\uff6e\117" +
    "\uff6e\120\uff6e\152\uff6e\153\uff6e\154\uff6e\155\uff6e\156\uff6e" +
    "\157\uff6e\001\002\000\042\005\uff82\047\uff82\050\uff82\051" +
    "\uff82\113\uff82\117\uff82\120\uff82\145\uff82\146\uff82\147\uff82" +
    "\152\uff82\153\uff82\154\uff82\155\uff82\156\uff82\157\uff82\001" +
    "\002\000\034\005\073\047\101\050\065\051\106\113\063" +
    "\117\062\120\074\152\022\153\102\154\077\155\103\156" +
    "\024\157\064\001\002\000\034\005\uff72\047\uff72\050\uff72" +
    "\051\uff72\113\uff72\117\uff72\120\uff72\152\uff72\153\uff72\154" +
    "\uff72\155\uff72\156\uff72\157\uff72\001\002\000\042\005\073" +
    "\047\101\050\065\051\106\113\063\117\062\120\074\145" +
    "\044\146\043\147\054\152\022\153\102\154\077\155\103" +
    "\156\024\157\064\001\002\000\034\005\uff6f\047\uff6f\050" +
    "\uff6f\051\uff6f\113\uff6f\117\uff6f\120\uff6f\152\uff6f\153\uff6f" +
    "\154\uff6f\155\uff6f\156\uff6f\157\uff6f\001\002\000\034\005" +
    "\uff71\047\uff71\050\uff71\051\uff71\113\uff71\117\uff71\120\uff71" +
    "\152\uff71\153\uff71\154\uff71\155\uff71\156\uff71\157\uff71\001" +
    "\002\000\004\042\142\001\002\000\034\005\uff6d\047\uff6d" +
    "\050\uff6d\051\uff6d\113\uff6d\117\uff6d\120\uff6d\152\uff6d\153" +
    "\uff6d\154\uff6d\155\uff6d\156\uff6d\157\uff6d\001\002\000\034" +
    "\005\uff70\047\uff70\050\uff70\051\uff70\113\uff70\117\uff70\120" +
    "\uff70\152\uff70\153\uff70\154\uff70\155\uff70\156\uff70\157\uff70" +
    "\001\002\000\042\005\uff81\047\uff81\050\uff81\051\uff81\113" +
    "\uff81\117\uff81\120\uff81\145\uff81\146\uff81\147\uff81\152\uff81" +
    "\153\uff81\154\uff81\155\uff81\156\uff81\157\uff81\001\002\000" +
    "\026\013\uff84\045\uff84\053\uff84\101\uff84\110\uff84\114\uff84" +
    "\121\uff84\124\uff84\150\uff84\151\uff84\001\002\000\064\013" +
    "\uffdd\024\061\025\056\045\uffdd\046\uff76\053\uffdd\064\152" +
    "\066\uff76\101\uffdd\110\uffdd\111\uff76\112\112\113\113\114" +
    "\uffdd\115\uff76\116\uff76\117\uff76\120\uff76\121\uffdd\122\110" +
    "\124\uffdd\135\uff76\136\uff76\150\uffdd\151\uffdd\001\002\000" +
    "\026\013\uff83\045\uff83\053\uff83\101\uff83\110\uff83\114\uff83" +
    "\121\uff83\124\uff83\150\uff83\151\uff83\001\002\000\004\135" +
    "\147\001\002\000\034\005\073\047\101\050\065\051\106" +
    "\113\063\117\062\120\074\152\022\153\102\154\077\155" +
    "\103\156\024\157\064\001\002\000\036\013\uffd5\043\uffd5" +
    "\045\uffd5\053\uffd5\101\uffd5\110\uffd5\114\uffd5\121\uffd5\124" +
    "\uffd5\133\uffd5\134\uffd5\137\uffd5\150\uffd5\151\uffd5\001\002" +
    "\000\032\013\uffda\043\uffda\045\uffda\053\uffda\101\uffda\110" +
    "\uffda\114\uffda\121\uffda\124\uffda\137\uffda\150\uffda\151\uffda" +
    "\001\002\000\034\005\073\047\101\050\065\051\106\113" +
    "\063\117\062\120\074\152\022\153\102\154\077\155\103" +
    "\156\024\157\064\001\002\000\032\013\uffd9\043\uffd9\045" +
    "\uffd9\053\uffd9\101\uffd9\110\uffd9\114\uffd9\121\uffd9\124\uffd9" +
    "\137\uffd9\150\uffd9\151\uffd9\001\002\000\036\013\uffd6\043" +
    "\uffd6\045\uffd6\053\uffd6\101\uffd6\110\uffd6\114\uffd6\121\uffd6" +
    "\124\uffd6\133\uffd6\134\uffd6\137\uffd6\150\uffd6\151\uffd6\001" +
    "\002\000\026\013\uff85\045\uff85\053\uff85\101\uff85\110\uff85" +
    "\114\uff85\121\uff85\124\uff85\150\uff85\151\uff85\001\002\000" +
    "\034\005\073\047\101\050\065\051\106\113\063\117\062" +
    "\120\074\152\022\153\102\154\077\155\103\156\024\157" +
    "\064\001\002\000\016\045\uff8b\101\uff8b\110\uff8b\114\uff8b" +
    "\121\uff8b\124\uff8b\001\002\000\034\005\ufffc\047\ufffc\050" +
    "\ufffc\051\ufffc\113\ufffc\117\ufffc\120\ufffc\152\ufffc\153\ufffc" +
    "\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001\002\000\034\005" +
    "\073\047\101\050\065\051\106\113\063\117\062\120\074" +
    "\152\022\153\102\154\077\155\103\156\024\157\064\001" +
    "\002\000\016\013\uff8f\045\uff8f\101\uff8f\114\uff8f\121\uff8f" +
    "\124\uff8f\001\002\000\034\005\ufffc\047\ufffc\050\ufffc\051" +
    "\ufffc\113\ufffc\117\ufffc\120\ufffc\152\ufffc\153\ufffc\154\ufffc" +
    "\155\ufffc\156\ufffc\157\ufffc\001\002\000\034\005\073\047" +
    "\101\050\065\051\106\113\063\117\062\120\074\152\022" +
    "\153\102\154\077\155\103\156\024\157\064\001\002\000" +
    "\016\045\uff87\101\uff87\114\uff87\121\uff87\124\uff87\151\uff87" +
    "\001\002\000\034\005\073\047\101\050\065\051\106\113" +
    "\063\117\062\120\074\152\022\153\102\154\077\155\103" +
    "\156\024\157\064\001\002\000\116\013\uff0a\024\uff0a\025" +
    "\uff0a\042\uff0a\043\uff0a\045\uff0a\046\uff0a\050\uff0a\053\uff0a" +
    "\064\uff0a\066\uff0a\101\uff0a\105\uff0a\110\uff0a\111\uff0a\112" +
    "\uff0a\113\uff0a\114\uff0a\115\uff0a\116\uff0a\117\uff0a\120\uff0a" +
    "\121\uff0a\122\uff0a\124\uff0a\125\uff0a\126\uff0a\127\uff0a\130" +
    "\uff0a\131\uff0a\132\uff0a\133\uff0a\134\uff0a\135\uff0a\136\uff0a" +
    "\137\uff0a\150\uff0a\151\uff0a\001\002\000\006\114\ufff4\121" +
    "\ufff4\001\002\000\034\005\ufffc\047\ufffc\050\ufffc\051\ufffc" +
    "\113\ufffc\117\ufffc\120\ufffc\152\ufffc\153\ufffc\154\ufffc\155" +
    "\ufffc\156\ufffc\157\ufffc\001\002\000\034\005\ufffc\047\ufffc" +
    "\050\ufffc\051\ufffc\113\ufffc\117\ufffc\120\ufffc\152\ufffc\153" +
    "\ufffc\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001\002\000\034" +
    "\005\ufffc\047\ufffc\050\ufffc\051\ufffc\113\ufffc\117\ufffc\120" +
    "\ufffc\152\ufffc\153\ufffc\154\ufffc\155\ufffc\156\ufffc\157\ufffc" +
    "\001\002\000\034\005\073\047\101\050\065\051\106\113" +
    "\063\117\062\120\074\152\022\153\102\154\077\155\103" +
    "\156\024\157\064\001\002\000\034\005\ufffc\047\ufffc\050" +
    "\ufffc\051\ufffc\113\ufffc\117\ufffc\120\ufffc\152\ufffc\153\ufffc" +
    "\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001\002\000\034\005" +
    "\073\047\101\050\065\051\106\113\063\117\062\120\074" +
    "\152\022\153\102\154\077\155\103\156\024\157\064\001" +
    "\002\000\016\045\uff8e\053\uff8e\101\uff8e\114\uff8e\121\uff8e" +
    "\124\uff8e\001\002\000\016\045\uff8c\101\uff8c\110\uff8c\114" +
    "\uff8c\121\uff8c\124\uff8c\001\002\000\034\005\073\047\101" +
    "\050\065\051\106\113\063\117\062\120\074\152\022\153" +
    "\102\154\077\155\103\156\024\157\064\001\002\000\016" +
    "\045\uff8a\101\uff8a\114\uff8a\121\uff8a\124\uff8a\150\uff8a\001" +
    "\002\000\034\005\073\047\101\050\065\051\106\113\063" +
    "\117\062\120\074\152\022\153\102\154\077\155\103\156" +
    "\024\157\064\001\002\000\016\013\uff90\045\uff90\101\uff90" +
    "\114\uff90\121\uff90\124\uff90\001\002\000\034\005\073\047" +
    "\101\050\065\051\106\113\063\117\062\120\074\152\022" +
    "\153\102\154\077\155\103\156\024\157\064\001\002\000" +
    "\016\045\uff88\101\uff88\114\uff88\121\uff88\124\uff88\151\uff88" +
    "\001\002\000\034\005\073\047\101\050\065\051\106\113" +
    "\063\117\062\120\074\152\022\153\102\154\077\155\103" +
    "\156\024\157\064\001\002\000\006\114\ufff2\121\ufff2\001" +
    "\002\000\034\005\ufffc\047\ufffc\050\ufffc\051\ufffc\113\ufffc" +
    "\117\ufffc\120\ufffc\152\ufffc\153\ufffc\154\ufffc\155\ufffc\156" +
    "\ufffc\157\ufffc\001\002\000\034\005\073\047\101\050\065" +
    "\051\106\113\063\117\062\120\074\152\022\153\102\154" +
    "\077\155\103\156\024\157\064\001\002\000\016\045\uff8d" +
    "\053\uff8d\101\uff8d\114\uff8d\121\uff8d\124\uff8d\001\002\000" +
    "\034\005\ufffc\047\ufffc\050\ufffc\051\ufffc\113\ufffc\117\ufffc" +
    "\120\ufffc\152\ufffc\153\ufffc\154\ufffc\155\ufffc\156\ufffc\157" +
    "\ufffc\001\002\000\034\005\073\047\101\050\065\051\106" +
    "\113\063\117\062\120\074\152\022\153\102\154\077\155" +
    "\103\156\024\157\064\001\002\000\016\045\uff89\101\uff89" +
    "\114\uff89\121\uff89\124\uff89\150\uff89\001\002\000\102\013" +
    "\uff60\042\uff60\043\uff60\045\uff60\046\uff60\050\uff60\053\uff60" +
    "\064\uff60\066\uff60\101\uff60\110\uff60\111\uff60\114\uff60\115" +
    "\uff60\116\uff60\117\uff60\120\uff60\121\uff60\124\uff60\125\uff60" +
    "\126\uff60\127\uff60\130\uff60\131\uff60\132\uff60\133\uff60\134" +
    "\uff60\135\uff60\136\uff60\137\uff60\150\uff60\151\uff60\001\002" +
    "\000\036\005\073\047\101\050\065\051\106\054\230\113" +
    "\063\117\062\120\074\152\022\153\102\154\077\155\103" +
    "\156\024\157\064\001\002\000\006\114\251\121\250\001" +
    "\002\000\006\133\237\134\245\001\002\000\006\133\uffb2" +
    "\134\uffb2\001\002\000\076\013\uff76\042\uff76\046\uff76\050" +
    "\uff76\053\uff76\064\152\066\uff76\110\uff76\111\uff76\112\112" +
    "\113\113\114\uff76\115\uff76\116\uff76\117\uff76\120\uff76\121" +
    "\uff76\122\110\125\uff76\126\uff76\127\uff76\130\uff76\131\uff76" +
    "\132\uff76\133\uff76\134\uff76\135\uff76\136\uff76\150\uff76\151" +
    "\uff76\001\002\000\006\114\243\121\uff98\001\002\000\006" +
    "\133\uffb1\134\uffb1\001\002\000\004\121\232\001\002\000" +
    "\006\133\uffb4\134\uffb4\001\002\000\046\013\uff86\042\131" +
    "\050\137\053\uff86\110\uff86\114\uff86\121\uff86\125\135\126" +
    "\141\127\133\130\136\131\130\132\140\133\uffb5\134\uffb5" +
    "\135\147\150\uff86\151\uff86\001\002\000\036\005\073\047" +
    "\101\050\065\051\106\054\230\113\063\117\062\120\074" +
    "\152\022\153\102\154\077\155\103\156\024\157\064\001" +
    "\002\000\006\133\237\134\236\001\002\000\006\114\uff98" +
    "\121\uff98\001\002\000\006\114\uff9a\121\uff9a\001\002\000" +
    "\034\005\073\047\101\050\065\051\106\113\063\117\062" +
    "\120\074\152\022\153\102\154\077\155\103\156\024\157" +
    "\064\001\002\000\036\005\073\047\101\050\065\051\106" +
    "\054\230\113\063\117\062\120\074\152\022\153\102\154" +
    "\077\155\103\156\024\157\064\001\002\000\006\133\uffb0" +
    "\134\uffb0\001\002\000\010\133\uffb5\134\uffb5\135\147\001" +
    "\002\000\006\114\uff97\121\uff97\001\002\000\102\013\uff61" +
    "\042\uff61\043\uff61\045\uff61\046\uff61\050\uff61\053\uff61\064" +
    "\uff61\066\uff61\101\uff61\110\uff61\111\uff61\114\uff61\115\uff61" +
    "\116\uff61\117\uff61\120\uff61\121\uff61\124\uff61\125\uff61\126" +
    "\uff61\127\uff61\130\uff61\131\uff61\132\uff61\133\uff61\134\uff61" +
    "\135\uff61\136\uff61\137\uff61\150\uff61\151\uff61\001\002\000" +
    "\006\133\uffb3\134\uffb3\001\002\000\034\005\073\047\101" +
    "\050\065\051\106\113\063\117\062\120\074\152\022\153" +
    "\102\154\077\155\103\156\024\157\064\001\002\000\006" +
    "\114\247\121\uff97\001\002\000\102\013\uff9b\042\uff9b\043" +
    "\uff9b\045\uff9b\046\uff9b\050\uff9b\053\uff9b\064\uff9b\066\uff9b" +
    "\101\uff9b\110\uff9b\111\uff9b\114\uff9b\115\uff9b\116\uff9b\117" +
    "\uff9b\120\uff9b\121\uff9b\124\uff9b\125\uff9b\126\uff9b\127\uff9b" +
    "\130\uff9b\131\uff9b\132\uff9b\133\uff9b\134\uff9b\135\uff9b\136" +
    "\uff9b\137\uff9b\150\uff9b\151\uff9b\001\002\000\036\005\073" +
    "\047\101\050\065\051\106\054\230\113\063\117\062\120" +
    "\074\152\022\153\102\154\077\155\103\156\024\157\064" +
    "\001\002\000\102\013\uff9c\042\uff9c\043\uff9c\045\uff9c\046" +
    "\uff9c\050\uff9c\053\uff9c\064\uff9c\066\uff9c\101\uff9c\110\uff9c" +
    "\111\uff9c\114\uff9c\115\uff9c\116\uff9c\117\uff9c\120\uff9c\121" +
    "\uff9c\124\uff9c\125\uff9c\126\uff9c\127\uff9c\130\uff9c\131\uff9c" +
    "\132\uff9c\133\uff9c\134\uff9c\135\uff9c\136\uff9c\137\uff9c\150" +
    "\uff9c\151\uff9c\001\002\000\006\114\uff99\121\uff99\001\002" +
    "\000\116\013\uffa3\024\uffa3\025\uffa3\042\uffa3\043\uffa3\045" +
    "\uffa3\046\uffa3\050\uffa3\053\uffa3\064\uffa3\066\uffa3\101\uffa3" +
    "\105\uffa3\110\uffa3\111\uffa3\112\uffa3\113\uffa3\114\uffa3\115" +
    "\uffa3\116\uffa3\117\uffa3\120\uffa3\121\uffa3\122\uffa3\124\uffa3" +
    "\125\uffa3\126\uffa3\127\uffa3\130\uffa3\131\uffa3\132\uffa3\133" +
    "\uffa3\134\uffa3\135\uffa3\136\uffa3\137\uffa3\150\uffa3\151\uffa3" +
    "\001\002\000\116\013\uffa4\024\uffa4\025\uffa4\042\uffa4\043" +
    "\uffa4\045\uffa4\046\uffa4\050\uffa4\053\uffa4\064\uffa4\066\uffa4" +
    "\101\uffa4\105\uffa4\110\uffa4\111\uffa4\112\uffa4\113\uffa4\114" +
    "\uffa4\115\uffa4\116\uffa4\117\uffa4\120\uffa4\121\uffa4\122\uffa4" +
    "\124\uffa4\125\uffa4\126\uffa4\127\uffa4\130\uffa4\131\uffa4\132" +
    "\uffa4\133\uffa4\134\uffa4\135\uffa4\136\uffa4\137\uffa4\150\uffa4" +
    "\151\uffa4\001\002\000\116\013\uffa2\024\uffa2\025\uffa2\042" +
    "\uffa2\043\uffa2\045\uffa2\046\uffa2\050\uffa2\053\uffa2\064\uffa2" +
    "\066\uffa2\101\uffa2\105\uffa2\110\uffa2\111\uffa2\112\uffa2\113" +
    "\uffa2\114\uffa2\115\uffa2\116\uffa2\117\uffa2\120\uffa2\121\uffa2" +
    "\122\uffa2\124\uffa2\125\uffa2\126\uffa2\127\uffa2\130\uffa2\131" +
    "\uffa2\132\uffa2\133\uffa2\134\uffa2\135\uffa2\136\uffa2\137\uffa2" +
    "\150\uffa2\151\uffa2\001\002\000\070\013\uff7f\042\uff7f\043" +
    "\uff7f\045\uff7f\050\uff7f\053\uff7f\064\uff7f\101\uff7f\110\uff7f" +
    "\111\262\114\uff7f\117\257\120\260\121\uff7f\124\uff7f\125" +
    "\uff7f\126\uff7f\127\uff7f\130\uff7f\131\uff7f\132\uff7f\133\uff7f" +
    "\134\uff7f\135\uff7f\137\uff7f\150\uff7f\151\uff7f\001\002\000" +
    "\024\047\uff6c\051\uff6c\113\uff6c\152\uff6c\153\uff6c\154\uff6c" +
    "\155\uff6c\156\uff6c\157\uff6c\001\002\000\024\047\uff6b\051" +
    "\uff6b\113\uff6b\152\uff6b\153\uff6b\154\uff6b\155\uff6b\156\uff6b" +
    "\157\uff6b\001\002\000\024\047\101\051\106\113\063\152" +
    "\022\153\102\154\077\155\103\156\024\157\064\001\002" +
    "\000\024\047\uff6a\051\uff6a\113\uff6a\152\uff6a\153\uff6a\154" +
    "\uff6a\155\uff6a\156\uff6a\157\uff6a\001\002\000\100\013\uff7d" +
    "\042\uff7d\043\uff7d\045\uff7d\046\264\050\uff7d\053\uff7d\064" +
    "\uff7d\066\267\101\uff7d\110\uff7d\111\uff7d\114\uff7d\115\270" +
    "\116\266\117\uff7d\120\uff7d\121\uff7d\124\uff7d\125\uff7d\126" +
    "\uff7d\127\uff7d\130\uff7d\131\uff7d\132\uff7d\133\uff7d\134\uff7d" +
    "\135\uff7d\137\uff7d\150\uff7d\151\uff7d\001\002\000\024\047" +
    "\uff63\051\uff63\113\uff63\152\uff63\153\uff63\154\uff63\155\uff63" +
    "\156\uff63\157\uff63\001\002\000\024\047\101\051\106\113" +
    "\063\152\022\153\102\154\077\155\103\156\024\157\064" +
    "\001\002\000\024\047\uff64\051\uff64\113\uff64\152\uff64\153" +
    "\uff64\154\uff64\155\uff64\156\uff64\157\uff64\001\002\000\024" +
    "\047\uff62\051\uff62\113\uff62\152\uff62\153\uff62\154\uff62\155" +
    "\uff62\156\uff62\157\uff62\001\002\000\024\047\uff65\051\uff65" +
    "\113\uff65\152\uff65\153\uff65\154\uff65\155\uff65\156\uff65\157" +
    "\uff65\001\002\000\100\013\uff7b\042\uff7b\043\uff7b\045\uff7b" +
    "\046\uff7b\050\uff7b\053\uff7b\064\uff7b\066\uff7b\101\uff7b\110" +
    "\uff7b\111\uff7b\114\uff7b\115\uff7b\116\uff7b\117\uff7b\120\uff7b" +
    "\121\uff7b\124\uff7b\125\uff7b\126\uff7b\127\uff7b\130\uff7b\131" +
    "\uff7b\132\uff7b\133\uff7b\134\uff7b\135\uff7b\137\uff7b\150\uff7b" +
    "\151\uff7b\001\002\000\106\013\uff5f\042\uff5f\043\uff5f\045" +
    "\uff5f\046\uff5f\050\uff5f\053\uff5f\064\uff5f\066\uff5f\101\uff5f" +
    "\110\uff5f\111\uff5f\113\113\114\uff5f\115\uff5f\116\uff5f\117" +
    "\uff5f\120\uff5f\121\uff5f\122\110\124\uff5f\125\uff5f\126\uff5f" +
    "\127\uff5f\130\uff5f\131\uff5f\132\uff5f\133\uff5f\134\uff5f\135" +
    "\uff5f\136\uff5f\137\uff5f\150\uff5f\151\uff5f\001\002\000\024" +
    "\047\101\051\106\113\063\152\022\153\102\154\077\155" +
    "\103\156\024\157\064\001\002\000\100\013\uff79\042\uff79" +
    "\043\uff79\045\uff79\046\uff79\050\uff79\053\uff79\064\uff79\066" +
    "\uff79\101\uff79\110\uff79\111\uff79\114\uff79\115\uff79\116\uff79" +
    "\117\uff79\120\uff79\121\uff79\124\uff79\125\uff79\126\uff79\127" +
    "\uff79\130\uff79\131\uff79\132\uff79\133\uff79\134\uff79\135\uff79" +
    "\137\uff79\150\uff79\151\uff79\001\002\000\032\013\uffcf\043" +
    "\uffcf\045\uffcf\053\uffcf\101\uffcf\110\uffcf\114\uffcf\121\uffcf" +
    "\124\uffcf\137\uffcf\150\uffcf\151\uffcf\001\002\000\032\013" +
    "\uffd0\043\uffd0\045\uffd0\053\uffd0\101\uffd0\110\uffd0\114\uffd0" +
    "\121\uffd0\124\uffd0\137\uffd0\150\uffd0\151\uffd0\001\002\000" +
    "\006\114\300\121\uff98\001\002\000\102\013\uff73\042\uff73" +
    "\043\uff73\045\uff73\046\uff73\050\uff73\053\uff73\064\uff73\066" +
    "\uff73\101\uff73\110\uff73\111\uff73\114\uff73\115\uff73\116\uff73" +
    "\117\uff73\120\uff73\121\uff73\124\uff73\125\uff73\126\uff73\127" +
    "\uff73\130\uff73\131\uff73\132\uff73\133\uff73\134\uff73\135\uff73" +
    "\136\uff73\137\uff73\150\uff73\151\uff73\001\002\000\034\013" +
    "\uffd1\043\uffd1\045\uffd1\053\uffd1\064\152\101\uffd1\110\uffd1" +
    "\114\uffd1\121\uffd1\124\uffd1\137\uffd1\150\uffd1\151\uffd1\001" +
    "\002\000\032\013\uffd2\043\uffd2\045\uffd2\053\uffd2\101\uffd2" +
    "\110\uffd2\114\uffd2\121\uffd2\124\uffd2\137\uffd2\150\uffd2\151" +
    "\uffd2\001\002\000\032\013\uffd8\043\uffd8\045\uffd8\053\uffd8" +
    "\101\uffd8\110\uffd8\114\uffd8\121\uffd8\124\uffd8\137\uffd8\150" +
    "\uffd8\151\uffd8\001\002\000\034\005\073\047\101\050\065" +
    "\051\106\113\063\117\062\120\074\152\022\153\102\154" +
    "\077\155\103\156\024\157\064\001\002\000\006\114\uff1a" +
    "\124\uff1a\001\002\000\006\114\uffe9\124\uffe9\001\002\000" +
    "\014\145\uff16\146\uff16\147\uff16\152\uff16\156\uff16\001\002" +
    "\000\006\121\uffe5\123\uffe5\001\002\000\004\152\022\001" +
    "\002\000\020\042\037\055\036\145\uff19\146\uff19\147\uff19" +
    "\152\uff19\156\uff19\001\002\000\014\145\044\146\043\147" +
    "\054\152\022\156\024\001\002\000\010\114\uffea\124\uffea" +
    "\137\304\001\002\000\006\114\uff1b\124\uff1b\001\002\000" +
    "\006\121\uffe6\123\uffe6\001\002\000\004\152\022\001\002" +
    "\000\004\114\321\001\002\000\010\043\uff20\071\uff20\124" +
    "\uff20\001\002\000\006\114\uff1c\124\uff1c\001\002\000\014" +
    "\145\044\146\043\147\054\152\022\156\024\001\002\000" +
    "\006\043\325\124\uff28\001\002\000\020\003\uff25\016\uff25" +
    "\036\uff25\061\uff25\075\uff25\102\uff25\152\uff25\001\002\000" +
    "\004\002\001\001\002\000\010\002\uff07\036\uff07\061\uff07" +
    "\001\002\000\004\016\u0133\001\002\000\020\003\343\016" +
    "\uffae\036\014\061\005\075\336\102\340\152\022\001\002" +
    "\000\020\003\uffed\016\uffed\036\uffed\061\uffed\075\uffed\102" +
    "\uffed\152\uffed\001\002\000\020\003\uffab\016\uffab\036\uffab" +
    "\061\uffab\075\uffab\102\uffab\152\uffab\001\002\000\020\003" +
    "\ufff1\016\ufff1\036\ufff1\061\ufff1\075\ufff1\102\ufff1\152\ufff1" +
    "\001\002\000\006\121\311\123\u012a\001\002\000\004\152" +
    "\022\001\002\000\020\003\uffac\016\uffac\036\uffac\061\uffac" +
    "\075\uffac\102\uffac\152\uffac\001\002\000\004\152\022\001" +
    "\002\000\020\003\uffee\016\uffee\036\uffee\061\uffee\075\uffee" +
    "\102\uffee\152\uffee\001\002\000\020\003\ufff0\016\ufff0\036" +
    "\ufff0\061\ufff0\075\ufff0\102\ufff0\152\ufff0\001\002\000\004" +
    "\124\361\001\002\000\006\121\034\123\350\001\002\000" +
    "\020\003\uffef\016\uffef\036\uffef\061\uffef\075\uffef\102\uffef" +
    "\152\uffef\001\002\000\020\003\uffe2\016\uffe2\036\uffe2\061" +
    "\uffe2\075\uffe2\102\uffe2\152\uffe2\001\002\000\020\003\uffaa" +
    "\016\uffaa\036\uffaa\061\uffaa\075\uffaa\102\uffaa\152\uffaa\001" +
    "\002\000\016\021\351\145\000\146\000\147\000\152\000" +
    "\156\000\001\002\000\016\137\356\145\uffff\146\uffff\147" +
    "\uffff\152\uffff\156\uffff\001\002\000\014\145\044\146\043" +
    "\147\054\152\022\156\024\001\002\000\006\124\uffea\137" +
    "\304\001\002\000\004\124\355\001\002\000\020\003\uffeb" +
    "\016\uffeb\036\uffeb\061\uffeb\075\uffeb\102\uffeb\152\uffeb\001" +
    "\002\000\034\005\073\047\101\050\065\051\106\113\063" +
    "\117\062\120\074\152\022\153\102\154\077\155\103\156" +
    "\024\157\064\001\002\000\004\124\360\001\002\000\020" +
    "\003\uffe7\016\uffe7\036\uffe7\061\uffe7\075\uffe7\102\uffe7\152" +
    "\uffe7\001\002\000\020\003\uffa9\016\uffa9\036\uffa9\061\uffa9" +
    "\075\uffa9\102\uffa9\152\uffa9\001\002\000\010\043\uffe1\113" +
    "\364\124\uffe1\001\002\000\006\043\u0104\124\u0103\001\002" +
    "\000\004\152\022\001\002\000\006\043\uffe0\124\uffe0\001" +
    "\002\000\006\114\uffbc\124\uffbc\001\002\000\006\114\u0100" +
    "\124\u0101\001\002\000\006\121\311\123\375\001\002\000" +
    "\006\121\034\123\372\001\002\000\014\145\044\146\043" +
    "\147\054\152\022\156\024\001\002\000\010\114\uffea\124" +
    "\uffea\137\304\001\002\000\006\114\uffb9\124\uffb9\001\002" +
    "\000\014\145\044\146\043\147\054\152\022\156\024\001" +
    "\002\000\010\114\uffea\124\uffea\137\304\001\002\000\006" +
    "\114\uffba\124\uffba\001\002\000\006\043\uffbd\124\uffbd\001" +
    "\002\000\004\152\022\001\002\000\006\114\uffbb\124\uffbb" +
    "\001\002\000\020\003\uffaf\016\uffaf\036\uffaf\061\uffaf\075" +
    "\uffaf\102\uffaf\152\uffaf\001\002\000\004\065\uffe4\001\002" +
    "\000\004\065\u0106\001\002\000\014\003\uffcb\020\uffcb\031" +
    "\uffcb\051\uffcb\152\uffcb\001\002\000\004\124\u0109\001\002" +
    "\000\004\124\uffdf\001\002\000\020\003\uffe3\016\uffe3\036" +
    "\uffe3\061\uffe3\075\uffe3\102\uffe3\152\uffe3\001\002\000\014" +
    "\003\uffc4\020\uffc4\031\uffc4\051\u010d\152\uffc4\001\002\000" +
    "\014\003\u0114\020\uffc8\031\uffc8\105\uffc8\152\022\001\002" +
    "\000\004\031\uffca\001\002\000\004\124\uffc6\001\002\000" +
    "\004\124\u010f\001\002\000\006\031\uffc5\105\uffc5\001\002" +
    "\000\004\031\u0111\001\002\000\004\065\u0112\001\002\000" +
    "\004\124\uffc9\001\002\000\010\020\u011b\031\uffc2\105\uffc2" +
    "\001\002\000\014\003\uffbe\020\uffbe\031\uffbe\105\uffbe\152" +
    "\uffbe\001\002\000\004\124\uffc0\001\002\000\014\003\uffc3" +
    "\020\uffc3\031\uffc3\105\uffc3\152\uffc3\001\002\000\004\124" +
    "\u0118\001\002\000\014\003\uffbf\020\uffbf\031\uffbf\105\uffbf" +
    "\152\uffbf\001\002\000\006\031\uffc1\105\uffc1\001\002\000" +
    "\006\031\uffc7\105\uffc7\001\002\000\006\152\022\156\024" +
    "\001\002\000\010\043\u011d\113\113\122\110\001\002\000" +
    "\006\031\uffb7\105\uffb7\001\002\000\006\031\u0120\105\u011f" +
    "\001\002\000\036\005\073\047\101\050\065\051\106\054" +
    "\230\113\063\117\062\120\074\152\022\153\102\154\077" +
    "\155\103\156\024\157\064\001\002\000\004\020\u0121\001" +
    "\002\000\004\124\u0122\001\002\000\006\031\uffb8\105\uffb8" +
    "\001\002\000\006\133\237\134\u0124\001\002\000\016\003" +
    "\uffc4\020\uffc4\031\uffc4\051\u010d\105\uffc4\152\uffc4\001\002" +
    "\000\006\031\uffb6\105\uffb6\001\002\000\004\043\u0127\001" +
    "\002\000\014\145\044\146\043\147\054\152\022\156\024" +
    "\001\002\000\004\124\u0129\001\002\000\020\003\uffde\016" +
    "\uffde\036\uffde\061\uffde\075\uffde\102\uffde\152\uffde\001\002" +
    "\000\016\021\u012b\145\000\146\000\147\000\152\000\156" +
    "\000\001\002\000\016\137\u0130\145\uffff\146\uffff\147\uffff" +
    "\152\uffff\156\uffff\001\002\000\014\145\044\146\043\147" +
    "\054\152\022\156\024\001\002\000\006\124\uffea\137\304" +
    "\001\002\000\004\124\u012f\001\002\000\020\003\uffec\016" +
    "\uffec\036\uffec\061\uffec\075\uffec\102\uffec\152\uffec\001\002" +
    "\000\034\005\073\047\101\050\065\051\106\113\063\117" +
    "\062\120\074\152\022\153\102\154\077\155\103\156\024" +
    "\157\064\001\002\000\004\124\u0132\001\002\000\020\003" +
    "\uffe8\016\uffe8\036\uffe8\061\uffe8\075\uffe8\102\uffe8\152\uffe8" +
    "\001\002\000\042\003\uff15\016\uff15\022\uff15\034\uff15\035" +
    "\uff15\040\uff15\041\uff15\045\uff15\051\uff15\071\uff15\106\uff15" +
    "\140\uff15\143\uff15\144\uff15\152\uff15\156\uff15\001\002\000" +
    "\042\003\u0136\016\uff59\022\uff59\034\uff59\035\uff59\040\uff59" +
    "\041\uff59\045\uff59\051\uff59\071\uff59\106\uff59\140\uff59\143" +
    "\uff59\144\uff59\152\uff59\156\uff59\001\002\000\044\003\ufffc" +
    "\016\ufffc\022\ufffc\031\u01c4\034\ufffc\035\ufffc\040\ufffc\041" +
    "\ufffc\045\ufffc\051\ufffc\071\ufffc\106\ufffc\140\ufffc\143\ufffc" +
    "\144\ufffc\152\ufffc\156\ufffc\001\002\000\050\003\uff5a\016" +
    "\uff5a\022\uff5a\027\uff5a\030\uff5a\031\uff5a\034\uff5a\035\uff5a" +
    "\040\uff5a\041\uff5a\045\uff5a\051\uff5a\071\uff5a\106\uff5a\140" +
    "\uff5a\143\uff5a\144\uff5a\152\uff5a\156\uff5a\001\002\000\040" +
    "\016\uff34\022\u0152\034\u0139\035\u0150\040\u013d\041\u0142\045" +
    "\uff3c\051\u0151\071\u0140\106\u013e\140\u014d\143\u0146\144\u0155" +
    "\152\022\156\024\001\002\000\050\003\uff5e\016\uff5e\022" +
    "\uff5e\027\uff5e\030\uff5e\031\uff5e\034\uff5e\035\uff5e\040\uff5e" +
    "\041\uff5e\045\uff5e\051\uff5e\071\uff5e\106\uff5e\140\uff5e\143" +
    "\uff5e\144\uff5e\152\uff5e\156\uff5e\001\002\000\012\105\uff31" +
    "\124\uff31\152\022\156\024\001\002\000\050\003\uff51\016" +
    "\uff51\022\uff51\027\uff51\030\uff51\031\uff51\034\uff51\035\uff51" +
    "\040\uff51\041\uff51\045\uff51\051\uff51\071\uff51\106\uff51\140" +
    "\uff51\143\uff51\144\uff51\152\uff51\156\uff51\001\002\000\016" +
    "\112\uffa8\113\uffa8\122\uffa8\123\u01b0\124\uffa8\137\uffa8\001" +
    "\002\000\050\003\uff50\016\uff50\022\uff50\027\uff50\030\uff50" +
    "\031\uff50\034\uff50\035\uff50\040\uff50\041\uff50\045\uff50\051" +
    "\uff50\071\uff50\106\uff50\140\uff50\143\uff50\144\uff50\152\uff50" +
    "\156\uff50\001\002\000\006\152\022\156\024\001\002\000" +
    "\034\005\ufffc\047\ufffc\050\ufffc\051\ufffc\113\ufffc\117\ufffc" +
    "\120\ufffc\152\ufffc\153\ufffc\154\ufffc\155\ufffc\156\ufffc\157" +
    "\ufffc\001\002\000\050\003\uff57\016\uff57\022\uff57\027\uff57" +
    "\030\uff57\031\uff57\034\uff57\035\uff57\040\uff57\041\uff57\045" +
    "\uff57\051\uff57\071\uff57\106\uff57\140\uff57\143\uff57\144\uff57" +
    "\152\uff57\156\uff57\001\002\000\036\005\073\047\101\050" +
    "\065\051\106\113\063\117\062\120\074\124\u01a9\152\022" +
    "\153\102\154\077\155\103\156\024\157\064\001\002\000" +
    "\050\003\uff56\016\uff56\022\uff56\027\uff56\030\uff56\031\uff56" +
    "\034\uff56\035\uff56\040\uff56\041\uff56\045\uff56\051\uff56\071" +
    "\uff56\106\uff56\140\uff56\143\uff56\144\uff56\152\uff56\156\uff56" +
    "\001\002\000\034\005\073\047\101\050\065\051\106\113" +
    "\063\117\062\120\074\152\022\153\102\154\077\155\103" +
    "\156\024\157\064\001\002\000\050\003\uff5b\016\uff5b\022" +
    "\uff5b\027\uff5b\030\uff5b\031\uff5b\034\uff5b\035\uff5b\040\uff5b" +
    "\041\uff5b\045\uff5b\051\uff5b\071\uff5b\106\uff5b\140\uff5b\143" +
    "\uff5b\144\uff5b\152\uff5b\156\uff5b\001\002\000\050\003\uff4e" +
    "\016\uff4e\022\uff4e\027\uff4e\030\uff4e\031\uff4e\034\uff4e\035" +
    "\uff4e\040\uff4e\041\uff4e\045\uff4e\051\uff4e\071\uff4e\106\uff4e" +
    "\140\uff4e\143\uff4e\144\uff4e\152\uff4e\156\uff4e\001\002\000" +
    "\040\016\uff58\022\uff58\034\uff58\035\uff58\040\uff58\041\uff58" +
    "\045\uff58\051\uff58\071\uff58\106\uff58\140\uff58\143\uff58\144" +
    "\uff58\152\uff58\156\uff58\001\002\000\004\113\u01a2\001\002" +
    "\000\050\003\uff52\016\uff52\022\uff52\027\uff52\030\uff52\031" +
    "\uff52\034\uff52\035\uff52\040\uff52\041\uff52\045\uff52\051\uff52" +
    "\071\uff52\106\uff52\140\uff52\143\uff52\144\uff52\152\uff52\156" +
    "\uff52\001\002\000\050\003\uff4f\016\uff4f\022\uff4f\027\uff4f" +
    "\030\uff4f\031\uff4f\034\uff4f\035\uff4f\040\uff4f\041\uff4f\045" +
    "\uff4f\051\uff4f\071\uff4f\106\uff4f\140\uff4f\143\uff4f\144\uff4f" +
    "\152\uff4f\156\uff4f\001\002\000\004\045\ufffc\001\002\000" +
    "\004\016\u0192\001\002\000\050\003\uff53\016\uff53\022\uff53" +
    "\027\uff53\030\uff53\031\uff53\034\uff53\035\uff53\040\uff53\041" +
    "\uff53\045\uff53\051\uff53\071\uff53\106\uff53\140\uff53\143\uff53" +
    "\144\uff53\152\uff53\156\uff53\001\002\000\010\027\ufffb\030" +
    "\ufffb\031\uff44\001\002\000\004\152\022\001\002\000\050" +
    "\003\uff55\016\uff55\022\uff55\027\uff55\030\uff55\031\uff55\034" +
    "\uff55\035\uff55\040\uff55\041\uff55\045\uff55\051\uff55\071\uff55" +
    "\106\uff55\140\uff55\143\uff55\144\uff55\152\uff55\156\uff55\001" +
    "\002\000\004\124\u0172\001\002\000\004\152\022\001\002" +
    "\000\004\124\u0164\001\002\000\020\003\uffad\016\uffad\036" +
    "\uffad\061\uffad\075\uffad\102\uffad\152\uffad\001\002\000\050" +
    "\003\uff5c\016\uff5c\022\uff5c\027\uff5c\030\uff5c\031\uff5c\034" +
    "\uff5c\035\uff5c\040\uff5c\041\uff5c\045\uff5c\051\uff5c\071\uff5c" +
    "\106\uff5c\140\uff5c\143\uff5c\144\uff5c\152\uff5c\156\uff5c\001" +
    "\002\000\050\003\uff54\016\uff54\022\uff54\027\uff54\030\uff54" +
    "\031\uff54\034\uff54\035\uff54\040\uff54\041\uff54\045\uff54\051" +
    "\uff54\071\uff54\106\uff54\140\uff54\143\uff54\144\uff54\152\uff54" +
    "\156\uff54\001\002\000\004\113\u015b\001\002\000\014\112" +
    "\112\113\113\122\110\124\u0158\137\u0157\001\002\000\034" +
    "\005\073\047\101\050\065\051\106\113\063\117\062\120" +
    "\074\152\022\153\102\154\077\155\103\156\024\157\064" +
    "\001\002\000\050\003\uff10\016\uff10\022\uff10\027\uff10\030" +
    "\uff10\031\uff10\034\uff10\035\uff10\040\uff10\041\uff10\045\uff10" +
    "\051\uff10\071\uff10\106\uff10\140\uff10\143\uff10\144\uff10\152" +
    "\uff10\156\uff10\001\002\000\004\124\u015a\001\002\000\050" +
    "\003\uff4b\016\uff4b\022\uff4b\027\uff4b\030\uff4b\031\uff4b\034" +
    "\uff4b\035\uff4b\040\uff4b\041\uff4b\045\uff4b\051\uff4b\071\uff4b" +
    "\106\uff4b\140\uff4b\143\uff4b\144\uff4b\152\uff4b\156\uff4b\001" +
    "\002\000\006\152\022\156\024\001\002\000\006\113\113" +
    "\122\110\001\002\000\010\113\uffa8\114\u0161\122\uffa8\001" +
    "\002\000\010\113\uffa7\114\u015f\122\uffa7\001\002\000\004" +
    "\124\u0160\001\002\000\050\003\uff0d\016\uff0d\022\uff0d\027" +
    "\uff0d\030\uff0d\031\uff0d\034\uff0d\035\uff0d\040\uff0d\041\uff0d" +
    "\045\uff0d\051\uff0d\071\uff0d\106\uff0d\140\uff0d\143\uff0d\144" +
    "\uff0d\152\uff0d\156\uff0d\001\002\000\004\124\u0162\001\002" +
    "\000\050\003\uff0e\016\uff0e\022\uff0e\027\uff0e\030\uff0e\031" +
    "\uff0e\034\uff0e\035\uff0e\040\uff0e\041\uff0e\045\uff0e\051\uff0e" +
    "\071\uff0e\106\uff0e\140\uff0e\143\uff0e\144\uff0e\152\uff0e\156" +
    "\uff0e\001\002\000\004\016\uff33\001\002\000\050\003\uff4c" +
    "\016\uff4c\022\uff4c\027\uff4c\030\uff4c\031\uff4c\034\uff4c\035" +
    "\uff4c\040\uff4c\041\uff4c\045\uff4c\051\uff4c\071\uff4c\106\uff4c" +
    "\140\uff4c\143\uff4c\144\uff4c\152\uff4c\156\uff4c\001\002\000" +
    "\004\042\u0166\001\002\000\042\005\073\047\101\050\065" +
    "\051\106\072\u016b\113\063\117\062\120\074\146\043\147" +
    "\u0167\152\022\153\102\154\077\155\103\156\024\157\064" +
    "\001\002\000\006\045\ufff9\064\ufff9\001\002\000\004\045" +
    "\uffcc\001\002\000\004\045\ufffc\001\002\000\006\045\uffd1" +
    "\064\152\001\002\000\040\005\073\047\101\050\065\051" +
    "\106\113\063\117\062\120\074\146\043\147\u0167\152\022" +
    "\153\102\154\077\155\103\156\024\157\064\001\002\000" +
    "\036\045\uffd1\046\uff76\064\152\066\uff76\111\uff76\112\112" +
    "\113\113\115\uff76\116\uff76\117\uff76\120\uff76\122\110\135" +
    "\uff76\136\uff76\001\002\000\004\045\uffce\001\002\000\004" +
    "\045\ufffc\001\002\000\004\045\uff3a\001\002\000\004\045" +
    "\uffcd\001\002\000\004\045\uff3b\001\002\000\050\003\uff03" +
    "\016\uff03\022\uff03\027\uff03\030\uff03\031\uff03\034\uff03\035" +
    "\uff03\040\uff03\041\uff03\045\uff03\051\uff03\071\uff03\106\uff03" +
    "\140\uff03\143\uff03\144\uff03\152\uff03\156\uff03\001\002\000" +
    "\004\141\u0174\001\002\000\040\016\uff4d\022\uff4d\034\uff4d" +
    "\035\uff4d\040\uff4d\041\uff4d\045\uff4d\051\uff4d\071\uff4d\106" +
    "\uff4d\140\uff4d\143\uff4d\144\uff4d\152\uff4d\156\uff4d\001\002" +
    "\000\004\031\u018f\001\002\000\006\027\u0178\030\ufffc\001" +
    "\002\000\004\030\u017e\001\002\000\042\003\ufffc\016\ufffc" +
    "\022\ufffc\034\ufffc\035\ufffc\040\ufffc\041\ufffc\045\ufffc\051" +
    "\ufffc\071\ufffc\106\ufffc\140\ufffc\143\ufffc\144\ufffc\152\ufffc" +
    "\156\ufffc\001\002\000\042\003\u0136\016\uff59\022\uff59\034" +
    "\uff59\035\uff59\040\uff59\041\uff59\045\uff59\051\uff59\071\uff59" +
    "\106\uff59\140\uff59\143\uff59\144\uff59\152\uff59\156\uff59\001" +
    "\002\000\044\003\ufffc\016\ufffc\022\ufffc\031\uff43\034\ufffc" +
    "\035\ufffc\040\ufffc\041\ufffc\045\ufffc\051\ufffc\071\ufffc\106" +
    "\ufffc\140\ufffc\143\ufffc\144\ufffc\152\ufffc\156\ufffc\001\002" +
    "\000\042\003\u0136\016\uff59\022\uff59\034\uff59\035\uff59\040" +
    "\uff59\041\uff59\045\uff59\051\uff59\071\uff59\106\uff59\140\uff59" +
    "\143\uff59\144\uff59\152\uff59\156\uff59\001\002\000\050\003" +
    "\uff5d\016\uff5d\022\uff5d\027\uff5d\030\uff5d\031\uff5d\034\uff5d" +
    "\035\uff5d\040\uff5d\041\uff5d\045\uff5d\051\uff5d\071\uff5d\106" +
    "\uff5d\140\uff5d\143\uff5d\144\uff5d\152\uff5d\156\uff5d\001\002" +
    "\000\010\027\ufffb\030\ufffb\031\uff44\001\002\000\034\005" +
    "\073\047\101\050\065\051\106\113\063\117\062\120\074" +
    "\152\022\153\102\154\077\155\103\156\024\157\064\001" +
    "\002\000\004\101\u0181\001\002\000\010\045\uff42\101\uff42" +
    "\124\uff42\001\002\000\042\003\ufffc\016\ufffc\022\ufffc\034" +
    "\ufffc\035\ufffc\040\ufffc\041\ufffc\045\ufffc\051\ufffc\071\ufffc" +
    "\106\ufffc\140\ufffc\143\ufffc\144\ufffc\152\ufffc\156\ufffc\001" +
    "\002\000\042\003\u0136\016\uff59\022\uff59\034\uff59\035\uff59" +
    "\040\uff59\041\uff59\045\uff59\051\uff59\071\uff59\106\uff59\140" +
    "\uff59\143\uff59\144\uff59\152\uff59\156\uff59\001\002\000\050" +
    "\003\ufffc\016\ufffc\022\ufffc\027\uff46\030\uff46\031\uff46\034" +
    "\ufffc\035\ufffc\040\ufffc\041\ufffc\045\ufffc\051\ufffc\071\ufffc" +
    "\106\ufffc\140\ufffc\143\ufffc\144\ufffc\152\ufffc\156\ufffc\001" +
    "\002\000\004\031\u018c\001\002\000\006\027\u0178\030\u0186" +
    "\001\002\000\034\005\ufffc\047\ufffc\050\ufffc\051\ufffc\113" +
    "\ufffc\117\ufffc\120\ufffc\152\ufffc\153\ufffc\154\ufffc\155\ufffc" +
    "\156\ufffc\157\ufffc\001\002\000\034\005\073\047\101\050" +
    "\065\051\106\113\063\117\062\120\074\152\022\153\102" +
    "\154\077\155\103\156\024\157\064\001\002\000\004\101" +
    "\u0189\001\002\000\042\003\ufffc\016\ufffc\022\ufffc\034\ufffc" +
    "\035\ufffc\040\ufffc\041\ufffc\045\ufffc\051\ufffc\071\ufffc\106" +
    "\ufffc\140\ufffc\143\ufffc\144\ufffc\152\ufffc\156\ufffc\001\002" +
    "\000\042\003\u0136\016\uff59\022\uff59\034\uff59\035\uff59\040" +
    "\uff59\041\uff59\045\uff59\051\uff59\071\uff59\106\uff59\140\uff59" +
    "\143\uff59\144\uff59\152\uff59\156\uff59\001\002\000\050\003" +
    "\ufffc\016\ufffc\022\ufffc\027\uff45\030\uff45\031\uff45\034\ufffc" +
    "\035\ufffc\040\ufffc\041\ufffc\045\ufffc\051\ufffc\071\ufffc\106" +
    "\ufffc\140\ufffc\143\ufffc\144\ufffc\152\ufffc\156\ufffc\001\002" +
    "\000\004\041\u018d\001\002\000\004\124\u018e\001\002\000" +
    "\050\003\uff47\016\uff47\022\uff47\027\uff47\030\uff47\031\uff47" +
    "\034\uff47\035\uff47\040\uff47\041\uff47\045\uff47\051\uff47\071" +
    "\uff47\106\uff47\140\uff47\143\uff47\144\uff47\152\uff47\156\uff47" +
    "\001\002\000\004\041\u0190\001\002\000\004\124\u0191\001" +
    "\002\000\050\003\uff48\016\uff48\022\uff48\027\uff48\030\uff48" +
    "\031\uff48\034\uff48\035\uff48\040\uff48\041\uff48\045\uff48\051" +
    "\uff48\071\uff48\106\uff48\140\uff48\143\uff48\144\uff48\152\uff48" +
    "\156\uff48\001\002\000\042\003\uff38\016\uff38\022\uff38\034" +
    "\uff38\035\uff38\040\uff38\041\uff38\045\uff38\051\uff38\071\uff38" +
    "\106\uff38\140\uff38\143\uff38\144\uff38\152\uff38\156\uff38\001" +
    "\002\000\042\003\u0136\016\uff59\022\uff59\034\uff59\035\uff59" +
    "\040\uff59\041\uff59\045\uff59\051\uff59\071\uff59\106\uff59\140" +
    "\uff59\143\uff59\144\uff59\152\uff59\156\uff59\001\002\000\044" +
    "\003\ufffc\016\ufffc\022\ufffc\031\u0195\034\ufffc\035\ufffc\040" +
    "\ufffc\041\ufffc\045\ufffc\051\ufffc\071\ufffc\106\ufffc\140\ufffc" +
    "\143\ufffc\144\ufffc\152\ufffc\156\ufffc\001\002\000\004\124" +
    "\u0196\001\002\000\050\003\uff37\016\uff37\022\uff37\027\uff37" +
    "\030\uff37\031\uff37\034\uff37\035\uff37\040\uff37\041\uff37\045" +
    "\uff37\051\uff37\071\uff37\106\uff37\140\uff37\143\uff37\144\uff37" +
    "\152\uff37\156\uff37\001\002\000\004\045\u0199\001\002\000" +
    "\004\124\u019e\001\002\000\042\003\uff3e\016\uff3e\022\uff3e" +
    "\034\uff3e\035\uff3e\040\uff3e\041\uff3e\045\uff3e\051\uff3e\071" +
    "\uff3e\106\uff3e\140\uff3e\143\uff3e\144\uff3e\152\uff3e\156\uff3e" +
    "\001\002\000\042\003\u0136\016\uff59\022\uff59\034\uff59\035" +
    "\uff59\040\uff59\041\uff59\045\uff59\051\uff59\071\uff59\106\uff59" +
    "\140\uff59\143\uff59\144\uff59\152\uff59\156\uff59\001\002\000" +
    "\044\003\ufffc\016\ufffc\022\ufffc\031\u019c\034\ufffc\035\ufffc" +
    "\040\ufffc\041\ufffc\045\ufffc\051\ufffc\071\ufffc\106\ufffc\140" +
    "\ufffc\143\ufffc\144\ufffc\152\ufffc\156\ufffc\001\002\000\004" +
    "\045\u019d\001\002\000\006\124\uff3d\152\uff3d\001\002\000" +
    "\050\003\uff41\016\uff41\022\uff41\027\uff41\030\uff41\031\uff41" +
    "\034\uff41\035\uff41\040\uff41\041\uff41\045\uff41\051\uff41\071" +
    "\uff41\106\uff41\140\uff41\143\uff41\144\uff41\152\uff41\156\uff41" +
    "\001\002\000\050\003\ufffd\016\ufffd\022\ufffd\027\ufffd\030" +
    "\ufffd\031\ufffd\034\ufffd\035\ufffd\040\ufffd\041\ufffd\045\ufffd" +
    "\051\ufffd\071\ufffd\106\ufffd\140\ufffd\143\ufffd\144\ufffd\152" +
    "\ufffd\156\ufffd\001\002\000\050\003\uff40\016\uff40\022\uff40" +
    "\027\uff40\030\uff40\031\uff40\034\uff40\035\uff40\040\uff40\041" +
    "\uff40\045\uff40\051\uff40\071\uff40\106\uff40\140\uff40\143\uff40" +
    "\144\uff40\152\uff40\156\uff40\001\002\000\004\124\u01a3\001" +
    "\002\000\034\005\073\047\101\050\065\051\106\113\063" +
    "\117\062\120\074\152\022\153\102\154\077\155\103\156" +
    "\024\157\064\001\002\000\050\003\uff0f\016\uff0f\022\uff0f" +
    "\027\uff0f\030\uff0f\031\uff0f\034\uff0f\035\uff0f\040\uff0f\041" +
    "\uff0f\045\uff0f\051\uff0f\071\uff0f\106\uff0f\140\uff0f\143\uff0f" +
    "\144\uff0f\152\uff0f\156\uff0f\001\002\000\004\101\u01a5\001" +
    "\002\000\042\003\uff4a\016\uff4a\022\uff4a\034\uff4a\035\uff4a" +
    "\040\uff4a\041\uff4a\045\uff4a\051\uff4a\071\uff4a\106\uff4a\140" +
    "\uff4a\143\uff4a\144\uff4a\152\uff4a\156\uff4a\001\002\000\042" +
    "\003\ufffc\016\ufffc\022\ufffc\034\ufffc\035\ufffc\040\ufffc\041" +
    "\ufffc\045\ufffc\051\ufffc\071\ufffc\106\ufffc\140\ufffc\143\ufffc" +
    "\144\ufffc\152\ufffc\156\ufffc\001\002\000\042\003\u0136\016" +
    "\uff59\022\uff59\034\uff59\035\uff59\040\uff59\041\uff59\045\uff59" +
    "\051\uff59\071\uff59\106\uff59\140\uff59\143\uff59\144\uff59\152" +
    "\uff59\156\uff59\001\002\000\050\003\ufffc\016\ufffc\022\ufffc" +
    "\027\uff49\030\uff49\031\uff49\034\ufffc\035\ufffc\040\ufffc\041" +
    "\ufffc\045\ufffc\051\ufffc\071\ufffc\106\ufffc\140\ufffc\143\ufffc" +
    "\144\ufffc\152\ufffc\156\ufffc\001\002\000\050\003\uff2d\016" +
    "\uff2d\022\uff2d\027\uff2d\030\uff2d\031\uff2d\034\uff2d\035\uff2d" +
    "\040\uff2d\041\uff2d\045\uff2d\051\uff2d\071\uff2d\106\uff2d\140" +
    "\uff2d\143\uff2d\144\uff2d\152\uff2d\156\uff2d\001\002\000\004" +
    "\124\u01ab\001\002\000\050\003\uff2c\016\uff2c\022\uff2c\027" +
    "\uff2c\030\uff2c\031\uff2c\034\uff2c\035\uff2c\040\uff2c\041\uff2c" +
    "\045\uff2c\051\uff2c\071\uff2c\106\uff2c\140\uff2c\143\uff2c\144" +
    "\uff2c\152\uff2c\156\uff2c\001\002\000\034\005\073\047\101" +
    "\050\065\051\106\113\063\117\062\120\074\152\022\153" +
    "\102\154\077\155\103\156\024\157\064\001\002\000\004" +
    "\045\uff39\001\002\000\010\113\113\122\110\124\u01af\001" +
    "\002\000\050\003\uff2b\016\uff2b\022\uff2b\027\uff2b\030\uff2b" +
    "\031\uff2b\034\uff2b\035\uff2b\040\uff2b\041\uff2b\045\uff2b\051" +
    "\uff2b\071\uff2b\106\uff2b\140\uff2b\143\uff2b\144\uff2b\152\uff2b" +
    "\156\uff2b\001\002\000\014\016\uff34\022\u0152\035\u0150\045" +
    "\uff3c\106\u013e\001\002\000\004\045\ufffc\001\002\000\004" +
    "\016\u01b3\001\002\000\042\003\uff36\016\uff36\022\uff36\034" +
    "\uff36\035\uff36\040\uff36\041\uff36\045\uff36\051\uff36\071\uff36" +
    "\106\uff36\140\uff36\143\uff36\144\uff36\152\uff36\156\uff36\001" +
    "\002\000\042\003\u0136\016\uff59\022\uff59\034\uff59\035\uff59" +
    "\040\uff59\041\uff59\045\uff59\051\uff59\071\uff59\106\uff59\140" +
    "\uff59\143\uff59\144\uff59\152\uff59\156\uff59\001\002\000\044" +
    "\003\ufffc\016\ufffc\022\ufffc\031\u01b6\034\ufffc\035\ufffc\040" +
    "\ufffc\041\ufffc\045\ufffc\051\ufffc\071\ufffc\106\ufffc\140\ufffc" +
    "\143\ufffc\144\ufffc\152\ufffc\156\ufffc\001\002\000\004\152" +
    "\022\001\002\000\004\124\u01b8\001\002\000\050\003\uff35" +
    "\016\uff35\022\uff35\027\uff35\030\uff35\031\uff35\034\uff35\035" +
    "\uff35\040\uff35\041\uff35\045\uff35\051\uff35\071\uff35\106\uff35" +
    "\140\uff35\143\uff35\144\uff35\152\uff35\156\uff35\001\002\000" +
    "\004\045\u0199\001\002\000\004\152\022\001\002\000\004" +
    "\124\u01bc\001\002\000\050\003\uff3f\016\uff3f\022\uff3f\027" +
    "\uff3f\030\uff3f\031\uff3f\034\uff3f\035\uff3f\040\uff3f\041\uff3f" +
    "\045\uff3f\051\uff3f\071\uff3f\106\uff3f\140\uff3f\143\uff3f\144" +
    "\uff3f\152\uff3f\156\uff3f\001\002\000\006\105\u01c0\124\uff2f" +
    "\001\002\000\012\105\uff30\113\113\122\110\124\uff30\001" +
    "\002\000\004\124\u01c3\001\002\000\034\005\ufffc\047\ufffc" +
    "\050\ufffc\051\ufffc\113\ufffc\117\ufffc\120\ufffc\152\ufffc\153" +
    "\ufffc\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001\002\000\034" +
    "\005\073\047\101\050\065\051\106\113\063\117\062\120" +
    "\074\152\022\153\102\154\077\155\103\156\024\157\064" +
    "\001\002\000\004\124\uff2e\001\002\000\050\003\uff32\016" +
    "\uff32\022\uff32\027\uff32\030\uff32\031\uff32\034\uff32\035\uff32" +
    "\040\uff32\041\uff32\045\uff32\051\uff32\071\uff32\106\uff32\140" +
    "\uff32\143\uff32\144\uff32\152\uff32\156\uff32\001\002\000\010" +
    "\124\uff12\152\022\156\024\001\002\000\004\124\uff11\001" +
    "\002\000\004\124\u01c7\001\002\000\022\002\uff14\003\uff14" +
    "\016\uff14\036\uff14\061\uff14\075\uff14\102\uff14\152\uff14\001" +
    "\002\000\022\002\ufffd\003\ufffd\016\ufffd\036\ufffd\061\ufffd" +
    "\075\ufffd\102\ufffd\152\ufffd\001\002\000\022\002\uff13\003" +
    "\uff13\016\uff13\036\uff13\061\uff13\075\uff13\102\uff13\152\uff13" +
    "\001\002\000\010\043\u01cb\113\027\124\uff1f\001\002\000" +
    "\020\003\uff27\016\uff27\036\uff27\061\uff27\075\uff27\102\uff27" +
    "\152\uff27\001\002\000\006\043\u01ce\124\uff1e\001\002\000" +
    "\004\124\uff29\001\002\000\020\003\uff26\016\uff26\036\uff26" +
    "\061\uff26\075\uff26\102\uff26\152\uff26\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u01cc\000\022\002\012\136\011\137\014\140\005\150" +
    "\003\155\006\156\010\157\015\001\001\000\002\001\001" +
    "\000\004\011\u01c9\001\001\000\006\053\327\054\330\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\136\011" +
    "\137\014\140\005\150\003\157\326\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\011\020\141\017\142\022" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\143\024\144\025\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\011\030\012\031" +
    "\145\027\146\032\001\001\000\004\174\317\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\011\307\001\001\000\004\147\037\001\001\000\002\001" +
    "\001\000\002\001\001\000\024\007\050\010\052\011\047" +
    "\025\044\026\040\056\041\057\045\142\051\153\046\001" +
    "\001\000\002\001\001\000\014\027\150\031\152\032\056" +
    "\034\057\154\110\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\017\304\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\027\302\001\001\000\010\031\054\032\056" +
    "\034\057\001\001\000\002\001\001\000\040\011\047\056" +
    "\106\057\045\060\077\061\066\074\300\075\075\076\070" +
    "\077\067\100\074\103\104\105\103\106\065\142\051\153" +
    "\046\001\001\000\002\001\001\000\002\001\001\000\040" +
    "\011\047\056\106\057\045\060\077\061\066\074\071\075" +
    "\075\076\070\077\067\100\074\103\104\105\103\106\065" +
    "\142\051\153\046\001\001\000\002\001\001\000\070\011" +
    "\047\030\222\050\225\051\221\056\223\057\045\060\077" +
    "\061\066\062\220\063\226\064\276\065\123\066\114\067" +
    "\124\070\113\071\121\072\116\074\230\075\075\076\070" +
    "\077\067\100\074\103\104\105\103\106\065\142\051\153" +
    "\046\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\104" +
    "\264\001\001\000\006\027\275\033\274\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\102" +
    "\260\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\011\047\056\271\057\045\142\051\153\046\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\034" +
    "\011\047\056\106\057\045\060\077\061\066\075\255\076" +
    "\070\077\067\100\074\105\103\106\065\142\051\153\046" +
    "\001\001\000\002\001\001\000\004\154\110\001\001\000" +
    "\006\011\253\142\254\001\001\000\002\001\001\000\004" +
    "\061\216\001\001\000\062\011\115\013\120\014\125\056" +
    "\106\057\045\060\077\061\066\064\117\065\123\066\114" +
    "\067\124\070\113\071\121\072\116\074\126\075\075\076" +
    "\070\077\067\100\074\103\104\105\103\106\065\142\051" +
    "\153\046\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\073\133" +
    "\101\131\001\001\000\002\001\001\000\002\001\001\000" +
    "\040\011\047\056\106\057\045\060\077\061\066\074\154" +
    "\075\075\076\070\077\067\100\074\103\104\105\103\106" +
    "\065\142\051\153\046\001\001\000\002\001\001\000\052" +
    "\007\050\010\052\011\047\025\144\026\040\030\142\056" +
    "\143\057\045\060\077\061\066\074\145\075\075\076\070" +
    "\077\067\100\074\103\104\105\103\106\065\142\051\153" +
    "\046\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\014\027\150\031\152\032\056" +
    "\034\057\154\110\001\001\000\002\001\001\000\002\001" +
    "\001\000\040\011\047\056\106\057\045\060\077\061\066" +
    "\074\147\075\075\076\070\077\067\100\074\103\104\105" +
    "\103\106\065\142\051\153\046\001\001\000\002\001\001" +
    "\000\002\001\001\000\042\011\047\030\153\056\106\057" +
    "\045\060\077\061\066\074\145\075\075\076\070\077\067" +
    "\100\074\103\104\105\103\106\065\142\051\153\046\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\042\011\047\056\106\057\045\060\077\061\066\072" +
    "\156\074\126\075\075\076\070\077\067\100\074\103\104" +
    "\105\103\106\065\142\051\153\046\001\001\000\002\001" +
    "\001\000\004\004\160\001\001\000\042\011\047\056\106" +
    "\057\045\060\077\061\066\072\161\074\126\075\075\076" +
    "\070\077\067\100\074\103\104\105\103\106\065\142\051" +
    "\153\046\001\001\000\002\001\001\000\004\004\163\001" +
    "\001\000\042\011\047\056\106\057\045\060\077\061\066" +
    "\072\164\074\126\075\075\076\070\077\067\100\074\103" +
    "\104\105\103\106\065\142\051\153\046\001\001\000\002" +
    "\001\001\000\060\011\115\014\167\056\106\057\045\060" +
    "\077\061\066\064\117\065\123\066\114\067\124\070\113" +
    "\071\121\072\116\074\126\075\075\076\070\077\067\100" +
    "\074\103\104\105\103\106\065\142\051\153\046\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\004\204\001" +
    "\001\000\004\004\202\001\001\000\004\004\200\001\001" +
    "\000\042\011\047\056\106\057\045\060\077\061\066\072" +
    "\177\074\126\075\075\076\070\077\067\100\074\103\104" +
    "\105\103\106\065\142\051\153\046\001\001\000\004\004" +
    "\175\001\001\000\042\011\047\056\106\057\045\060\077" +
    "\061\066\072\176\074\126\075\075\076\070\077\067\100" +
    "\074\103\104\105\103\106\065\142\051\153\046\001\001" +
    "\000\002\001\001\000\002\001\001\000\042\011\047\056" +
    "\106\057\045\060\077\061\066\072\201\074\126\075\075" +
    "\076\070\077\067\100\074\103\104\105\103\106\065\142" +
    "\051\153\046\001\001\000\002\001\001\000\042\011\047" +
    "\056\106\057\045\060\077\061\066\072\203\074\126\075" +
    "\075\076\070\077\067\100\074\103\104\105\103\106\065" +
    "\142\051\153\046\001\001\000\002\001\001\000\042\011" +
    "\047\056\106\057\045\060\077\061\066\072\205\074\126" +
    "\075\075\076\070\077\067\100\074\103\104\105\103\106" +
    "\065\142\051\153\046\001\001\000\002\001\001\000\056" +
    "\011\047\056\106\057\045\060\077\061\066\064\207\065" +
    "\123\066\114\067\124\070\113\071\121\072\116\074\126" +
    "\075\075\076\070\077\067\100\074\103\104\105\103\106" +
    "\065\142\051\153\046\001\001\000\002\001\001\000\004" +
    "\004\211\001\001\000\042\011\047\056\106\057\045\060" +
    "\077\061\066\072\212\074\126\075\075\076\070\077\067" +
    "\100\074\103\104\105\103\106\065\142\051\153\046\001" +
    "\001\000\002\001\001\000\004\004\214\001\001\000\042" +
    "\011\047\056\106\057\045\060\077\061\066\072\215\074" +
    "\126\075\075\076\070\077\067\100\074\103\104\105\103" +
    "\106\065\142\051\153\046\001\001\000\002\001\001\000" +
    "\002\001\001\000\070\011\047\030\222\050\225\051\221" +
    "\056\223\057\045\060\077\061\066\062\220\063\226\064" +
    "\224\065\123\066\114\067\124\070\113\071\121\072\116" +
    "\074\230\075\075\076\070\077\067\100\074\103\104\105" +
    "\103\106\065\142\051\153\046\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\027\243\154" +
    "\110\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\073\133\101\131\001" +
    "\001\000\066\011\047\030\222\050\225\051\232\056\223" +
    "\057\045\060\077\061\066\063\234\064\233\065\123\066" +
    "\114\067\124\070\113\071\121\072\116\074\230\075\075" +
    "\076\070\077\067\100\074\103\104\105\103\106\065\142" +
    "\051\153\046\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\056\011\047\056\106\057\045\060" +
    "\077\061\066\064\241\065\123\066\114\067\124\070\113" +
    "\071\121\072\116\074\126\075\075\076\070\077\067\100" +
    "\074\103\104\105\103\106\065\142\051\153\046\001\001" +
    "\000\044\011\047\030\222\050\237\056\223\057\045\060" +
    "\077\061\066\074\240\075\075\076\070\077\067\100\074" +
    "\103\104\105\103\106\065\142\051\153\046\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\056\011\047\056\106\057" +
    "\045\060\077\061\066\064\245\065\123\066\114\067\124" +
    "\070\113\071\121\072\116\074\126\075\075\076\070\077" +
    "\067\100\074\103\104\105\103\106\065\142\051\153\046" +
    "\001\001\000\002\001\001\000\002\001\001\000\066\011" +
    "\047\030\222\050\225\051\232\056\223\057\045\060\077" +
    "\061\066\063\251\064\233\065\123\066\114\067\124\070" +
    "\113\071\121\072\116\074\230\075\075\076\070\077\067" +
    "\100\074\103\104\105\103\106\065\142\051\153\046\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\102\260\001" +
    "\001\000\002\001\001\000\002\001\001\000\032\011\047" +
    "\056\106\057\045\060\077\061\066\076\262\077\067\100" +
    "\074\105\103\106\065\142\051\153\046\001\001\000\002" +
    "\001\001\000\004\104\264\001\001\000\002\001\001\000" +
    "\030\011\047\056\106\057\045\060\077\061\066\077\270" +
    "\100\074\105\103\106\065\142\051\153\046\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\154\110\001\001\000\026\011\047\056" +
    "\106\057\045\060\077\061\066\100\273\105\103\106\065" +
    "\142\051\153\046\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\027\275\033\301\001\001\000\002\001\001\000" +
    "\002\001\001\000\056\011\047\056\106\057\045\060\077" +
    "\061\066\064\305\065\123\066\114\067\124\070\113\071" +
    "\121\072\116\074\126\075\075\076\070\077\067\100\074" +
    "\103\104\105\103\106\065\142\051\153\046\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\011\315\001\001\000\004\147\312\001" +
    "\001\000\024\007\050\010\052\011\047\025\313\026\040" +
    "\056\041\057\045\142\051\153\046\001\001\000\004\017" +
    "\314\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\011\030\012\031\146\321\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\024\007\050\010\052" +
    "\011\047\025\323\026\040\056\041\057\045\142\051\153" +
    "\046\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\034\011" +
    "\334\012\343\015\332\016\333\020\331\021\341\024\340" +
    "\052\345\055\336\136\344\137\014\140\005\150\346\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\011\u0125\001\001\000\002\001" +
    "\001\000\004\011\361\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\006\351" +
    "\001\001\000\002\001\001\000\024\007\050\010\052\011" +
    "\047\025\352\026\040\056\041\057\045\142\051\153\046" +
    "\001\001\000\004\017\353\001\001\000\002\001\001\000" +
    "\002\001\001\000\056\011\047\056\106\057\045\060\077" +
    "\061\066\064\356\065\123\066\114\067\124\070\113\071" +
    "\121\072\116\074\126\075\075\076\070\077\067\100\074" +
    "\103\104\105\103\106\065\142\051\153\046\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\022\362\043\364\001\001\000\002\001\001\000\012\011" +
    "\367\012\370\044\366\045\365\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\024\007\050\010\052\011\047\025\372" +
    "\026\040\056\041\057\045\142\051\153\046\001\001\000" +
    "\004\017\373\001\001\000\002\001\001\000\024\007\050" +
    "\010\052\011\047\025\375\026\040\056\041\057\045\142" +
    "\051\153\046\001\001\000\004\017\376\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\011\367\012\370\045" +
    "\u0101\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\161\u0104\001\001\000\006\023\u0106\036\u0107\001\001\000" +
    "\004\162\u0109\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\037\u010b\040\u010a\001\001\000" +
    "\014\011\367\012\370\042\u0115\045\u0114\164\u0112\001\001" +
    "\000\004\163\u010f\001\001\000\004\165\u010d\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\041\u0119\046\u0118\001" +
    "\001\000\002\001\001\000\004\166\u0116\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\014\011\047\056\u011b\057\045" +
    "\142\051\153\046\001\001\000\004\154\110\001\001\000" +
    "\004\047\u011d\001\001\000\002\001\001\000\046\011\047" +
    "\030\222\050\225\051\u0122\056\223\057\045\060\077\061" +
    "\066\074\240\075\075\076\070\077\067\100\074\103\104" +
    "\105\103\106\065\142\051\153\046\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\037\u0124\040\u010a\001\001\000\002\001\001\000" +
    "\002\001\001\000\024\007\050\010\052\011\047\025\u0127" +
    "\026\040\056\041\057\045\142\051\153\046\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\006\u012b\001\001" +
    "\000\002\001\001\000\024\007\050\010\052\011\047\025" +
    "\u012c\026\040\056\041\057\045\142\051\153\046\001\001" +
    "\000\004\017\u012d\001\001\000\002\001\001\000\002\001" +
    "\001\000\056\011\047\056\106\057\045\060\077\061\066" +
    "\064\u0130\065\123\066\114\067\124\070\113\071\121\072" +
    "\116\074\126\075\075\076\070\077\067\100\074\103\104" +
    "\105\103\106\065\142\051\153\046\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\175\u0133\001\001\000\010" +
    "\107\u0134\110\u0137\111\u0136\001\001\000\004\004\u017a\001" +
    "\001\000\002\001\001\000\056\011\u013a\056\u0155\057\045" +
    "\105\u014e\112\u0152\113\u0142\114\u0144\115\u013e\116\u0140\117" +
    "\u013b\123\u014b\124\u0147\126\u0148\127\u0143\130\u0149\131\u014d" +
    "\134\u0153\135\u014a\142\051\152\u0146\153\046\160\u0139\001" +
    "\001\000\002\001\001\000\016\011\047\056\u01bd\057\045" +
    "\132\u01bc\142\051\153\046\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\014\011\047\056\u01ad" +
    "\057\045\142\051\153\046\001\001\000\004\004\u01ab\001" +
    "\001\000\002\001\001\000\056\011\047\056\106\057\045" +
    "\060\077\061\066\064\u01a9\065\123\066\114\067\124\070" +
    "\113\071\121\072\116\074\126\075\075\076\070\077\067" +
    "\100\074\103\104\105\103\106\065\142\051\153\046\001" +
    "\001\000\002\001\001\000\060\011\047\056\106\057\045" +
    "\060\077\061\066\064\u017f\065\123\066\114\067\124\070" +
    "\113\071\121\072\116\074\126\075\075\076\070\077\067" +
    "\100\074\103\104\105\103\106\065\122\u01a3\142\051\153" +
    "\046\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\154\u01a0\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\004\u0196\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\005\u0175\121\u0174\001\001\000" +
    "\004\011\u0172\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\011\u0164\001\001\000\002\001\001\000\006\053" +
    "\u0162\054\330\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\154\110\001\001\000\056\011" +
    "\047\056\106\057\045\060\077\061\066\064\u0158\065\123" +
    "\066\114\067\124\070\113\071\121\072\116\074\126\075" +
    "\075\076\070\077\067\100\074\103\104\105\103\106\065" +
    "\142\051\153\046\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\014\011\u015c\056\u015b\057\u015d" +
    "\142\051\153\046\001\001\000\004\154\110\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\046\010\u0169" +
    "\011\047\030\u0167\035\u0168\056\u016b\057\045\060\077\061" +
    "\066\074\145\075\075\076\070\077\067\100\074\103\104" +
    "\105\103\106\065\142\051\153\046\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\004\u0170\001\001\000\006" +
    "\027\275\033\u016f\001\001\000\046\010\u0169\011\047\030" +
    "\u0167\035\u016d\056\u016b\057\045\060\077\061\066\074\145" +
    "\075\075\076\070\077\067\100\074\103\104\105\103\106" +
    "\065\142\051\153\046\001\001\000\010\027\275\033\u016c" +
    "\154\110\001\001\000\002\001\001\000\004\004\u016e\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\004\u0176\001\001\000\004\120\u017c" +
    "\001\001\000\004\004\u0178\001\001\000\010\107\u0179\110" +
    "\u0137\111\u0136\001\001\000\004\004\u017a\001\001\000\006" +
    "\110\u017b\111\u0136\001\001\000\002\001\001\000\006\005" +
    "\u0184\121\u0183\001\001\000\060\011\047\056\106\057\045" +
    "\060\077\061\066\064\u017f\065\123\066\114\067\124\070" +
    "\113\071\121\072\116\074\126\075\075\076\070\077\067" +
    "\100\074\103\104\105\103\106\065\122\u017e\142\051\153" +
    "\046\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\004\u0181\001\001\000\010\107\u0182\110\u0137\111\u0136\001" +
    "\001\000\004\004\u017a\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\004\u0186\001\001\000\060\011\047\056" +
    "\106\057\045\060\077\061\066\064\u017f\065\123\066\114" +
    "\067\124\070\113\071\121\072\116\074\126\075\075\076" +
    "\070\077\067\100\074\103\104\105\103\106\065\122\u0187" +
    "\142\051\153\046\001\001\000\002\001\001\000\004\004" +
    "\u0189\001\001\000\010\107\u018a\110\u0137\111\u0136\001\001" +
    "\000\004\004\u017a\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\172\u0192\001\001\000\010\107" +
    "\u0193\110\u0137\111\u0136\001\001\000\004\004\u017a\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\125\u0197\001" +
    "\001\000\002\001\001\000\004\171\u0199\001\001\000\010" +
    "\107\u019a\110\u0137\111\u0136\001\001\000\004\004\u017a\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\170\u019e" +
    "\001\001\000\004\003\u019f\001\001\000\002\001\001\000" +
    "\002\001\001\000\062\011\115\013\120\014\125\056\106" +
    "\057\045\060\077\061\066\064\117\065\123\066\114\067" +
    "\124\070\113\071\121\072\116\074\126\075\075\076\070" +
    "\077\067\100\074\103\104\105\103\106\065\142\051\153" +
    "\046\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\167\u01a5\001\001\000\004\004\u01a6\001\001\000\010\107" +
    "\u01a7\110\u0137\111\u0136\001\001\000\004\004\u017a\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\060\011\047\056\106\057\045\060\077\061\066\064\u017f" +
    "\065\123\066\114\067\124\070\113\071\121\072\116\074" +
    "\126\075\075\076\070\077\067\100\074\103\104\105\103" +
    "\106\065\122\u01ac\142\051\153\046\001\001\000\002\001" +
    "\001\000\004\154\110\001\001\000\002\001\001\000\006" +
    "\126\u01b0\130\u01b1\001\001\000\004\004\u01b8\001\001\000" +
    "\002\001\001\000\004\173\u01b3\001\001\000\010\107\u01b4" +
    "\110\u0137\111\u0136\001\001\000\004\004\u017a\001\001\000" +
    "\004\011\u01b6\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\125\u01b9\001\001\000\004\011\u01ba\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\133\u01be\001\001" +
    "\000\004\154\110\001\001\000\002\001\001\000\004\004" +
    "\u01c0\001\001\000\060\011\047\056\106\057\045\060\077" +
    "\061\066\064\u017f\065\123\066\114\067\124\070\113\071" +
    "\121\072\116\074\126\075\075\076\070\077\067\100\074" +
    "\103\104\105\103\106\065\122\u01c1\142\051\153\046\001" +
    "\001\000\002\001\001\000\002\001\001\000\012\011\020" +
    "\141\u01c4\142\022\151\u01c5\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\176\u01c7\001\001\000\004\003\u01c8" +
    "\001\001\000\002\001\001\000\006\143\u01cb\144\u01cc\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$semantic$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$semantic$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$semantic$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    /**Lista donde se guardan los errores encontrados*/
    public ArrayList<String> errores=new ArrayList<String>();
    /**Método para devolver tanto los errores del parser como los  del lexer, si los hay*/
    public ArrayList<String> getErrores(){
		if(getScanner() instanceof Ada95Lexer){
			errores.addAll(((Ada95Lexer)getScanner()).lexical_errors);		
		}
		return errores;

	}
    /**Método que devuelve las advertencias, hasta esta versión, sólo el lexer tiene advertencias...*/
    public ArrayList<String> getAdvertencias(){
	ArrayList<String> warnings=new ArrayList<String>();
	if(getScanner() instanceof Ada95Lexer){
		warnings.addAll(((Ada95Lexer)getScanner()).lexical_warnings);		
	}
	return warnings;
		
    }
    boolean EOFReported=false;
    Stack<String> unClosed=new Stack<String>();
    public String getUnclosed(){return unClosed.pop();}
    public void setUnclosed(String faltante,String abierto, int line, int col){
	String addToUnClosed="'"+faltante+"'"+" faltante para el '"+abierto+"' abierto en línea "+(line+1)+", columna "+(col+1);
	unClosed.push(addToUnClosed);

    }
    public void emptyLastUnclosed(){String tempUnClosed=unClosed.pop();tempUnClosed=null;}
    	
    /**Guardar los errores en un stringBuffer*/
    //StringBuffer errorMessages=new StringBuffer();
    /* Change the method report_error so it will display the line and
       column of where the error occurred in the input as well as the
       reason for the error which is passed into the method in the
       String 'message'. */
    public void report_error(String message, Object info) {
   	
	/*If the EOF was already reported, just return (to avoid that horrible unexpected EOF...)*/
	if(EOFReported)
		return;
        /* Create a StringBuffer called 'm' with the string 'Error' in it. */
        StringBuffer m = new StringBuffer();
        /* Add to the end of the StringBuffer error message created in
           this method the message that was passed into this method. */
	if(message.equalsIgnoreCase("Syntax error")){
		message="Error Sintáctico  ";
	}else if(message.equalsIgnoreCase("Couldn't repair and continue parse")){
		message="Error ";
	}	
        m.append(message);
   
        /* Check if the information passed to the method is the same
           type as the type java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {
            /* Declare a java_cup.runtime.Symbol object 's' with the
               information in the object info that is being typecasted
               as a java_cup.runtime.Symbol object. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            /* Check if the line number in the input is greater or
               equal to zero. */
            if (s.left >= 0) {                
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(": en línea "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0) {                   
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", columna "+(s.right+1));
		   //ver si se puede sacar el texto:
		   if(getScanner() instanceof Ada95Lexer){
			m.append("; no se esperaba '"+((Ada95Lexer)getScanner()).getCurrentText()+"'");
		   }
		}
	///guardar el error en la variable de errores:
            }else if(s.toString().equals("#0")){
			if(unClosed.empty()){				
				m.append(": final de archivo inesperado");
			}else{
				m.append(": "+getUnclosed());
				EOFReported=true;
			}

		}

        }
   
   
        /* Print the contents of the StringBuffer 'm', which contains
           an error message, out on a line. */
        //System.err.println(m);
	errores.add(m.toString());
	/*Guardar el error en el buffer, mas un salto de línea:*/
	//	errorMessages.append(m+"\n");
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);

        //System.exit(1);
    }
 /**La función que guarda errores para luego ser impresos por el front-end
*@param line, column la línea y columna del error/
public void push_error(int line, int column){
	errores.add(new String(String.valueOf(line)+"_"+String.valueOf(column)));
	System.out.println(errores);
}*/


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$semantic$actions {



/**The current symbol table*/
LinkedSymbolTable currentScope = null; 
/**Variables globales para el control de los subprogramas*/
ArrayList<Type> returns=new ArrayList<Type>();
int branches=0;
/*Variables para la generación de código intermedio*/
//las instrucciones
ArrayList<Cuadruplo> cuadruplos=new ArrayList<Cuadruplo>();
public static final int MIPS_TEMPS=9;
//los temporales cf: http://en.wikipedia.org/wiki/MIPS_architecture
boolean[] temps=new boolean[MIPS_TEMPS];
int temp_provisorio=0;
/**Para obtener el siguiente temporal libre*/
public String temp_nuevo(){
	return "$t"+String.valueOf(++temp_provisorio);
}
/**La lista de saltos de salida en el loop actual (sólo funciona para salidas inmediatas)*/
ListaSalto currentExit=null;
/**Ir imprimiendo el código intermedio al generarlo*/
public boolean DEBUG=true;
/*Para agregar cuádruplos a la lista. Sólo generar el cuádruplo si no hay errores.*/
public void gen(Object op, Object arg1, Object arg2, Object res){
	//si hay errores y no estamos debugueando, ni siquiera molestarse en seguir:
	if(!DEBUG && parser.errores.size()>0)
		return;
	/*castear a string*/
	String o=op.toString();
	String a1=arg1.toString();
	String a2=arg2.toString();
	String r=res.toString();
	//pasar los argumentos a lowercase, para no tener problemas luego con la st.
	a1=a1.toLowerCase();
	a2=a2.toLowerCase();
	Cuadruplo quad=new Cuadruplo(o, a1, a2, r);
	cuadruplos.add(quad);	
	if(DEBUG){
		System.out.println((cuadruplos.size()-1)+"    "+quad.toString());
	}	
}

/**Función que devuelve el String que representa a un branch de código intermedio*/
public String getIf(Object operador){
	String o=operador.toString();
	return "if_"+o;
}

/**Convierte una literal booleana en un número*/
public Integer getNumeric(Boolean val){
	int rv= (val.booleanValue()) ? 1 : 0;
        return new Integer(rv);
}
/**Devuelve la lista de saltos de un valor booleano*/
public BackPatchResult getBackPatch(Boolean b){
	BackPatchResult rval=new BackPatchResult();
	if(b.booleanValue()){
		rval.verdadera=new ListaSalto(cuadruplos.size());
		return rval;
	}else{
		rval.falsa=new ListaSalto(cuadruplos.size());
		return rval;
	}
}

/**Dada una lista de saltos completa los correspondientes cuádruplos con el salto proveido*/
public void completa(ListaSalto completar, Object con){
	if(completar.lista.isEmpty())
		return;
	int value=0;
	String salto=con.toString();
	for(Integer index : completar.lista){
		//por cualquier cosa
		value=index.intValue();
		if(value < cuadruplos.size() && value >=0){
			cuadruplos.get(value).res=salto;
		}else if(DEBUG){
			System.err.println("Se trató de asignar un salto a un cuádruplo inválido; "+
			index+ ". Hay "+cuadruplos.size()+"  cuádruplos");
		}
	}
}

/**Genera código para la asignación, recibe un ParserResult que corresponde a la expresión
   si la expresión tiene backpatch, y éste tiene una listaVerdadera o listaFalsa vacías, 
   genera además el código para completarlas y darles valor
*/
public void generar_asignacion(ParserResult expression, Object result){	
	//esto nunca debería pasar, pero bueno...
		if(expression.backpatch == null){
			gen(":=", expression.value, "", result);
			return;
		}
	//todo depende, en realidad, del tipo de la expression: (ya que todas tienen sus listaV y listaF)
		if(expression.type instanceof BooleanType){
			completa(expression.backpatch.verdadera, cuadruplos.size());
			gen(":=", "1", "", result);
			gen("goto", "", "",cuadruplos.size()+1);
			completa(expression.backpatch.falsa, cuadruplos.size());
			gen(":=", "0", "", result);
		}else{
			gen(":=", expression.value, "", result);
		}
}

 /**Esta función chequea que un subprograma que tiene nombre al principio y final tenga exactamente el mismo nombre
   * @param start la palabra del inicio
     @param sline, scolumn el left y right del símbolo start
     @param end la palabra del final
     @param eline, ecolumn el left y right del símbolo end
 */

 public void check_coherence(Object start, int sline, int scolumn, Object end, int eline, int ecolumn){
	 String s=(String)start;
	 String sInfo="inicio: "+s+" ["+String.valueOf(sline+1)+" , "+String.valueOf((scolumn-s.length()))+"]";
	//la funciones pueden no tener el del final:
	 if(end==null){return;}
	 String e=(String)end;
	 String eInfo=" y fin: "+e+" ["+String.valueOf(eline+1)+" , "+String.valueOf(ecolumn+1)+"]";
	 //ver si son lo mismo:
	if(!s.equals(e)){
		//System.err.println("Error sintáctico  : el nombre del subprograma debe coincidir entre "+sInfo+eInfo);
		parser.errores.add("Error sintáctico  : el nombre del subprograma debe coincidir entre "+sInfo+eInfo);
	}
	

 }
/**Método para comprobar errores semánticos de tipo. Los agrega también a la lista de errores. Se vale del método equals de las clases
   que heredan de Type.
   @param expected el tipo esperado
   @param found el tipo encontrado
   @param foundLine, foundColumn, etc la línea y columna donde se encuentra la declaración.
*/
public boolean compare_types(Object expected, Object found, int foundLine, int foundColumn){
	Type etipo=(Type)expected;
	Type ftipo=(Type)found;
	Type e=(etipo instanceof FunctionType)? (((FunctionType)etipo).getRange()) : etipo;
	Type f=(ftipo instanceof FunctionType)? (((FunctionType)ftipo).getRange()) : ftipo;
	if(! e.equals(f)){
		StringBuffer errorMessage=new StringBuffer();
		errorMessage.append("Se esperaba el tipo "+e.toString());
		errorMessage.append(" Y se encontró "+f.toString());
		errorMessage.append(" En línea "+String.valueOf(foundLine+1)+", columna "+String.valueOf(foundColumn+1));
		parser.errores.add(errorMessage.toString());
		return false;		
	}
	return true;
}
/**Método para determinar si un símbolo está o no declarado*/
public AdaSymbol findSymbol(Object id, int line, int column){
	AdaSymbol found;
	found=currentScope.get(id);
	if(found == null){
		parser.errores.add(" No se encuentra el símbolo '"+(String)id+"'. En línea "+(String.valueOf(line+1))+", columna "+String.valueOf(column+1));
		return null;
	}
	return found;
	
}
/*Agrega un error a los errores del parser*/
public void agregarError(String mensaje, int linea, int columna){
	parser.errores.add(mensaje+". En línea "+String.valueOf(linea+1)+", columna "+String.valueOf(columna+1));
}

public boolean validateBuiltIn(String method, Object val, int line, int col){
	if(method.equalsIgnoreCase("put") || method.equalsIgnoreCase("get")){
	//the value must be an arraylist of Parser Results:
		if(!(val instanceof ArrayList))
			return false;
	//if it is, cast:
		ArrayList<ParserResult> l=(ArrayList<ParserResult>)val;
	//now, check that it has only one parameter:
		if(l.size()!=1){
			agregarError("La función '"+method+"' solamente admite 1 parámetro, "+String.valueOf(l.size())+" suministrados", line, col);
			return false;
		}
	//it has, so, check that the type is valid: it must be one of the primitive types:
		return l.get(0).type.isPrimitive();
		
	}	

	
	//invalid method:
	return false;
}


  private final semantic parser;

  /** Constructor */
  CUP$semantic$actions(semantic parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$semantic$do_action(
    int                        CUP$semantic$act_num,
    java_cup.runtime.lr_parser CUP$semantic$parser,
    java.util.Stack            CUP$semantic$stack,
    int                        CUP$semantic$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$semantic$result;

      /* select the action based on the action number */
      switch (CUP$semantic$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 254: // code_statement ::= qualified_expression SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("code_statement",110, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 253: // compilation_unit ::= subprogram_body 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_unit",109, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 252: // compilation_unit ::= subprogram_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_unit",109, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 251: // compilation_list ::= error 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_list",108, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 250: // compilation_list ::= compilation_list compilation_unit 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_list",108, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 249: // compilation_list ::= compilation_unit 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation_list",108, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 248: // compilation ::= compilation_list 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compilation",107, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 247: // actual_parameter_part ::= LEFTPAR argument_list RIGHTPAR 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT=a;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("actual_parameter_part",106, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 246: // function_call ::= name actual_parameter_part 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					ParserResult pn=(ParserResult)n;
					AdaSymbol f=findSymbol(pn.value, nleft, nright);
					if(f==null)
						RESULT=new ParserResult(pn.value);
					else{
						if(!(f.type instanceof FunctionType)){
							agregarError("'"+((String)pn.value)+"' no es una función", nleft, nright);
							RESULT=new ParserResult(pn.value);
						}else{//la función existe: 
						//ver si está llamado con el número correcto de parámetros:
							if(!(f.type.getProduct().size()==((ArrayList<ParserResult>)p).size())){
								agregarError("La función '"+((String)pn.value)+
								"' recibe "+(f.type.getProduct().size())+" parámetros. "+
								String.valueOf(((ArrayList<ParserResult>)p).size())
								+" suministrados", nleft, nright);
								RESULT=new ParserResult(pn.value);	
							}else{//el número de parámetros es correcto, vamos a ver si son iguales:
								int i=0;
								ArrayList<ParserResult> pr=(ArrayList<ParserResult>)p;
								Type found;Type expected;			
								for(;i<f.type.getProduct().size();i++){
									found=pr.get(i).type;
									expected=f.type.getProduct().get(i);		
									if(!expected.equals(found)){
										agregarError("Argumento incorrecto para la función '"+((String)pn.value)+"'"+
										" encontrado '"+found.toString()+"', se esperaba '"+expected.toString()+"'",
										nleft, nright);
										break;			
									}
								}//si termina, el tipo de los parámetros es correcto
								if(i==f.type.getProduct().size()){
									//generar, entonces, el código:
									for(ParserResult res: pr){
										gen("param", res.value, "", "");
									}	
									String lugar=temp_nuevo();
									gen("call", pn.value, pr.size(), lugar);					
									RESULT=new ParserResult(pn.value, f.type, lugar);
								}else{
									RESULT=new ParserResult(pn.value);
								}
								
							}//el número de parámetros es correcto 
								
						}//es una función
					}//se encontró el id
					//create a new dummy function to compare it with this.
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("function_call",105, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 245: // function_call ::= name LEFTPAR RIGHTPAR 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
			
						ParserResult pn=(ParserResult)n;
						AdaSymbol f=findSymbol(pn.value, nleft, nright);	
					        if (f==null)
							RESULT=new ParserResult(pn.value);
					  	else{//found, check if the function complies...
						//check if it IS a function:
							if(!(f.type instanceof FunctionType)){
								agregarError("'"+((String)pn.value)+"' no es una función", nleft, nright);
								RESULT=new ParserResult(pn.value);
						//check if it is an empty parameter function:
							}else if(!f.type.getProduct().isEmpty()){
								agregarError("La función '"+((String)pn.value)+
								"' recibe "+(f.type.getProduct().size())+" parámetros. O suministrados", nleft, nright);
								RESULT=new ParserResult(pn.value);
						//if it is a function with empty parameters, but no return type, is a procedure!
							}else if(((FunctionType)f.type).getRange() == null){
								agregarError("No se puede usar una llamada a procedimiento como operando", nleft, nright);
								RESULT=new ParserResult(pn.value);
						//it IS a function (i.e it HAS return type:)
							}else{
								//it's safe to generate the code, then:
								String lugar=temp_nuevo();
								gen("call", pn.value, "0", lugar);							
								RESULT=new ParserResult(pn.value, f.type, lugar);
							}
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("function_call",105, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 244: // procedure_call ::= GET LEFTPAR selected_component RIGHTPAR SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		
					  AdaSymbol f=findSymbol(i, ileft, iright);
					  if(f!=null){
						if(!f.type.isPrimitive()){
							agregarError("La función 'get' sólo acepta parámetros con tipos primitivos (boolean"+
							"float o integer)", ileft, iright);
						}else{
							String tipo=f.type.getClass().getSimpleName();
							String lugar=i.toString();
							gen("get", tipo.split("Type")[0], "", lugar);
						}
					
					  }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("procedure_call",104, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 243: // procedure_call ::= GET LEFTPAR identifier RIGHTPAR SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		
					  AdaSymbol f=findSymbol(i, ileft, iright);
					  if(f!=null){
						if(!f.type.isPrimitive()){
							agregarError("La función 'get' sólo acepta parámetros con tipos primitivos (boolean"+
							"float o integer)", ileft, iright);
						}else{
							String tipo=f.type.getClass().getSimpleName();
							String lugar=i.toString();
							gen("get", tipo.split("Type")[0], "", lugar);
						}
					
					  }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("procedure_call",104, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 242: // procedure_call ::= PUT actual_parameter_part SEMICOLON 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		//ver si cumple con: sólo un parámetro, el tipo es o String, int, float o boolean
						boolean v=validateBuiltIn("PUT", p, pleft, pright);						
						if(v){
							//assume it has only one element:
							ParserResult uP=((ArrayList<ParserResult>)p).get(0);
							String lugar=temp_nuevo();
							String tipo=uP.type.getClass().getSimpleName();
							gen("put", 
								tipo.split("Type")[0],
								uP.value,
								"");
							RESULT=new ParserResult("put", uP.type, lugar);
						}
						
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("procedure_call",104, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 241: // procedure_call ::= name SEMICOLON 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					/*si no está clean, alguien ya se hizo cargo de ella:
					entonces, sólo hacer la llamada si aún no ha pasado por function_call
					*/
					ParserResult pn=(ParserResult)n;
					AdaSymbol f=findSymbol(pn.value, nleft, nright);
					if(f != null){
						if(pn.clean){
						//Se tiene que haber declarado como función
							if(!(f.type instanceof FunctionType)){
								agregarError("'"+((String)pn.value)+"' no es un procedimiento", nleft, nright);
						//no tiene que tener parámetros
							}else if(!f.type.getProduct().isEmpty()){
								agregarError("El procedimiento'"+((String)pn.value)+
								"' recibe "+(f.type.getProduct().size())+" parámetros. O suministrados", nleft, nright);
						//ni tipo de retorno
							}else if(((FunctionType)f.type).getRange() != null){
								agregarError("'"+((String)pn.value)+"' no es un procedimiento", nleft, nright);
						//SI es un procedimiento como debería:
							}else{
								gen("call", pn.value, "0", "");	
							}
						
						}else{//si no está limpio, es un nombre normal, pero debe ser función, eh!
							if(!(f.type instanceof FunctionType)){
								agregarError("'"+((String)pn.value)+"' no es un procedimiento", nleft, nright);
							}
						}
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("procedure_call",104, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 240: // designator_option ::= designator 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=d;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("designator_option",103, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 239: // designator_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("designator_option",103, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 238: // subprogram_body ::= subprogram_specification_is declarative_part BEGIN NT$12 sequence_of_statements END designator_option SEMICOLON NT$13 placeholder 
            {
              Object RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-9)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-9)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-9)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-7)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		Object designator=(s instanceof ParserResult) ? ((ParserResult)s).value : s;
					check_coherence(designator,sleft, sright, e, eleft, eright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_body",102, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-9)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 237: // NT$13 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-7)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;

					  if(s != null){
						if(s instanceof ParserResult){
							ParserResult ps=(ParserResult)s;
							for(Type r : returns){
								//si es errortype, ya fue reportado un error
								if(!(r instanceof ErrorType))
									compare_types(ps.type,r,sleft, sright);
							}

							//se asume que sólo las funciones tienen branches
							if (returns.size() < branches)
								agregarError("Sentencia de retorno faltante para el subprograma '"+((String)ps.value)+"'"
								, sleft, sright);
						}else{//si no es un ParserResult es un procedure:
							if(returns.size()>0)	
								agregarError("Un procedimiento no puede retornar un valor"+
								" (En el procedimiento '"+((String)s)+"') ", sleft, sright);
						}
					  }
					  //completar la sequence of statements: así todas tienen un salto
					  ParserResult tr=(ParserResult)t;
					  completa(tr.backpatch.siguiente, cuadruplos.size());
					//generar la salida:
					Object designator=(s instanceof ParserResult) ? ((ParserResult)s).value : s;
					String id=designator.toString();
					if(currentScope.getAncestor() == null)
						gen("glblExit", "", "", "");
					else
						gen("exit",id, "", "");
					  //resetear las cosas: el main no debería desaparecer!
					if(currentScope.getAncestor() != null)
						  currentScope=currentScope.getAncestor();
					  returns=new ArrayList<Type>();
					  branches=0;
				  	 //Revisar que no venga un exit_statement
					  if(currentExit != null )	
						  agregarError("No puede salir de un subprograma con una sentencia de salida", sleft, sright);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$13",124, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 236: // NT$12 ::= 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
Object designator=(s instanceof ParserResult) ? ((ParserResult)s).value : s;
					parser.setUnclosed((" end "+((String)designator)+";"), "begin",bleft, bright);
					//crear el código para inicializar la función
					gen("initFunction", designator.toString(), String.valueOf(currentScope.desplazamiento), "");
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$12",123, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 235: // mode ::= IN OUT 
            {
              Object RESULT =null;
		RESULT="INOUT";
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("mode",101, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 234: // mode ::= OUT 
            {
              Object RESULT =null;
		RESULT="OUT";
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("mode",101, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 233: // mode ::= IN 
            {
              Object RESULT =null;
		RESULT="IN";
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("mode",101, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 232: // mode ::= 
            {
              Object RESULT =null;
		RESULT="IN";
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("mode",101, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 231: // parameter_declaration ::= identifier_list COLON mode subtype_indication initialization_option 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					
					ParserResult ps=(ParserResult)s;
                                	//if the type is null, there was an error down the tree (and is already reported)
	                                if (ps.type != null){
					ArrayList<String> il=(ArrayList<String>)l;
					ArrayList<ParserResult> r=new ArrayList<ParserResult>();
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
							String nombre="";
							String mode=(String)m;
							if(o != null){
								ParserResult po=(ParserResult)o;
								boolean compare;
								if(!mode.equalsIgnoreCase("in")){
									agregarError("Los parámetros '"+il.toString()+"' no son de tipo 'in'"+
									", no pueden ser inicializados", oleft, oright);
									compare=false;	
								}else{
									compare=compare_types(ps.type, po.type, oleft, oright);
								}
								//Type tipo=compare ? ps.type : new ErrorType(ps.type);
								Type tipo=ps.type;
								for(String id :il){									
									nombre=(mode.equalsIgnoreCase("in")) ? id+"$constant" : id;
									if(compare){
										generar_asignacion(po, id);
									}
									r.add(new ParserResult(nombre, tipo));
								}
								RESULT=r;
							}else{//there's no initialization expression:
								for(String id: il){
									nombre=(mode.equalsIgnoreCase("in")) ? id+"$constant" : id;
									r.add(new ParserResult(nombre, ps.type));
								}
								RESULT=r;
							}
						}else{
							for(String id: il)
								r.add(new ParserResult(id));
							RESULT=r;
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
						}
                	                }else{
						RESULT=null;
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("parameter_declaration",100, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 230: // parameter_declaration ::= identifier COLON mode subtype_indication initialization_option 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					ParserResult ps=(ParserResult)s;
					String mode=(String)m;
                                	//if the type is null, there was an error down the tree (and is already reported)
	                                if (ps.type != null){
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
							String nombre=(mode.equalsIgnoreCase("in")) ? ((String)i)+"$constant" : (String)i;
							if(o != null){
								ParserResult po=(ParserResult)o;
								if(mode.equalsIgnoreCase("in")){
									if(compare_types(ps.type, po.type, oleft, oright)){
										//todo está bien, generar el código
										generar_asignacion(po, i);
									}
								}else{//solo los in pueden estar inicializados:
									agregarError("El parámetro '"+i.toString()+"' no es de tipo 'in'"+
									", no puede ser inicializado", oleft, oright);
								}
								//Type tipo=compare ? ps.type : new ErrorType(ps.type);
								Type tipo=ps.type;
								ParserResult r=new ParserResult(nombre, tipo);
								RESULT=r;
							}else{//there's no initialization expression:
								RESULT=new ParserResult(nombre, ps.type);
							}
						}else{
							RESULT=new ParserResult(i);
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);							     }
                	                }else{
						RESULT=null;
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("parameter_declaration",100, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 229: // parameter_declaration_list ::= parameter_declaration_list SEMICOLON parameter_declaration 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(l != null){
						ArrayList<ParserResult> ll=(ArrayList<ParserResult>)l;
						//puede venir un solo elemento o una lista:
						if(d != null){
							if(!(d instanceof ArrayList)){
								ll.add((ParserResult)d);
							}else{
								ll.addAll((ArrayList<ParserResult>)d);
							}
						}
						RESULT=ll;
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("parameter_declaration_list",99, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 228: // parameter_declaration_list ::= parameter_declaration 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(d != null){
						ArrayList<ParserResult> r=new ArrayList<ParserResult>();
					if (!(d instanceof ArrayList)){
						//asumimos que, si no es una lista, es un parser result
						r.add((ParserResult)d);
						RESULT=r;
					}else{
						RESULT=r;
					}
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("parameter_declaration_list",99, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 227: // formal_part_option ::= formal_part 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=f;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("formal_part_option",98, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // formal_part_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("formal_part_option",98, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // formal_part ::= LEFTPAR parameter_declaration_list NT$11 RIGHTPAR 
            {
              Object RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("formal_part",97, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // NT$11 ::= 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
RESULT=l;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$11",122, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // operator_symbol ::= STRING_LITERAL 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(s, new StringType(((String)s).length()));
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("operator_symbol",96, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // designator ::= operator_symbol 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=o;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("designator",95, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // designator ::= identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=i;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("designator",95, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // subprogram_specification_is ::= FUNCTION designator formal_part_option RETURN subtype_indication IS 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					String id=i.toString().toLowerCase();
					//es una función, así que al menos espera una branch:
					branches=1;
					ParserResult ps=(ParserResult)s;
					if(ps.type != null){
					if(f != null){
						
						ArrayList<ParserResult> fl=(ArrayList<ParserResult>)f;
						ArrayList<Type> ft=new ArrayList<Type>();
						for (ParserResult p:fl)
							ft.add(p.type);							
						if(ps.type != null){
							if((currentScope != null) && !currentScope.put(i, new AdaSymbol(new FunctionType(ps.type, ft)))){
								agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
							}else{
								if(currentScope != null){
									LinkedSymbolTable scope=new LinkedSymbolTable(currentScope, id);
									currentScope.addChild(scope);
									currentScope=scope;		
									gen("function", id, "", "");	
								}else{
									currentScope=new LinkedSymbolTable(id);
									gen("glbl", id, "", "");
								}
								String nombre="";
								boolean cons=false;
								for(ParserResult p: fl){
									nombre=((String)p.value).split("\\$")[0];
									cons=((String)p.value).contains("$constant");
									//las funciones sólo pueden tener parámetros de tipo in:
									if(!cons){
										agregarError("Las funciones sólo pueden tener parámetros de modo in",
										fleft, fright );
										cons=true;
									}
									if(!currentScope.put(nombre, new AdaSymbol(p.type, cons))){
										agregarError("'"+nombre+"' ya ha sido declarado", fleft, fright);
									}
								}
							}
						}
						
					}else{
						if((currentScope != null) && !currentScope.put(i, new AdaSymbol(new FunctionType(ps.type))))
							agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
						else{	
							if(currentScope != null){
								LinkedSymbolTable scope=new LinkedSymbolTable(currentScope, id);
								currentScope.addChild(scope);
								currentScope=scope;		
								gen("function", id, "", "");	
							}else{
								currentScope=new LinkedSymbolTable(id);
								gen("glbl", id, "", "");
							}
						}
						
					}
					
 					RESULT=new ParserResult(i,ps.type);
					}else{
					 RESULT=i;
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification_is",94, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // subprogram_specification_is ::= PROCEDURE identifier formal_part IS 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					  String id=i.toString().toLowerCase();
					  //formal part es una lista de parser results:
					  if( f!= null){											  	
						ArrayList<ParserResult> fl=(ArrayList<ParserResult>)f;
						ArrayList<Type> ft=new ArrayList<Type>();
						for (ParserResult p:fl)
							ft.add(p.type);
						
						if((currentScope != null) && !currentScope.put(i, new AdaSymbol(new FunctionType(ft)))){
							agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
						}else{
							if(currentScope != null){
								LinkedSymbolTable scope=new LinkedSymbolTable(currentScope, id);
								currentScope.addChild(scope);
								currentScope=scope;
								gen("function", id, "", "");
							}else{
								currentScope=new LinkedSymbolTable(id);
								gen("glbl", id, "", "");
							}
							String nombre="";
							boolean cons=false;
							for(ParserResult p: fl){
								nombre=((String)p.value).split("\\$")[0];
								cons=((String)p.value).contains("$constant");
								if(!currentScope.put(nombre, new AdaSymbol(p.type, cons))){
									agregarError("'"+nombre+"' ya ha sido declarado", fleft, fright);
								}
							}
						}
					    
					  }
					
					RESULT=i;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification_is",94, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // subprogram_specification_is ::= PROCEDURE identifier IS 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					String id=i.toString().toLowerCase();
                                         if(currentScope != null){
                                                if(!currentScope.put(i, new AdaSymbol(new FunctionType()))){
                                                        agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
                                                }else{
							LinkedSymbolTable scope=new LinkedSymbolTable(currentScope, id);
							currentScope.addChild(scope);
							currentScope=scope;
							gen("function", id, "", "");
						}

                                         }else{
                                          currentScope=new LinkedSymbolTable(id);
                                          boolean neverused=currentScope.put("put", new AdaSymbol(new IntegerType()));
                                          boolean neveruser2=currentScope.put("get", new AdaSymbol(new IntegerType()));
					  gen("glbl", id, "", ""); //glbl genera las cosas iniciales. Pero todas las vars van en regs...
                                         }

                                          RESULT=i;
                                        
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification_is",94, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // subprogram_specification ::= FUNCTION designator formal_part_option RETURN subtype_indication 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
						ParserResult ps=(ParserResult)s;
						if(f != null){//si la formal part está correcta:
							/*Si los nombres de los parámetros me importaran: */
							//ArrayList<ParserResult> pf=(ArrayList<ParserResult>)f;
							//sólo me importan los types?
							//LinkedSymbolTable ft=(LinkedSymbolTable)f;	 
							ArrayList<ParserResult> fl=(ArrayList<ParserResult>)f;
							ArrayList<Type> ft=new ArrayList<Type>();
							for (ParserResult p:fl)
								ft.add(p.type);							
							if(ps.type != null){
								if(!currentScope.put(d, new AdaSymbol(new FunctionType(ps.type, ft))))
									agregarError("'"+((String)d)+"' ya ha sido declarado.", dleft, dright);
							}
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification",93, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // subprogram_specification ::= PROCEDURE identifier formal_part_option 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
						if(f != null){
							ArrayList<ParserResult> fl=(ArrayList<ParserResult>)f;
							ArrayList<Type> ft=new ArrayList<Type>();
							for (ParserResult p:fl)
								ft.add(p.type);
							if(!currentScope.put(i, new AdaSymbol(new FunctionType(ft))))
								agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_specification",93, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // subprogram_declaration ::= subprogram_specification SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subprogram_declaration",92, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // goto_statement ::= GOTO name SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("goto_statement",91, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // return_statement ::= RETURN expression SEMICOLON 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
						ParserResult pe=(ParserResult)e;
						gen("return", pe.value, "", "");
						gen("goto", "", "", "exit_"+currentScope.id);
						RESULT=e;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("return_statement",90, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // return_statement ::= RETURN SEMICOLON 
            {
              Object RESULT =null;
		
						gen("goto", "", "", "exit_"+currentScope.id);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("return_statement",90, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // when_option ::= WHEN m condition 
            {
              Object RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType)){
							agregarError("Se esperaba un tipo booleano y se encontró"+pc.type.toString(), cleft, cright);
						}else{
							ParserResult res=new ParserResult();
							ParserResult mr=(ParserResult)m;
							res.value=mr.value;
							res.backpatch.falsa=pc.backpatch.falsa;
							res.backpatch.verdadera=pc.backpatch.verdadera;
							RESULT=res;

						}
					 }
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("when_option",89, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // when_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("when_option",89, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // name_option ::= name 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=n;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name_option",88, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // name_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name_option",88, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // exit_statement ::= EXIT name_option when_option SEMICOLON 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int wleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int wright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object w = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		if(w != null){
						  ParserResult wr=(ParserResult)w;
						  completa(wr.backpatch.falsa, cuadruplos.size());
						  if(currentExit != null){
							currentExit=ListaSalto.fusiona(currentExit, wr.backpatch.verdadera);
						  }else{
							currentExit=wr.backpatch.verdadera;
						  }
						  if(n != null){
							  ParserResult nr=(ParserResult)n;		
							  RESULT=new ParserResult(nr.value, wr.type, wr.backpatch);
						  }else{
							  RESULT=new ParserResult(wr.type, wr.backpatch);
						  }
					  }else{//there is no condition, but a goto must be generated:
					  ListaSalto verdadero=new ListaSalto(cuadruplos.size());
					  BackPatchResult bpr=new BackPatchResult(verdadero, new ListaSalto()); 
					  gen("goto", "", "", " ");
      						if(n != null){
							ParserResult nr=(ParserResult)n;		
							RESULT=new ParserResult(nr.value, bpr); 
						}else{
							RESULT=new ParserResult(bpr);
						}
					  if(currentExit != null){
						currentExit=ListaSalto.fusiona(currentExit, verdadero);
					  }else{
						currentExit=verdadero;
					  }
					  }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("exit_statement",87, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // declare_part_option ::= DECLARE declarative_part 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declare_part_option",86, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // declare_part_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declare_part_option",86, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // block ::= identifier COLON declare_part_option BEGIN NT$10 sequence_of_statements END identifier SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-8)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("block",85, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-8)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // NT$10 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
parser.setUnclosed((" end "+((String)i)+ ";"), ("begin del bloque "+((String)i)),ileft, iright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$10",121, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // block ::= declare_part_option BEGIN NT$9 sequence_of_statements END SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("block",85, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // NT$9 ::= 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
parser.setUnclosed("end;", "begin del bloque",bleft, bright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$9",120, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // iteration_clause_option ::= WHILE m condition 
            {
              Object RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType)){
							agregarError("Se esperaba un tipo booleano y se encontró"+pc.type.toString(), cleft, cright);
						}else{
							//subir la lista verdadera de la condición para que la llene el loop y el valor
							// de m para completar lo de las sentencias y generar el goto
							ParserResult res=new ParserResult();
							ParserResult mr=(ParserResult)m;
							res.value=mr.value;
							res.backpatch.falsa=pc.backpatch.falsa;
							res.backpatch.verdadera=pc.backpatch.verdadera;
							RESULT=res;
						}
					 }
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",84, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // iteration_clause_option ::= FOR identifier IN REVERSE discrete_range m 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					LinkedSymbolTable scope=new LinkedSymbolTable(currentScope); 
					currentScope.addChild(scope);
					currentScope=scope;
					Type tipo=(r != null) ? ((ParserResult)r).type : new IntegerType();
					if(!currentScope.put(i, new AdaSymbol(tipo, true))){
						agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
					}
					//generar la condición:
					if(r != null){
						ParserResult range=(ParserResult)r;
						Object initial = ((ArrayList<Object>)range.value).get(0);
						Object fin     = ((ArrayList<Object>)range.value).get(1);
						//acá podríamos avisar que el rango es nulo
						// identifier := range_initial
						gen(":=", fin, "", i);	
						//las listas verdadera y falsa:
						BackPatchResult b_res=new BackPatchResult(new ListaSalto(cuadruplos.size()),
                                                                                          new ListaSalto(cuadruplos.size()+1));
						//generarlas instrucciones:
						ArrayList<Object> post=new ArrayList<Object>(2);
						post.add(new Integer(cuadruplos.size()));
						gen("if_>=", i, initial, "");
						gen("goto", " ", "", "");
						ParserResult mr=(ParserResult)m;
						post.add(new Cuadruplo("-", i.toString(), "1", i.toString()));
						RESULT=new ParserResult(post, b_res);
					}	
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",84, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // iteration_clause_option ::= FOR identifier IN discrete_range m 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					LinkedSymbolTable scope=new LinkedSymbolTable(currentScope); 
					currentScope.addChild(scope);
					currentScope=scope;
					//ver si viene algo en el rango:
					Type tipo=(r != null) ? ((ParserResult)r).type : new IntegerType();
					if(!currentScope.put(i, new AdaSymbol(tipo, true))){
						agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);					
					}
					/*
					//avisar si el rango es nulo:
					if(r ==  null)
						agregarError("Advertencia: El rango del ciclo es nulo y no se ejecutará", rleft, rright);
					*/
					if(r != null){
						ParserResult range=(ParserResult)r;
						Object initial = ((ArrayList<Object>)range.value).get(0);
						Object fin     = ((ArrayList<Object>)range.value).get(1);
						//acá podríamos avisar que el rango es nulo
						// identifier := range_initial
						gen(":=", initial, "", i);	
						//las listas verdadera y falsa:
						BackPatchResult b_res=new BackPatchResult(new ListaSalto(cuadruplos.size()),
                                                                                          new ListaSalto(cuadruplos.size()+1));
						//generar las instrucciones:
						ArrayList<Object> post=new ArrayList<Object>(2);
						post.add(new Integer(cuadruplos.size()));
						gen("if_<", i, fin, "");
						gen("goto", " ", "", "");
						ParserResult mr=(ParserResult)m;
						//post.add(mr.value);
						post.add(new Cuadruplo("+", i.toString(), "1", i.toString()));
						RESULT=new ParserResult(post, b_res);
						
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",84, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // iteration_clause_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",84, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // basic_loop ::= LOOP NT$8 sequence_of_statements END LOOP 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		RESULT=s;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("basic_loop",83, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // NT$8 ::= 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
parser.setUnclosed("end loop;", "loop",lleft,lright);
					  currentExit=null;
					 
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$8",119, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // loop_statement ::= identifier COLON iteration_clause_option m basic_loop identifier SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-6)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int jleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object j = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					String si=(String)i; 
					String sj=(String)j;
					if(!si.equalsIgnoreCase(sj))
						agregarError("Se esperaba 'end loop "+si+"' y se encontró 'end loop "+sj+"'", jleft, jright);
					ParserResult mr=(ParserResult)m;
					ParserResult sr=(ParserResult)s;						
					if(o != null && (((ParserResult)o).value instanceof ArrayList)){
						currentScope=currentScope.getAncestor(); 
					  
					/*la iteration clause ya trae las cosas de la condición Y el marcador antes de ésta*/
						ParserResult iteration=(ParserResult)o;
						completa(iteration.backpatch.verdadera, mr.value);
						/*Aquí hay una disyuntiva, o viene una lista o no, si viene
						una, es porque es un for y hay que generarlo*/
						if(iteration.value instanceof ArrayList){
							ArrayList<Object> post=(ArrayList)iteration.value;
							completa(sr.backpatch.siguiente, cuadruplos.size());
							Cuadruplo step=(Cuadruplo)post.get(1);
							gen(step.operador, step.arg1, step.arg2, step.res);
							//genera un goto adonde está la condición:
							gen("goto", "", "", post.get(0));
						}else{//no es una lista, si no un simple m
							completa(sr.backpatch.siguiente, iteration.value);	
							gen("goto", "", "", iteration.value);
						}
						//TODO: cambiar esto para revisar que el value de la e_stmnt sea una etiqueta de este loop.
						//completa(sr.backpatch.falsa, iteration.value);
						RESULT=new ParserResult(
							new BackPatchResult(iteration.backpatch.falsa)
						);				
					}else{
						completa(sr.backpatch.siguiente, mr.value);
						gen("goto", "", "", mr.value);
						//siguiente=sr.backpatch.verdadera;
						RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
						
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("loop_statement",82, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // loop_statement ::= iteration_clause_option m basic_loop SEMICOLON NT$7 placeholder 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		/*la iteration clause ya trae las cosas de la condición Y el marcador antes de ésta*/
						ParserResult mr=(ParserResult)m;
						ParserResult sr=(ParserResult)s;
						ListaSalto siguiente;
						if(o != null){
							ParserResult iteration=(ParserResult)o;
							completa(iteration.backpatch.verdadera, mr.value);						
							if(iteration.value instanceof ArrayList){
								ArrayList<Object> post=(ArrayList)iteration.value;
								completa(sr.backpatch.siguiente, cuadruplos.size());
								Cuadruplo step=(Cuadruplo)post.get(1);
								gen(step.operador, step.arg1, step.arg2, step.res);
								//genera un goto adonde está la condición:
								gen("goto", "", "", post.get(0));
							}else{//no es una lista, si no un simple m
								completa(sr.backpatch.siguiente, iteration.value);	
								gen("goto","", "", iteration.value);
							}
							/*Completar la sequence_of_staments que podría traer las listas de los exit_staments
							  Verdadera: si se cumple será la siguiente (porque sale)
							  Falsa: completarla con la condición */
							//completa(sr.backpatch.falsa, iteration.value);
							//siguiente=ListaSalto.fusiona(iteration.backpatch.falsa, sr.backpatch.verdadera);
							siguiente=iteration.backpatch.falsa;
						}else{//es un loop normal, sin iteración.
							completa(sr.backpatch.siguiente, mr.value);
							gen("goto", "", "", mr.value);
							//siguiente=sr.backpatch.verdadera;
							siguiente=new ListaSalto();
						}
						RESULT=new ParserResult(
							new BackPatchResult(siguiente)
						);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("loop_statement",82, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // NT$7 ::= 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;

					 //se asume que si la iteration_clause existe, se creó una st para ésta
					 if(o != null && (((ParserResult)o).value instanceof ArrayList))
						currentScope=currentScope.getAncestor(); 
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$7",118, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // condition ::= expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("condition",80, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // else_option ::= n ELSE m sequence_of_statements 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		ParserResult ps=(ParserResult)s;
				  ParserResult mr=(ParserResult)m;
				  ParserResult nr=(ParserResult)n;
				  ps.backpatch.siguiente=ListaSalto.fusiona(ps.backpatch.siguiente, nr.backpatch.siguiente);
				  RESULT=new ParserResult(mr.value, ps.backpatch);
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("else_option",79, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // else_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("else_option",79, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // elsif_list ::= elsif_list n ELSIF m condition THEN m sequence_of_statements 
            {
              Object RESULT =null;
		int elsifleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).left;
		int elsifright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).right;
		Object elsif = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-7)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-6)).value;
		int munoleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int munoright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object muno = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mdosleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mdosright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object mdos = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		 branches++;
					  if(c != null){
						ParserResult pc=(ParserResult)c;
						ParserResult ps=(ParserResult)s;					
						ParserResult pn=(ParserResult)n;
						ParserResult pm1=(ParserResult)muno;
						ParserResult pm2=(ParserResult)mdos;
						ParserResult pelsif=(ParserResult)elsif;

						if(!(pc.type instanceof BooleanType)){
							agregarError("Una condición debe ser de un tipo booleano y se encontró "+pc.type.toString(),
						        cleft, cright);
						}else{
							completa(pc.backpatch.verdadera, pm2.value);
							completa(pelsif.backpatch.falsa, pm1.value);
							RESULT=new ParserResult(
								new BackPatchResult(
									ListaSalto.fusiona(pn.backpatch.siguiente,
										ListaSalto.fusiona(ps.backpatch.siguiente, pelsif.backpatch.siguiente)
									),
									new ListaSalto(),
									pc.backpatch.falsa
								)
							);
						}
					 }
					
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("elsif_list",78, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // elsif_list ::= ELSIF condition THEN m sequence_of_statements 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
						branches++;
						//comprobación:
						if(c != null){
							ParserResult pc=(ParserResult)c;
							ParserResult pm=(ParserResult)m;
							ParserResult ps=(ParserResult)s;
							if(!(pc.type instanceof BooleanType)){
								agregarError("Una condición debe ser de un tipo booleano y se encontró "+pc.type.toString(),
							        cleft, cright);
							}else{
						//backpatching:
							completa(pc.backpatch.verdadera, pm.value);			
							RESULT=new ParserResult(
							 new BackPatchResult(
								ps.backpatch.siguiente,
								new ListaSalto(),
								pc.backpatch.falsa
							 )
							);
							}
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("elsif_list",78, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // if_statement ::= if_header n m elsif_list else_option END IF SEMICOLON 
            {
              Object RESULT =null;
		int headerleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).left;
		int headerright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)).right;
		Object header = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-7)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-6)).value;
		int mdosleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int mdosright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object mdos = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int elsifleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int elsifright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object elsif = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int elsleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int elsright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object els = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		
					 if(header != null){ 
							ParserResult pc=(ParserResult)header;
							ParserResult pm2=(ParserResult)mdos;
							ParserResult pn=(ParserResult)n;
							ParserResult pelsif=(ParserResult)elsif;
							ParserResult pelse=(ParserResult)els;
							BackPatchResult siguiente=new BackPatchResult();
							completa(pc.backpatch.verdadera, pc.value);
							completa(pc.backpatch.falsa, pm2.value);
							siguiente.siguiente=ListaSalto.fusiona(
											ListaSalto.fusiona(pc.backpatch.siguiente,pn.backpatch.siguiente),
											pelsif.backpatch.siguiente
										);	
							if(pelse != null){
								completa(pelsif.backpatch.falsa, pelse.value);
								siguiente.siguiente=ListaSalto.fusiona(siguiente.siguiente, pelse.backpatch.siguiente);
							}else{
								siguiente.siguiente=ListaSalto.fusiona(siguiente.siguiente, pelsif.backpatch.falsa);
							}
							RESULT=new ParserResult(siguiente);
						}else{
							RESULT=new ParserResult(new BackPatchResult());
						}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("if_statement",77, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-7)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // if_statement ::= if_header else_option END IF SEMICOLON 
            {
              Object RESULT =null;
		int headerleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int headerright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object header = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int elsleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int elsright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object els = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		
					if(header != null){
						ParserResult pc=(ParserResult)header;
						ParserResult RetVal=new ParserResult();
						completa(pc.backpatch.verdadera, pc.value);
						RetVal.backpatch.siguiente=ListaSalto.fusiona(pc.backpatch.siguiente, pc.backpatch.falsa);
						if(els != null){
							ParserResult pelse=(ParserResult)els;
							completa(pc.backpatch.falsa, pelse.value);
							RetVal.backpatch.siguiente=ListaSalto.fusiona(pc.backpatch.siguiente,
									           pelse.backpatch.siguiente);
						}
						RESULT=RetVal;
					 }else{
						RESULT=new ParserResult(new BackPatchResult());
					 }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("if_statement",77, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // if_header ::= IF condition THEN NT$6 m sequence_of_statements 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		 branches++;
					 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType)){
							agregarError("Una condición debe ser de un tipo booleano y se encontró "+pc.type.toString(),
							 cleft, cright);
							RESULT=null;
						}else{
							ParserResult pm=(ParserResult)m;
							ParserResult ps=(ParserResult)s;
							RESULT=new ParserResult(pm.value,
										 new BackPatchResult(ps.backpatch.siguiente,
		 	       										 pc.backpatch.verdadera,
													 pc.backpatch.falsa));
						}
					}
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("if_header",81, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // NT$6 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
parser.setUnclosed("end if;", "if", ileft, iright);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$6",117, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // assignment_statement ::= name ASSIGNMENT expression SEMICOLON 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					if(e != null){
						ParserResult pe=(ParserResult)e;
						ParserResult pn=(ParserResult)n;
						//AdaSymbol gn=currentScope.get(pn.value);
						
						if(pn.type != null){
						//get it:
						AdaSymbol gn=currentScope.get(pn.value);
						//if it is a function, a record or a constant, then it's not eligible:
						if(gn.type instanceof FunctionType)
						agregarError("El lado izquierdo de la asignación debe ser una variable, no una función", nleft, nright);
						else if(gn.type instanceof RecordType)						
						agregarError("El lado izquierdo de la asignación debe ser una variable, no un registro", nleft, nright);
						else if(gn.constant)
					agregarError("El lado izquierdo de la asignación debe ser una variable, no un objeto constante", nleft, nright);
						else//si todo sale bien, entonces sí comparar:					
						    if(compare_types(pn.type, pe.type, eleft, eright)){
							//generar el código para la asignación:
							generar_asignacion(pe, pn.value);
						    }
						}
					}
					
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("assignment_statement",76, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // null_statement ::= NULL SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("null_statement",75, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // label ::= LEFTLABEL identifier RIGHTLABEL 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("label",74, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // compound_statement ::= block 
            {
              Object RESULT =null;
		parser.emptyLastUnclosed();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compound_statement",73, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // compound_statement ::= loop_statement 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		parser.emptyLastUnclosed();
						  RESULT=s;
						  //completar el currentExit con la siguiente sentencia:
						  if(currentExit != null){
							completa(currentExit, cuadruplos.size());
							currentExit=null;
						  }
						
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compound_statement",73, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // compound_statement ::= if_statement 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		parser.emptyLastUnclosed(); RESULT=s;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("compound_statement",73, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // simple_statement ::= code_statement 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // simple_statement ::= procedure_call 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
					  
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // simple_statement ::= goto_statement 
            {
              Object RESULT =null;
		int gleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int gright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object g = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // simple_statement ::= return_statement 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(e != null){
						ParserResult pe=(ParserResult)e;
						returns.add(pe.type);
					}else{
						returns.add(new ErrorType());
					}
					RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // simple_statement ::= exit_statement 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // simple_statement ::= assignment_statement 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // simple_statement ::= null_statement 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // label_list ::= label_list label 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("label_list",71, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // label_list ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("label_list",71, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // statement ::= error 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // statement ::= label_list compound_statement 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=c;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // statement ::= label_list simple_statement 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=s;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("statement",70, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // sequence_of_statements ::= sequence_of_statements m statement 
            {
              Object RESULT =null;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
						ParserResult qr=(ParserResult)q;
						ParserResult mr=(ParserResult)m;
						ParserResult sr=(ParserResult)s;
						completa(qr.backpatch.siguiente, mr.value);
						RESULT=new ParserResult(
							new BackPatchResult(sr.backpatch.siguiente)
						);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("sequence_of_statements",69, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // sequence_of_statements ::= statement 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=s;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("sequence_of_statements",69, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // allocator ::= NEW name 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("allocator",68, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // qualified_expression ::= name TICK aggregate 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("qualified_expression",67, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // qualified_expression ::= name TICK LEFTPAR expression RIGHTPAR 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("qualified_expression",67, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // multiplying_operator ::= REM 
            {
              Object RESULT =null;
		RESULT= new ParserResult("rem");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("multiplying_operator",66, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // multiplying_operator ::= MOD 
            {
              Object RESULT =null;
		RESULT= new ParserResult("mod");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("multiplying_operator",66, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // multiplying_operator ::= DIVIDE 
            {
              Object RESULT =null;
		RESULT= new ParserResult("div");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("multiplying_operator",66, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // multiplying_operator ::= MULTIPLY 
            {
              Object RESULT =null;
		RESULT= new ParserResult("mul");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("multiplying_operator",66, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // unary_operator ::= ABS 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult("abs", new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("unary_operator",65, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // unary_operator ::= NOT 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult("not", new BooleanType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("unary_operator",65, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // unary_operator ::= MINUS 
            {
              Object RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult("-", new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("unary_operator",65, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // unary_operator ::= PLUS 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult("+", new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("unary_operator",65, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // adding_operator ::= CONCATENATE 
            {
              Object RESULT =null;
		RESULT= new ParserResult("&");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("adding_operator",64, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // adding_operator ::= MINUS 
            {
              Object RESULT =null;
		RESULT= new ParserResult("sub");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("adding_operator",64, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // adding_operator ::= PLUS 
            {
              Object RESULT =null;
		RESULT=new ParserResult("add");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("adding_operator",64, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // relational_operator ::= LTEQ 
            {
              Object RESULT =null;
		RESULT= new ParserResult("<=");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // relational_operator ::= GTEQ 
            {
              Object RESULT =null;
		RESULT= new ParserResult(">=");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // relational_operator ::= GT 
            {
              Object RESULT =null;
		RESULT= new ParserResult(">");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // relational_operator ::= LT 
            {
              Object RESULT =null;
		RESULT= new ParserResult("<");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // relational_operator ::= INEQUALITY 
            {
              Object RESULT =null;
		RESULT= new ParserResult("/=");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // relational_operator ::= EQUAL 
            {
              Object RESULT =null;
		RESULT= new ParserResult("==");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // primary ::= LEFTPAR expression RIGHTPAR 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // primary ::= qualified_expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // primary ::= allocator 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // primary ::= name 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		ParserResult nr=(ParserResult)n;
					  /***/
					  if(!nr.clean){						
						RESULT=new ParserResult(nr.place, nr.type);
					  }else{
					 	RESULT=n;
					 }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // primary ::= aggregate 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // primary ::= literal 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=l;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // factor ::= primary EXPONENTIATE primary 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								String lugar=temp_nuevo();
								gen("**", pr.value, qr.value, lugar);
								RESULT=new ParserResult(lugar, ptipo);
							}
							else {
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numérico y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo numérico y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("factor",61, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // factor ::= primary 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					   ParserResult pr=(ParserResult)p;
					   if(pr.type != null){
						RESULT=pr;						
					   }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("factor",61, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // term ::= term multiplying_operator factor 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if ((p != null) && (q != null)){
							
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult or=(ParserResult)o;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								String lugar=temp_nuevo();
								gen(or.value, pr.value, qr.value, lugar);
								RESULT=new ParserResult(lugar, ptipo);
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numérico y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo numérico y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					}	
					}	
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("term",60, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // term ::= factor 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(f != null){					  
					   ParserResult pr=(ParserResult)f;
					   if(pr.type != null){
						RESULT=pr;						
					   }
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("term",60, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // term_list ::= term_list adding_operator term 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult or=(ParserResult)o;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								String lugar=temp_nuevo();
								gen(or.value, pr.value, qr.value, lugar);
								RESULT=new ParserResult(lugar, ptipo);
							}else {
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numérico y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo numérico y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("term_list",59, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // term_list ::= term 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(t != null){					  
					   ParserResult pr=(ParserResult)t;
					   if(pr.type != null){
						RESULT=pr;						
					   }
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("term_list",59, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // simple_expression ::= unary_operator term_list 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(t != null){
						ParserResult pt=(ParserResult)t;
					if(pt.type != null){						
					 Type ptipo=(pt.type instanceof FunctionType)? (((FunctionType)pt.type).getRange()) : pt.type;
						ParserResult po=(ParserResult)o;
						Type so=(Type)po.type;						
						if(so.isNumeric()){
							if(ptipo.isNumeric()){
							    String lugar=temp_nuevo();
							    gen(po.value, pt.value, "", lugar);
							    RESULT=new ParserResult(lugar, ptipo);
							}else{								
							    agregarError("Se esperaba un tipo numérico y se encontró "+ptipo.toString(), oleft, oright);
							    RESULT=null;
							}	
						}else{//the operator is boolean! (The 'NOT' operator)
						/**Si la term_list es boolean, TIENE que traer su lista de backpatch*/
							if(ptipo instanceof BooleanType){
							    String lugar=temp_nuevo();
							    gen(po.value, pt.value, "", lugar);	
							    if(pt.backpatch != null){
								RESULT=new ParserResult(lugar, ptipo, 
									   new BackPatchResult(pt.backpatch.falsa, pt.backpatch.verdadera));
							    }else{
								RESULT=new ParserResult(lugar, ptipo);
							    }
							}else{
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), oleft, oright);
							    RESULT=null;
							}
						}						
					}
					}

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_expression",58, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // simple_expression ::= term_list 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if(t != null){					  
					   ParserResult pr=(ParserResult)t;
					   if(pr.type != null){
						RESULT=pr;						
					   }
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("simple_expression",58, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // membership_operator ::= NOT IN 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("membership_operator",57, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // membership_operator ::= IN 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("membership_operator",57, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // relation ::= simple_expression membership_operator subtype_indication 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					  if(p != null){
						ParserResult pr=(ParserResult)p;
						ParserResult ps=(ParserResult)s;
						if ((ps.type != null) && (pr.type != null)){
						 	Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
							if(compare_types(ptipo, ps.type, sleft, sright)){
								RESULT=pr;
							}else{
								RESULT=null;
							}						
						}
					  }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relation",56, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // relation ::= simple_expression membership_operator range 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numérico y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo numérico y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
					 
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relation",56, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // relation ::= simple_expression relational_operator simple_expression 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult po=(ParserResult)o;
					 if((pr.type != null) && (qr.type != null)){
					 //si no son null, vienen buenos:
						BackPatchResult res=new BackPatchResult(new ListaSalto(cuadruplos.size()),
											new ListaSalto(cuadruplos.size()+1));
						gen(getIf(po.value), pr.value, qr.value, " ");
						gen("goto", " ", "", "");
						RESULT=new ParserResult(new BooleanType(), res);
						}
						
					 }
				

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relation",56, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // relation ::= simple_expression 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=s;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("relation",56, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // orelse_expression ::= orelse_expression OR_ELSE m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult pm=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.falsa, pm.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									ListaSalto.fusiona(pr.backpatch.verdadera, qr.backpatch.verdadera),
									qr.backpatch.falsa
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("orelse_expression",55, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // orelse_expression ::= relation OR_ELSE m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.falsa, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									ListaSalto.fusiona(pr.backpatch.verdadera, qr.backpatch.verdadera),
									qr.backpatch.falsa
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(qtipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
						
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("orelse_expression",55, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // andthen_expression ::= andthen_expression AND_THEN m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.verdadera, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									qr.backpatch.verdadera,	
									ListaSalto.fusiona(pr.backpatch.falsa, qr.backpatch.falsa)
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("andthen_expression",54, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // andthen_expression ::= relation AND_THEN m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
				 	 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.verdadera, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									qr.backpatch.verdadera,	
									ListaSalto.fusiona(pr.backpatch.falsa, qr.backpatch.falsa)
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(qtipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}

					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("andthen_expression",54, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // xor_expression ::= xor_expression XOR relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("xor_expression",53, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // xor_expression ::= relation XOR relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright))
								RESULT=pr; //CHANGE THIS!
							else 
								RESULT= null;
						}else{
							//determine who's to blame:
							if(ptipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("xor_expression",53, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // or_expression ::= or_expression OR m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.falsa, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									ListaSalto.fusiona(pr.backpatch.verdadera, qr.backpatch.verdadera),
									qr.backpatch.falsa
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(qtipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("or_expression",52, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // or_expression ::= relation OR m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							if(compare_types(ptipo,qtipo, qleft, qright)){							
								completa(pr.backpatch.falsa, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									ListaSalto.fusiona(pr.backpatch.verdadera, qr.backpatch.verdadera),
									qr.backpatch.falsa
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(qtipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("or_expression",52, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // and_expression ::= and_expression AND m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.verdadera, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									qr.backpatch.verdadera,	
									ListaSalto.fusiona(pr.backpatch.falsa, qr.backpatch.falsa)
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(qtipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("and_expression",51, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // and_expression ::= relation AND m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if((p != null) && (q != null)){
					
					 ParserResult pr=(ParserResult)p;
					 ParserResult qr=(ParserResult)q;
					 ParserResult mr=(ParserResult)m;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if((ptipo instanceof BooleanType) && (qtipo instanceof BooleanType)){
							//comparar los tipos!
							//TODO: make the actual operation! (Have a function that does math operations...)
							if(compare_types(ptipo,qtipo, qleft, qright)){
								completa(pr.backpatch.verdadera, mr.value);
								RESULT=new ParserResult(ptipo, 
								new BackPatchResult(
									qr.backpatch.verdadera,	
									ListaSalto.fusiona(pr.backpatch.falsa, qr.backpatch.falsa)
								));
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(qtipo instanceof BooleanType)
							    agregarError("Se esperaba un tipo booleano y se encontró "+ptipo.toString(), pleft, pright);
							else 
							    agregarError("Se esperaba un tipo booleano y se encontró "+qtipo.toString(), qleft, qright);
							RESULT=null;
						}
						
					 }
				
					}
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("and_expression",51, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // expression ::= orelse_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // expression ::= andthen_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // expression ::= xor_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // expression ::= or_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // expression ::= and_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // expression ::= relation 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // component_association ::= choice_list ARROW expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_association",49, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // component_association ::= expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_association",49, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // component_association_list ::= component_association_list COMMA component_association 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_association_list",48, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // component_association_list ::= component_association COMMA component_association 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_association_list",48, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // aggregate ::= LEFTPAR choice_list ARROW expression RIGHTPAR 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("aggregate",47, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // aggregate ::= LEFTPAR component_association_list RIGHTPAR 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("aggregate",47, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // literal ::= NULL 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT= new ParserResult(n);
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // literal ::= BOOLEAN_LITERAL 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT= new ParserResult(getNumeric(b), new BooleanType(), getBackPatch(b));
					  gen("goto", " ", "", "");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // literal ::= CHARACTER_LITERAL 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT= new ParserResult(c, new StringType(1));
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // literal ::= FLOATING_POINT_LITERAL 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Float f = (Float)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT= new ParserResult(f, new FloatType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // literal ::= INTEGER_LITERAL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=new ParserResult(i, new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // selected_component ::= name POINT operator_symbol 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("selected_component",45, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // selected_component ::= name POINT ALL 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		
					AdaSymbol f=findSymbol(n, nleft, nright);
					if(f != null)
						RESULT=new ParserResult(n, f.type);
					else
						RESULT=new ParserResult(n);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("selected_component",45, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // selected_component ::= name POINT identifier 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					//the selected component query:
						ParserResult namen=(ParserResult)n;
						String valex=((String)namen.value)+"."+((String)i);
						Type t=null;
					//query for it in the current scope:
						AdaSymbol f=currentScope.get(valex);		
						if (f !=null)//found:
							t=f.type;
						else
							parser.errores.add("No se puede encontrar el componente '"+((String)i)+
							"' para el prefijo '"+((String)namen.value)+ "'. En línea "+String.valueOf(nleft+1)+
							", columna "+String.valueOf(nright+1));
						RESULT=new ParserResult(valex, t);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("selected_component",45, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // name ::= operator_symbol 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//buscar el nombre en la tabla de símbolos:					  
					  ParserResult pi=(ParserResult)i;
					  //AdaSymbol f=findSymbol(pi.value, ileft, iright);
					  /*Si no lo encuentra, asumamos que es un string normal...*/
					  AdaSymbol f=currentScope.get(pi.value);					  
					  if(f!= null)
						RESULT=new ParserResult(i, f.type);						 
					  else
						//RESULT=new ParserResult(i);
						RESULT=pi;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // name ::= function_call 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=f;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // name ::= selected_component 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=s;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // name ::= identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//buscar el nombre en la tabla de símbolos:
					  AdaSymbol f=findSymbol(i, ileft, iright);
					  if(f!= null)
						RESULT=new ParserResult(i, f.type);						 
					  else
						RESULT=new ParserResult(i);
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("name",44, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // declarative_item ::= error SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item",43, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // declarative_item ::= subprogram_body 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item",43, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // declarative_item ::= declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item",43, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // declarative_item_list ::= declarative_item_list declarative_item 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item_list",42, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // declarative_item_list ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_item_list",42, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // declarative_part ::= declarative_item_list 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declarative_part",41, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // incomplete_type_declaration ::= TYPE identifier discriminant_part_option SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("incomplete_type_declaration",40, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // choice_list ::= choice_list VERTICAL_LINE choice 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice_list",39, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // choice_list ::= choice 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice_list",39, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // choice ::= range 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice",38, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // choice ::= name range_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice",38, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // choice ::= OTHERS 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice",38, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // choice ::= simple_expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("choice",38, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // variant_list ::= variant_list WHEN choice_list ARROW component_list 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_list",37, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // variant_list ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_list",37, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // variant_part ::= CASE name IS variant_list END CASE SEMICOLON 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_part",36, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // discriminant_declaration ::= identifier_list COLON subtype_indication initialization_option 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					  ParserResult ps=(ParserResult)s;
					  ArrayList<String> il=(ArrayList<String>)l;
					  if(ps.type != null){//si el tipo sí fue encontrado:
						ArrayList<ParserResult> r=new ArrayList<ParserResult>();
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
							if(o != null){//ver si el tipo de o coincide con el de s:
								 ParserResult po=(ParserResult)o;
								 boolean compare=compare_types(ps.type, po.type, oleft, oright);
								 //Type tipo=compare ? ps.type : new ErrorType(ps.type);
								 Type tipo=ps.type;
								 for(String id: il){		
									if(compare){
										generar_asignacion(po, id);
									}				
									r.add(new ParserResult(id, tipo));					
								 }
								 RESULT=r;
							}else{//no hay inicialización:
								 for(String id: il){						
									r.add(new ParserResult(id, ps.type));					
								 }
								 RESULT=r;
							}
						}else{
							for(String id:il){
								r.add(new ParserResult(id));
							}
							RESULT=r;
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
						}
					  }else{
						RESULT=null;
					  }
						
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_declaration",35, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // discriminant_declaration ::= identifier COLON subtype_indication initialization_option 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		//ver si el tipo existe. Si existe, ver si coincide con la inicialización.
					  //si algo malo pasa, devolver null.
					  ParserResult ps=(ParserResult)s;
					  if(ps.type != null){//si el tipo sí fue encontrado:
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)) //si el tipo ES un tipo:
							if(o != null){//ver si el tipo de o coincide con el de s:
								 ParserResult po=(ParserResult)o;
								 if(compare_types(ps.type, po.type, oleft, oright)){
									generar_asignacion(po, i);
								 }
								 //Type tipo=compare ? ps.type : new ErrorType(ps.type);
								 Type tipo=ps.type;
								 RESULT=new ParserResult(i, tipo);
							}else{//no hay inicialización:
								RESULT=new ParserResult(i, ps.type);
							}
						  else{
							RESULT=new ParserResult(i);
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
						  }
					  }else{//el tipo no fue encontrado
						RESULT=null;
					  }
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_declaration",35, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // discriminant_declaration_list ::= discriminant_declaration_list SEMICOLON discriminant_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_declaration_list",34, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // discriminant_declaration_list ::= discriminant_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_declaration_list",34, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // discriminant_part ::= LEFTPAR discriminant_declaration_list RIGHTPAR 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_part",33, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // component_declaration ::= error 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_declaration",32, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // component_declaration ::= discriminant_declaration NT$5 SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_declaration",32, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // NT$5 ::= 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
RESULT=d;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$5",116, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // variant_part_option ::= variant_part 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_part_option",31, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // variant_part_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("variant_part_option",31, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // component_declaration_list ::= component_declaration_list component_declaration 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		LinkedSymbolTable t=(LinkedSymbolTable)l;
					  //the components are parserResults: en el valor viene el nombre.
					//c puede ser una lista o un solo elemento:
					if(c != null){	
					  if(!(c instanceof ArrayList)){
					 	 ParserResult p=(ParserResult)c;
						  if(!t.put(p.value, new AdaSymbol(p.type))){
							agregarError("El componente '"+((String)p.value)+
							"' ya ha sido declarado en este registro.", cleft, cright);
						  }
					  }else{//sí es una lista:
						ArrayList<ParserResult> lc=(ArrayList<ParserResult>)c;
						for(ParserResult p: lc){
						  if(!t.put(p.value, new AdaSymbol(p.type))){
							agregarError("El componente '"+((String)p.value)+
							"' ya ha sido declarado en este registro.", cleft, cright);
						  }//no se pudo meter el id
							
						}//iterar en c
					  }//c es una lista
				
					}//c existe
					//subir la tabla de símbolos:
					RESULT=t;
					
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_declaration_list",30, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // component_declaration_list ::= 
            {
              Object RESULT =null;
		RESULT=new LinkedSymbolTable();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_declaration_list",30, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // component_list ::= NULL NT$4 SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_list",29, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // NT$4 ::= 
            {
              Object RESULT =null;
RESULT=new LinkedSymbolTable();
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$4",115, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // component_list ::= component_declaration_list NT$3 variant_part_option 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("component_list",29, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // NT$3 ::= 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
RESULT=l;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$3",114, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // record_type_definition ::= RECORD NT$1 component_list NT$2 END RECORD 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("record_type_definition",28, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // NT$2 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
RESULT=l;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$2",113, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // NT$1 ::= 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
parser.setUnclosed("end record;", "record", rleft,rright );
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$1",112, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // discrete_range ::= range 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=r;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discrete_range",27, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // discrete_range ::= numeric_type range_constraint_option 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discrete_range",27, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // discrete_range ::= name range_constraint_option 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discrete_range",27, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // fixed_point_constraint ::= DELTA simple_expression range_constraint_option 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("fixed_point_constraint",26, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // range_constraint_option ::= range_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("range_constraint_option",25, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // range_constraint_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("range_constraint_option",25, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // floating_point_constraint ::= DIGITS simple_expression range_constraint_option 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("floating_point_constraint",24, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // accuracy_constraint ::= fixed_point_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("accuracy_constraint",23, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // accuracy_constraint ::= floating_point_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("accuracy_constraint",23, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // range ::= simple_expression DOUBLEDOT simple_expression 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
					if ((t != null) && (f != null)){
							
					 ParserResult pr=(ParserResult)t;
					 ParserResult qr=(ParserResult)f;
					 if((pr.type != null) && (qr.type != null)){
					 Type ptipo=(pr.type instanceof FunctionType)? (((FunctionType)pr.type).getRange()) : pr.type;
					 Type qtipo=(qr.type instanceof FunctionType)? (((FunctionType)qr.type).getRange()) : qr.type;
						if(ptipo.isNumeric() && qtipo.isNumeric()){
							//comparar los tipos!
							if(compare_types(ptipo,qtipo, fleft, fright)){
								ArrayList<Object> rVal=new ArrayList<Object>();
								rVal.add(pr.value);
								rVal.add(qr.value);
								RESULT=new ParserResult(rVal, ptipo);
							}else{ 
								RESULT= null;
							}
						}else{
							//determine who's to blame:
							if(!ptipo.isNumeric())
							    agregarError("Se esperaba un tipo numérico y se encontró "+ptipo.toString(), tleft, tright);
							else 
							    agregarError("Se esperaba un tipo numérico y se encontró "+qtipo.toString(), fleft, fright);
							RESULT=null;
						}
						
					}	
					}	
		
		
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("range",22, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // range_constraint ::= RANGE range 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("range_constraint",21, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // subtype_indication_with_constraint ::= FLOAT accuracy_constraint 
            {
              Object RESULT =null;
		RESULT=new ParserResult(new FloatType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",20, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // subtype_indication_with_constraint ::= numeric_type range_constraint 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT=n;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",20, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // subtype_indication_with_constraint ::= name accuracy_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",20, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // subtype_indication_with_constraint ::= name range_constraint 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",20, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // subtype_indication ::= primitive_type 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=t;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication",19, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // subtype_indication ::= subtype_indication_with_constraint 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=c;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication",19, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // subtype_indication ::= name 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=n;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_indication",19, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // subtype_declaration ::= SUBTYPE identifier IS subtype_indication SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
					ParserResult ps=(ParserResult)s;
					if(ps.type!= null){
					if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
						Type t=ps.type;
						t.name=(String)i;
						//se pone un nuevo tipo con otro nombre:
						if(!currentScope.put(i, new AdaSymbol(t, true))){
							agregarError("El tipo '"+((String)i)+"' ya ha sido declarado", ileft, iright);
						}
					}
					}else{
						agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
					}
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("subtype_declaration",18, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // type_definition ::= record_type_definition 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		parser.emptyLastUnclosed();RESULT=r;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("type_definition",17, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // discriminant_part_option ::= discriminant_part 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_part_option",16, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // discriminant_part_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("discriminant_part_option",16, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // type_declaration ::= incomplete_type_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("type_declaration",15, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // type_declaration ::= TYPE identifier discriminant_part_option IS NT$0 type_definition SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-4)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-4)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
				//viene una tabla de símbolos: porque siempre son records
				LinkedSymbolTable table=(LinkedSymbolTable)t;				
				if(!currentScope.put(i, new AdaSymbol(new RecordType(((String)i),table)))){
					agregarError("El tipo '"+((String)i)+"' ya ha sido declarado", ileft, iright);
				}else{
					gen("defRecord",i.toString().toLowerCase(),String.valueOf(table.desplazamiento), "" );
					table.id=i.toString().toLowerCase();
					currentScope.addChild(table);
				}
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("type_declaration",15, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-6)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // NT$0 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
gen("initRecord", i.toString(), "", "");
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("NT$0",111, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // identifier_list ::= identifier_list COMMA identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int jleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int jright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object j = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		ArrayList<String> r =new ArrayList<String>();
				  r.addAll((ArrayList<String>)i);r.add((String)j);	
				  RESULT=r;	
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("identifier_list",8, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // identifier_list ::= identifier COMMA identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int jleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int jright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object j = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		ArrayList<String>r=new ArrayList<String>();
				  r.add((String)i); r.add((String)j);
				  RESULT=r;		
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("identifier_list",8, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // number_declaration ::= identifier_list COLON CONSTANT ASSIGNMENT expression SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		if(o != null){
				ParserResult po=(ParserResult)o;ArrayList<String> pi=(ArrayList<String>)i;
				for(String id:pi){
					if(!currentScope.put(id, new AdaSymbol(po.type, true)))
						agregarError("El identificador "+id+" ya ha sido declarado", ileft, iright);
					else
						generar_asignacion(po, id);
				}	
				}  		
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("number_declaration",14, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // number_declaration ::= identifier COLON CONSTANT ASSIGNMENT expression SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		if(o != null){
				  ParserResult po=(ParserResult)o;
			          if(!currentScope.put(i, new AdaSymbol(po.type, true)))
					agregarError("El identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
				  else
					generar_asignacion(po, i);
				  }
				
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("number_declaration",14, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // initialization_option ::= ASSIGNMENT expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("initialization_option",13, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // initialization_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("initialization_option",13, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // object_declaration ::= identifier_list COLON constant_option subtype_indication initialization_option SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		
				ParserResult ps=(ParserResult)s; 
				if (ps.type != null){
				ArrayList<String> il=(ArrayList<String>)i;
				boolean isConstant=(c != null); 
				if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
				if(o != null){				
					ParserResult po=(ParserResult)o;
					boolean compare=compare_types(ps.type, po.type, oleft, oright);
					//Type tipo=compare ? ps.type : new ErrorType(ps.type);					
					Type tipo=ps.type;
					for(String id:il){
						if(!currentScope.put(id, new AdaSymbol(tipo, isConstant)))
							agregarError("El identificador "+id+" ya ha sido declarado", ileft, iright);
						else
							generar_asignacion(po, id);
					}	
				}else{//there's no initialization expression:
				   if(isConstant)
					agregarError("La declaración de un objeto constante requiere una expresión de inicialización", ileft, iright);	  
				   for(String id:il){
					if(!currentScope.put(id, new AdaSymbol(ps.type)))
						agregarError("El identificador "+id+" ya ha sido declarado", ileft, iright);
				   }	
				}
				}else{
					agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
	
				}
				}
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("object_declaration",12, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // object_declaration ::= identifier COLON constant_option subtype_indication initialization_option SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-5)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		ParserResult ps=(ParserResult)s; 
				//if the type is null, there was an error down the tree (and is already reported)
				if (ps.type != null){				
				boolean isConstant=(c != null); 
				if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
				if(o != null){			
					ParserResult po=(ParserResult)o;
					boolean compare=compare_types(ps.type, po.type, oleft, oright);
					//Type tipo=compare ? ps.type : new ErrorType(ps.type);					
					Type tipo=ps.type;
					if(!currentScope.put(i, new AdaSymbol(tipo, isConstant)))
						agregarError("El identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
					else //hay inicialización y todo está bien:
						generar_asignacion(po, i);
				}else{//there's no initialization expression:
				   if(isConstant)
					agregarError("La declaración de un objeto constante requiere una expresión de inicialización", ileft, iright);					        if(!currentScope.put(i, new AdaSymbol(ps.type)))
					agregarError("El identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
				   	
				}
				}else{//s no es un subtipo de nada:
					agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);	
				}
					
				}
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("object_declaration",12, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-5)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // declaration ::= number_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // declaration ::= subtype_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // declaration ::= subprogram_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // declaration ::= type_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // declaration ::= object_declaration 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // argument ::= identifier ARROW expression 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("argument",10, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // argument ::= expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=e;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("argument",10, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // argument_list ::= argument_list COMMA argument 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-2)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		if(a != null){
			  ArrayList<ParserResult> r=new ArrayList<ParserResult>();
			  r.addAll((ArrayList<ParserResult>)l);
			  r.add((ParserResult)a);
			  RESULT=r;
			 }else{RESULT=l;}			
			
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("argument_list",9, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-2)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // argument_list ::= argument 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		if(a != null){
			 ArrayList<ParserResult> r=new ArrayList<ParserResult>();
			  r.add((ParserResult)a);
			  RESULT=r;
			}
			
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("argument_list",9, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // identifier ::= IDENTIFIER 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=i;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("identifier",7, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // primitive_type ::= numeric_type 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		RESULT=(ParserResult)t;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primitive_type",5, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // primitive_type ::= BOOLEAN 
            {
              Object RESULT =null;
		RESULT=new ParserResult("boolean",new BooleanType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("primitive_type",5, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // numeric_type ::= FLOAT 
            {
              Object RESULT =null;
		RESULT=new ParserResult("float", new FloatType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("numeric_type",6, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // numeric_type ::= INTEGER 
            {
              Object RESULT =null;
		RESULT=new ParserResult("integer", new IntegerType());
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("numeric_type",6, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // n ::= 
            {
              Object RESULT =null;
		BackPatchResult br= new BackPatchResult(new ListaSalto(cuadruplos.size()));
			gen("goto", " ", "", "");
			RESULT=new ParserResult(br);
		      
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("n",3, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // m ::= 
            {
              Object RESULT =null;
		RESULT=new ParserResult(new Integer(cuadruplos.size()));
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("m",2, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // placeholder ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("placeholder",1, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // goal ::= compilation 
            {
              Object RESULT =null;
		int gleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).left;
		int gright = ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()).right;
		Object g = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.peek()).value;
		
if(parser.errores.size() == 0){	
	if(DEBUG){
		int i=0;
		for(Cuadruplo c: cuadruplos){
			System.out.println(i+"\t"+c.toString());
			i++;
		}
	}
	//aplanar las tablas de símbolos
	if(currentScope != null){
		FlatSymbolTable tabla=new FlatSymbolTable(currentScope);
		RESULT=new FrontEndResult(cuadruplos, tabla);
	}
}else{
	RESULT=null;
}

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("goal",0, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // constant_option ::= CONSTANT 
            {
              Object RESULT =null;
		RESULT=true;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("constant_option",4, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // constant_option ::= 
            {
              Object RESULT =null;

              CUP$semantic$result = parser.getSymbolFactory().newSymbol("constant_option",4, ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          return CUP$semantic$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= goal EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$semantic$stack.elementAt(CUP$semantic$top-1)).value;
		RESULT = start_val;
              CUP$semantic$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$semantic$stack.elementAt(CUP$semantic$top-1)), ((java_cup.runtime.Symbol)CUP$semantic$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$semantic$parser.done_parsing();
          return CUP$semantic$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

