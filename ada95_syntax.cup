/*Gramática del lenguaje de programación ADA95
*Autor: Luis Felipe Borjas @ 26 Agosto 09 (fecha de inicio)
*v. 2009083000
*archivo basado en el artículo  http://www.linuxgazette.com/issue39/sevenich.html
*incluido en los ejemplos de CUP que trae JFlex
*REFERENCIAS:
*==============
*la gramática, basado en el manual de referencia de Ada95(http://www.adahome.com/rm95/)
*y en el BNF de Ada-95 (http://www.seas.gwu.edu/~adagroup/ada95-syntax/)
*
*el paper:    An LALR(1) Grammar  for  (Revised) Ada
 de: G. Persch, G. Winterstein, S. Drossopoulou, M. Dausmann
*al cual me referiré de ahora en adelante como 'p85-persch'

*/

/*SECCIÓN DE DECLARACIONES PRELIMINARES*/

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;

   
/* Parser code to change the way the parser reports errors (include
   line and column number of the error). */
parser code {:
    /**Guardar los errores en un stringBuffer*/
    StringBuffer errorMessages=new StringBuffer();
    /* Change the method report_error so it will display the line and
       column of where the error occurred in the input as well as the
       reason for the error which is passed into the method in the
       String 'message'. */
    public void report_error(String message, Object info) {
   
        /* Create a StringBuffer called 'm' with the string 'Error' in it. */
        StringBuffer m = new StringBuffer("Error");
   
        /* Check if the information passed to the method is the same
           type as the type java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {
            /* Declare a java_cup.runtime.Symbol object 's' with the
               information in the object info that is being typecasted
               as a java_cup.runtime.Symbol object. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            /* Check if the line number in the input is greater or
               equal to zero. */
            if (s.left >= 0) {                
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(" en línea "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0)                    
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", columna "+(s.right+1));
            }
        }
   
        /* Add to the end of the StringBuffer error message created in
           this method the message that was passed into this method. */
        m.append(" : "+message);
   
        /* Print the contents of the StringBuffer 'm', which contains
           an error message, out on a line. */
        //System.err.println(m);
	/*Guardar el error en el buffer, mas un salto de línea:*/
	errorMessages.append(m+"\n");
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);

        System.exit(1);
    }
:};

/*SECCIÓN DE DECLARACIÓN DE TERMINALES Y NO TERMINALES*/
//primero, las terminales sin valor de retorno:
//1. Palabras reservadas (en filas por orden alfabético):
terminal ABORT, ABS, ABSTRACT, ACCEPT, ACCESS, ALIASED, ALL, AND, ARRAY, AT;
terminal BEGIN, BODY;
terminal CASE, CONSTANT;
terminal DECLARE, DELAY, DELTA, DIGITS, DO;
terminal ELSE, ELSIF, END, ENTRY, EXCEPTION, EXIT;
terminal FOR, FUNCTION;
terminal GENERIC, GOTO;
terminal IF, IN, IS;
terminal LIMITED, LOOP;
terminal MOD;
terminal NEW, NOT, NULL;
terminal OF, OR, OTHERS, OUT;
terminal PACKAGE, PRAGMA, PRIVATE,  PROCEDURE, PROTECTED;
terminal RAISE, RANGE, RECORD, REM, RENAMES, REQUEUE, RETURN, REVERSE;
terminal SELECT, SEPARATE, SUBTYPE;
terminal TAGGED, TASK, TERMINATE, THEN, TYPE;
terminal UNTIL, USE;
terminal WHEN, WHILE, WITH;
terminal XOR;
//2. Delimitadores
terminal CONCATENATE;
terminal TICK;
terminal LEFTPAR, RIGHTPAR;
terminal MULTIPLY, DIVIDE;
terminal PLUS, MINUS;
terminal COMMA;
terminal POINT;
terminal COLON;
terminal SEMICOLON;
terminal GT, LT, EQUAL, INEQUALITY, GTEQ, LTEQ;
terminal VERTICAL_LINE;
terminal ARROW;
terminal DOUBLEDOT;
terminal EXPONENTIATE;
terminal ASSIGNMENT;
terminal LEFTLABEL, RIGHTLABEL;
terminal BOX;
//3. Las funciones empotradas:
terminal PUT, GET;
//4. los tipos primitivos:
terminal BOOLEAN, INTEGER, FLOAT;

//los diz-que-operadores:
//terminal AND_THEN, OR_ELSE, NOT_IN;
//ahora las que sí tienen valores de retorno:
terminal String IDENTIFIER;
//terminal Number	NUMERIC_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Float	FLOATING_POINT_LITERAL;
terminal Character CHARACTER_LITERAL;
terminal String STRING_LITERAL;	
terminal Boolean BOOLEAN_LITERAL;

/*Sección de las no-terminales; iremos en el orden del RM*/
//INICIALES:
non terminal goal, compilation_unit;
//lexicos y varios
//de p85-persch, pag 87
non terminal constant_option;
non terminal primitive_type;
non terminal identifier, identifier_list, argument_list, argument;
non terminal declaration, object_declaration, initialization_option, number_declaration;
non terminal type_declaration, discriminant_part_option, type_definition;
non terminal subtype_declaration, subtype_indication;
//de p85-persch, pag 88
non terminal subtype_indication_with_constraint, range_constraint, range;
non terminal accuracy_constraint, floating_point_constraint, range_constraint_option, fixed_point_constraint;
non terminal record_type_definition, component_list;
//de p85-persch, pag 89
non terminal component_declaration_list, variant_part_option, component_declaration, discriminant_part;
non terminal discriminant_declaration_list, discriminant_declaration;
non terminal variant_part, variant_list;
non terminal choice, choice_list;
non terminal declarative_part, declarative_item_list;
//de p85-persch, pag 90
non terminal representation_spec_list_empty, representation_spec_list;
non terminal body_or_stub, program_component_list, program_component, body;
non terminal name, indexed_component, generalized_expression_list, generalized_expression;
non terminal selected_component, literal, aggregate, component_association_list, component_association;
non terminal expression;
//de p85-persch, pag 91
non terminal and_expression, or_expression, xor_expression, andthen_expression, orelse_expression;
non terminal relation;
non terminal membership_operator;
non terminal simple_expression, term_list, term, factor;
non terminal primary;
non terminal relational_operator, adding_operator, unary_operator, multipliying_operator;
non terminal qualified_expression, allocator;
non terminal sequence_of_statements, statement;
//de p85-persch, pag 92
non terminal label_list;
non terminal simple_statement, compound_statement;
non terminal label;
non terminal null_statement, assignment_statement;
non terminal if_statement, elsif_list, else_option, condition;
non terminal loop_statement, basic_loop;
//de p85-persch, pag 93:

//RM-3. DECLARATIONS

//RM-4: NAMES AND EXPRESSIONS

//RM-5: STATEMENTS

//RM-6: SUBPROGRAMS

/*SECCIÓN DE PRECEDENCIA Y ASOCIATIVIDAD DE TERMINALES*/
//ordenados de menor a mayor precedencia:
precedence left AND;
precedence left OR;
precedence left XOR;
precedence left EQUAL;
precedence left INEQUALITY, GT, LT, GTEQ, LTEQ;
precedence left PLUS, MINUS, CONCATENATE;
precedence left MULTIPLY, DIVIDE, MOD, REM;
precedence left EXPONENTIATE, NOT, ABS;
//precedence left AND_THEN, OR_ELSE;
//precedence left IN, NOT_IN;

/*SECCIÓN DE LA GRAMÁTICA*/
//elementos opcionales comunes:
constant_option	::=	| CONSTANT;
//empezamos con goal, que será una unidad de compilación:
start with goal;

goal	::=	compilation_unit
	;

//RM-2  LEXICAL ELEMENTS AND COMPILER-SPECIFIC RULES:
primitive_type 		::=	BOOLEAN
			|	INTEGER
			|	FLOAT
			;
identifier	::=	IDENTIFIER
		;
argument_list	::=	argument
		|	argument_list COMMA argument
		;
argument	::=	expression
		|	identifier ARROW expression
		; 

//RM-3: DECLARATIONS
declaration	::=	object_declaration
		|	type_declaration
		|	subprogram_declaration
		|	subtype_declaration
		;
//de p85-persch, pag 87
object_declaration	::=	identifier COLON constant_option subtype_indication initialization_option SEMICOLON
			|	identifier_list	COLON constant_option subtype_indication initialization_option SEMICOLON
			;
initialization_option	::=	| ASSIGNMENT expression
			;
number_declaration	::=	identifier COLON CONSTANT ASSIGNMENT expression SEMICOLON
			|	identifier_list COLON CONSTANT ASSIGNMENT expression SEMICOLON
			;
identifier_list		::=	identifier COMMA identifier 
			|	 identifier_list COMMA identifier
			;
type_declaration	::=	TYPE identifier discriminant_part_option IS type_definition SEMICOLON
			;
discriminant_part_option ::=	| discriminant_part
			;
type_definition		::=	record_type_definition
			;
subtype_declaration	::=	SUBTYPE identifier IS subtype_indication SEMICOLON
			;
subtype_indication	::=	name
			|	subtype_indication_with_constraint
			;
//de p85-persch, pag 88
subtype_indication_with_constraint ::=	name range_constraint
				   |	name accuracy_constraint
				   ;
range_constraint		   ::= RANGE range
				   ;
range	::=	simple_expression DOUBLEDOT simple_expression
	;
//quité la enumeration type definition
accuracy_constraint		::=	floating_point_constraint
				|	fixed_point_constraint
				;
floating_point_constraint	::=	DIGITS simple_expression range_constraint_option
				;
range_constraint_option		::=	| range_constraint
				;
fixed_point_constraint		::=	DELTA simple_expression range_constraint_option
				;
//no pongo lo de array ni index ni discrete range
record_type_definition		::=	RECORD component_list END RECORD
				;
component_list			::=	component_declaration_list variant_part_option 
				|	NULL SEMICOLON
				;
//de p85-persch, pag 89			
component_declaration_list	::=	| component_declaration_list component_declaration
				;
variant_part_option		::=	| variant_part
				;
component_declaration		::=	discriminant_declaration SEMICOLON 
				;
discriminant_part		::=	LEFTPAR discriminant_declaration_list RIGHTPAR
				;
discriminant_declaration_list	::=	discriminant_declaration
				|	discriminant_declaration_list SEMICOLON discriminant_declaration
				;
discriminant_declaration	::=	identifier COLON subtype_indication initialization_option
				|	identifier_list COLON subtype_indication initialization_option
				;
variant_part 			::=	CASE name IS variant_list END CASE SEMICOLON
				;
variant_list			::=	| variant_list WHEN choice_list ARROW component_list
				;
choice				::=	simple_expression
				|	OTHERS
				|	name range_constraint
				|	range
				;
choice_list			::=	choice 
				|	choice_list VERTICAL_LINE choice
				; 
declarative_part		::=	declarative_item_list
				|	declarative_item_list	representation_spec_list_empty  program_component_list
				|	declarative_item_list body_or_stub program_component_list
				;
declarative_item_list		::=	| declarative_item_list declaration
				|	declarative_item_list use_clause
				;

//de p85-persch, pag 90
representation_spec_list_empty	::=	| representation_spec_list
				;
representation_spec_list	::= 	representation_specification
				|	representation_spec_list representation_specification
				;
body_or_stub			::=	body 
				|       body_stub
				;
program_component_list		::=	| program_component_list program_component
				;
program_component		::=	body
				|	package_declaration
				|	body_stub
				;
body				::=	subprogram_body
				|	package_body
				;
//"No vamos a manejar atributos", por tanto, quité la regla que produce attribute
name				::=	identifier
				|	indexed_component
				|	selected_component
				|	function_call
				|	operator_symbol
				;
indexed_component		::=	name LEFTPAR generalized_expression_list RIGHTPAR
				;
generalized_expression_list	::=	generalized_expression
				|	generalized_expression_list COMMA generalized_expression
				;
generalized_expression		::=	expression
				|	range
				|	subtype_indication_with_constraint
				|	choice_list ARROW expression
				|	choice_list ARROW subtype_indication_with_constraint
				;
selected_component		::=	name POINT identifier
				|	name POINT ALL
				|	name POINT operator_symbol
				;
//pongo acá los string literals?
literal				::=	integer_literal
				|	floating_point_literal
				|	character_literal
				|	NULL
				;
aggregate			::=	LEFTPAR component_association_list RIGHTPAR
				|	LEFTPAR choice_list ARROW expression RIGHTPAR
				;
component_association_list	::=	component_association COMMA component_association
				|	component_association_list COMMA component_association
				;
component_association		::=	expression
				|	choice_list ARROW expression
				;
expression			::=	relation
				|	and_expression
				|	or_expression
				|	xor_expression
				|	andthen_expression
				|	orelse_expression
				;
//de p85-persch, pag 91
and_expression			::=	relation AND relation
				|	and_expression AND relation
				;
or_expression			::=	relation OR relation
				|	or_expression OR relation
				;
xor_expression			::=	relation XOR relation
				|	xor_expression XOR relation
				;
andthen_expression		::=	relation AND THEN relation
				|	andthen_expression AND THEN relation
				;
orelse_expression		::=	relation OR ELSE relation
				|	orelse_expression OR ELSE relation
				;
relation			::=	simple_expression
				|	simple_expression relational_operator simple_expression
				|	simple_expression membership_operator range
				|	simple_expression membership_operator subtype_indication
				;
membership_operator		::=	IN
				|	NOT IN
				;
simple_expression		::=	term_list	
				|	unary_operator term_list
				;
term_list			::=	term
				|	term_list adding_operator term
				;
term				::=	factor
				|	term multiplying_operator factor
				;
factor				::=	primary
				|	primary EXPONENTIATE primary
				;
primary				::=	literal
				|	aggregate
				|	name
				|	allocator
				|	qualified_expression
				|	LEFTPAR expression RIGHTPAR
				;
relational_operator		::=	EQUAL
				|	INEQUALITY
				|	LT	
				|	GT	
				|	GTEQ
				|	LTEQ
				;
adding_operator			::=	PLUS
				|	MINUS
				|	CONCATENATE
				;
unary_operator			::=	PLUS
				|	MINUS
				|	NOT
				;
multiplying_operator		::=	MULTIPLY
				|	DIVIDE
				|	MOD
				|	REM
				;
qualified_expression		::=	name TICK LEFTPAR expression RIGHTPAR
				|	name TICK aggregate
				;
allocator			::=	NEW name
				;
sequence_of_statements		::=	statement
				|	sequence_of_statements statement
				;
//usaremos pragma? De ser así, aquí también produciría pragma:
statement			::=	label_list simple_statement
				|	label_list compund_statement
				;
//de p85-persch, pag 92:
label_list			::=	| label_list label
				;
simple_statement		::=	null_statement
				|	assignment_statement
				|	exit_statement
				|	return_statement
				|	goto_statement
				|	procedure_call
				|	delay_statement
				|	abort_statement
				|	raise_statement	
				|	code_statement
				;
compound_statement		::=	if_statement
				|	case_statement
				|	loop_statement
				|	block
				|	accept_statement
				|	select_statement
				;
label				::=	LEFTLABEL identifier RIGHTLABEL
				;
null_statement			::=	NULL SEMICOLON
				;
assignment_statement		::=	name ASSIGNMENT expression SEMICOLON
				;
if_statement			::=	IF condition THEN sequence_of_statements elsif_list else_option END IF SEMICOLON
				;
elsif_list			::=	| elsif_list ELSIF condition THEN sequence_of_statements
				;
else_option			::=	| ELSE sequence_of_statements
				;
condition			::=	expression
				;
//acá iría el bloque case, seguido de la alternative_list
loop_statement			::=	iteration_clause_option basic_loop SEMICOLON
				|	identifier COLON iteration_clause_option basic_loop identifier SEMICOLON
				;
basic_loop			::=	LOOP sequence_of_statements END LOOP
				;
//de p85-persch, pag 93
	



