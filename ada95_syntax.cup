/*Gramática del lenguaje de programación ADA95
*Autor: Luis Felipe Borjas @ 26 Agosto 09 (fecha de inicio)
*v. 2009083000
*archivo basado en el artículo  http://www.linuxgazette.com/issue39/sevenich.html
*incluido en los ejemplos de CUP que trae JFlex
*REFERENCIAS:
*==============
*la gramática, basado en el manual de referencia de Ada95(http://www.adahome.com/rm95/)
*y en el BNF de Ada-95 (http://www.seas.gwu.edu/~adagroup/ada95-syntax/)
*
*el paper:    An LALR(1) Grammar  for  (Revised) Ada
 de: G. Persch, G. Winterstein, S. Drossopoulou, M. Dausmann
*al cual me referiré de ahora en adelante como 'p85-persch'

*/

/*SECCIÓN DE DECLARACIONES PRELIMINARES*/

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
//import java.util.ArrayList;
/*Métodos que van en la clase de acciones: Poner acá todo lo que debería ser accesible por la gramática*/
action code{:
 /**La variable donde guardar errores: */
 //public ArrayList<String> errores =new ArrayList<String>();
 /**Esta función chequea que un subprograma que tiene nombre al principio y final tenga exactamente el mismo nombre
   * @param start la palabra del inicio
     @param sline, scolumn el left y right del símbolo start
     @param end la palabra del final
     @param eline, ecolumn el left y right del símbolo end
 */

 public void check_coherence(Object start, int sline, int scolumn, Object end, int eline, int ecolumn){
	 String s=(String)start;
	 String sInfo="inicio: "+s+" ["+String.valueOf(sline+1)+" , "+String.valueOf((scolumn-s.length()))+"]";
	//la funciones pueden no tener el del final:
	 if(end==null){return;}
	 String e=(String)end;
	 String eInfo=" y fin: "+e+" ["+String.valueOf(eline+1)+" , "+String.valueOf(ecolumn+1)+"]";
	 //ver si son lo mismo:
	if(!s.equals(e)){
		System.err.println("Error sintáctico: el nombre del subprograma debe coincidir entre "+sInfo+eInfo);
	}
	

 }
 /**La función que guarda errores para luego ser impresos por el front-end
*@param line, column la línea y columna del error
*//*
public void push_error(int line, int column){
	errores.add(new String(String.valueOf(line)+"_"+String.valueOf(column)));
	System.out.println(errores);
}
 */
:};

/* Métodos que van en la clase del parser */
parser code {:
    /**Guardar los errores en un stringBuffer*/
    //StringBuffer errorMessages=new StringBuffer();
    /* Change the method report_error so it will display the line and
       column of where the error occurred in the input as well as the
       reason for the error which is passed into the method in the
       String 'message'. */
    public void report_error(String message, Object info) {
   
        /* Create a StringBuffer called 'm' with the string 'Error' in it. */
        StringBuffer m = new StringBuffer();
        /* Add to the end of the StringBuffer error message created in
           this method the message that was passed into this method. */
	if(message.equalsIgnoreCase("Syntax error")){
		message="Error Sintáctico  ";
	}else if(message.equalsIgnoreCase("Couldn't repair and continue parse")){
		message="Error ";
	}	
        m.append(message);
   
        /* Check if the information passed to the method is the same
           type as the type java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {
            /* Declare a java_cup.runtime.Symbol object 's' with the
               information in the object info that is being typecasted
               as a java_cup.runtime.Symbol object. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            /* Check if the line number in the input is greater or
               equal to zero. */
            if (s.left >= 0) {                
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(": en línea "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0) {                   
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", columna "+(s.right+1));
		   //ver si se puede sacar el texto:
		   if(getScanner() instanceof Ada95Lexer){
			m.append("; no se esperaba '"+((Ada95Lexer)getScanner()).getCurrentText()+"'");
		   }
		}
	///guardar el error en la variable de errores:
            }else if(s.toString().equals("#0")){
			m.append(": final de archivo inesperado");
		}

        }
   
   
        /* Print the contents of the StringBuffer 'm', which contains
           an error message, out on a line. */
        System.err.println(m);
	/*Guardar el error en el buffer, mas un salto de línea:*/
	//	errorMessages.append(m+"\n");
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);

        //System.exit(1);
    }
 /**La función que guarda errores para luego ser impresos por el front-end
*@param line, column la línea y columna del error/
public void push_error(int line, int column){
	errores.add(new String(String.valueOf(line)+"_"+String.valueOf(column)));
	System.out.println(errores);
}*/

:};

/*SECCIÓN DE DECLARACIÓN DE TERMINALES Y NO TERMINALES*/
//primero, las terminales sin valor de retorno:
//1. Palabras reservadas (en filas por orden alfabético):
terminal ABORT, ABS, ABSTRACT, ACCEPT, ACCESS, ALIASED, ALL, AND, ARRAY, AT;
terminal BEGIN, BODY;
terminal CASE, CONSTANT;
terminal DECLARE, DELAY, DELTA, DIGITS, DO;
terminal ELSE, ELSIF, END, ENTRY, EXCEPTION, EXIT;
terminal FOR, FUNCTION;
terminal GENERIC, GOTO;
terminal IF, IN, IS;
terminal LIMITED, LOOP;
terminal MOD;
terminal NEW, NOT, NULL;
terminal OF, OR, OTHERS, OUT;
terminal PACKAGE, PRAGMA, PRIVATE,  PROCEDURE, PROTECTED;
terminal RAISE, RANGE, RECORD, REM, RENAMES, REQUEUE, RETURN, REVERSE;
terminal SELECT, SEPARATE, SUBTYPE;
terminal TAGGED, TASK, TERMINATE, THEN, TYPE;
terminal UNTIL, USE;
terminal WHEN, WHILE, WITH;
terminal XOR;
//2. Delimitadores
terminal CONCATENATE;
terminal TICK;
terminal LEFTPAR, RIGHTPAR;
terminal MULTIPLY, DIVIDE;
terminal PLUS, MINUS;
terminal COMMA;
terminal POINT;
terminal COLON;
terminal SEMICOLON;
terminal GT, LT, EQUAL, INEQUALITY, GTEQ, LTEQ;
terminal VERTICAL_LINE;
terminal ARROW;
terminal DOUBLEDOT;
terminal EXPONENTIATE;
terminal ASSIGNMENT;
terminal LEFTLABEL, RIGHTLABEL;
terminal BOX;
//3. Las funciones empotradas:
terminal PUT, GET;
//4. los tipos primitivos:
terminal BOOLEAN, INTEGER, FLOAT;

//los diz-que-operadores:
terminal AND_THEN, OR_ELSE;
//terminal NOT_IN;
//ahora las que sí tienen valores de retorno:
terminal String IDENTIFIER;
//terminal Number	NUMERIC_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Float	FLOATING_POINT_LITERAL;
terminal String CHARACTER_LITERAL;
terminal String STRING_LITERAL;	
terminal Boolean BOOLEAN_LITERAL;

/*Sección de las no-terminales; iremos en el orden del RM*/
//INICIALES:
non terminal goal;
//lexicos y varios
//de p85-persch, pag 87
non terminal constant_option;
non terminal primitive_type,numeric_type;
non terminal identifier, identifier_list, argument_list, argument;
non terminal declaration, object_declaration, initialization_option, number_declaration;
non terminal type_declaration, discriminant_part_option, type_definition;
non terminal subtype_declaration, subtype_indication;
//de p85-persch, pag 88
non terminal subtype_indication_with_constraint, range_constraint, range;
non terminal accuracy_constraint, floating_point_constraint, range_constraint_option, fixed_point_constraint;
non terminal discrete_range_list, discrete_range;
non terminal record_type_definition, component_list;
//de p85-persch, pag 89
non terminal component_declaration_list, variant_part_option, component_declaration, discriminant_part;
non terminal discriminant_declaration_list, discriminant_declaration;
non terminal variant_part, variant_list;
non terminal choice, choice_list;
non terminal declarative_part, declarative_item_list;
//de p85-persch, pag 90
non terminal representation_spec_list_empty, representation_spec_list;
non terminal body_or_stub, program_component_list, program_component, body;
non terminal name, indexed_component, generalized_expression_list, generalized_expression;
non terminal selected_component, literal, aggregate, component_association_list, component_association;
non terminal expression;
//de p85-persch, pag 91
non terminal and_expression, or_expression, xor_expression, andthen_expression, orelse_expression;
non terminal relation;
non terminal membership_operator;
non terminal simple_expression, term_list, term, factor;
non terminal primary;
non terminal relational_operator, adding_operator, unary_operator, multiplying_operator;
non terminal qualified_expression, allocator;
non terminal sequence_of_statements, statement;
//de p85-persch, pag 92
non terminal label_list;
non terminal simple_statement, compound_statement;
non terminal label;
non terminal null_statement, assignment_statement;
non terminal if_statement, elsif_list, else_option, condition;
non terminal loop_statement, basic_loop;
//de p85-persch, pag 93:
non terminal iteration_clause_option;
non terminal block, declare_part_option, exception_option, exception_handler_list;
non terminal exit_statement, name_option, when_option;
non terminal return_statement, goto_statement;
non terminal subprogram_declaration, subprogram_specification, subprogram_specification_is;
//de p85-persch, pag 94:
non terminal designator, operator_symbol;
non terminal formal_part, formal_part_option;
non terminal parameter_declaration_list, parameter_declaration;
non terminal mode;
non terminal subprogram_body;
non terminal designator_option;
non terminal procedure_call,function_call;
non terminal actual_parameter_part, semicolon_parameter_part;
//non terminal actual_parameter_part, parameter_association_list, parameter_association, formal_parameter_option, explicit_actual_parameter;
non terminal package_declaration, package_specification, private_part_option, identifier_option, package_body;
//de p85-persch, pag 95:
non terminal statements_option;
non terminal private_type_definition;
non terminal use_clause;
non terminal name_list;
//de p85-persch, pag 96:
non terminal compilation, compilation_list;
//de p85-persch, pag 97:
non terminal compilation_unit;
non terminal context_specification, use_clause_option, with_clause;
non terminal subunit, body_stub;
non terminal exception_handler, exception_choice_list, exception_choice;
//de p85-persch, pag 98:
non terminal representation_specification, length_specification, record_type_representation;
non terminal location_list, alignment_clause_option, address_specification;
non terminal code_statement;

/*SECCIÓN DE PRECEDENCIA Y ASOCIATIVIDAD DE TERMINALES*/
//ordenados de menor a mayor precedencia:
precedence left AND;
precedence left OR;
precedence left XOR;
precedence left EQUAL;
precedence left INEQUALITY, GT, LT, GTEQ, LTEQ;
precedence left PLUS, MINUS, CONCATENATE;
precedence left MULTIPLY, DIVIDE, MOD, REM;
precedence left EXPONENTIATE, NOT, ABS;
precedence left AND_THEN, OR_ELSE;
//precedence left IN, NOT_IN;

/*SECCIÓN DE LA GRAMÁTICA*/
start with goal;
//elementos opcionales comunes:
constant_option	::=	| CONSTANT;
//empezamos con goal, que será una unidad de compilación:

goal	::=	compilation
	;

//RM-2  LEXICAL ELEMENTS AND COMPILER-SPECIFIC RULES:
numeric_type		::=	INTEGER
			|	FLOAT
			;
primitive_type 		::=	BOOLEAN
			|	numeric_type
			;
identifier	::=	IDENTIFIER:i {:RESULT=i;:}
		;
argument_list	::=	argument
		|	argument_list COMMA argument
		;
argument	::=	expression
		|	identifier ARROW expression
		; 

//RM-3: DECLARATIONS
declaration	::=	object_declaration
		|	type_declaration
		|	subprogram_declaration
		|	subtype_declaration
		|	number_declaration
		|	error SEMICOLON
		;
//de p85-persch, pag 87
object_declaration	::=	identifier COLON constant_option subtype_indication initialization_option SEMICOLON
			|	identifier_list	COLON constant_option subtype_indication initialization_option SEMICOLON
			;
initialization_option	::=	| ASSIGNMENT expression
			;
number_declaration	::=	identifier COLON CONSTANT ASSIGNMENT expression SEMICOLON
			|	identifier_list COLON CONSTANT ASSIGNMENT expression SEMICOLON
			;
identifier_list		::=	identifier COMMA identifier 
			|	 identifier_list COMMA identifier
			;
type_declaration	::=	TYPE identifier discriminant_part_option IS type_definition SEMICOLON
			;
discriminant_part_option ::=	| discriminant_part
			;
type_definition		::=	record_type_definition
			;
subtype_declaration	::=	SUBTYPE identifier IS subtype_indication SEMICOLON
			;
subtype_indication	::=	name
			|	subtype_indication_with_constraint
			|	primitive_type
			;
//de p85-persch, pag 88
subtype_indication_with_constraint ::=	name range_constraint
				   |	name accuracy_constraint
				   |	numeric_type range_constraint
				   |	FLOAT 	accuracy_constraint
		         	   ;
range_constraint		   ::= RANGE range
				   ;
range	::=	simple_expression DOUBLEDOT simple_expression
	;
//quité la enumeration type definition
accuracy_constraint		::=	floating_point_constraint
				|	fixed_point_constraint
				;
floating_point_constraint	::=	DIGITS simple_expression range_constraint_option
				;
range_constraint_option		::=	| range_constraint
				;
fixed_point_constraint		::=	DELTA simple_expression range_constraint_option
				;
//no pongo lo de array ni index
discrete_range_list		::=	discrete_range
				|	discrete_range_list COMMA discrete_range
				;
discrete_range			::=	name range_constraint_option
				|	numeric_type range_constraint_option
				|	range
				;
record_type_definition		::=	RECORD component_list END RECORD
				;
component_list			::=	component_declaration_list variant_part_option 
				|	NULL SEMICOLON
				;
//de p85-persch, pag 89			
component_declaration_list	::=	| component_declaration_list component_declaration
				;
variant_part_option		::=	| variant_part
				;
component_declaration		::=	discriminant_declaration SEMICOLON 
				|	error SEMICOLON
				;
discriminant_part		::=	LEFTPAR discriminant_declaration_list RIGHTPAR
				;
discriminant_declaration_list	::=	discriminant_declaration
				|	discriminant_declaration_list SEMICOLON discriminant_declaration
				;
discriminant_declaration	::=	identifier COLON subtype_indication initialization_option
				|	identifier_list COLON subtype_indication initialization_option
				;
variant_part 			::=	CASE name IS variant_list END CASE SEMICOLON
				;
variant_list			::=	| variant_list WHEN choice_list ARROW component_list
				;
choice				::=	simple_expression
				|	OTHERS
				|	name range_constraint
				|	range
				;
choice_list			::=	choice 
				|	choice_list VERTICAL_LINE choice
				; 
declarative_part		::=	declarative_item_list
				|	declarative_item_list	representation_spec_list  program_component_list
				;
declarative_item_list		::=	| declarative_item_list declaration
				|	declarative_item_list use_clause
				|	declarative_item_list body_or_stub
				;

//de p85-persch, pag 90
representation_spec_list_empty	::=	| representation_spec_list
				;
representation_spec_list	::= 	representation_specification
				|	representation_spec_list representation_specification
				;
body_or_stub			::=	body 
				|       body_stub
				;
program_component_list		::=	| program_component_list program_component
				;
program_component		::=	body
				|	package_declaration
				|	body_stub
				;
body				::=	subprogram_body
				|	package_body
				;
//"No vamos a manejar atributos", por tanto, quité la regla que produce attribute
//quité la de indexed_component:
name				::=	identifier
				|	selected_component
				|	function_call
				|	operator_symbol
				;
/*
indexed_component		::=	name LEFTPAR generalized_expression_list RIGHTPAR
				;
generalized_expression_list	::=	generalized_expression
				|	generalized_expression_list COMMA generalized_expression
				;
generalized_expression		::=	expression
				|	range
				|	subtype_indication_with_constraint
				|	choice_list ARROW expression
				|	choice_list ARROW subtype_indication_with_constraint
				;
*/
selected_component		::=	name POINT identifier
				|	name POINT ALL
				|	name POINT operator_symbol
				;
//pongo acá los string literals?
literal				::=	INTEGER_LITERAL
				|	FLOATING_POINT_LITERAL
				|	CHARACTER_LITERAL
				|	BOOLEAN_LITERAL
				|	NULL
				;
aggregate			::=	LEFTPAR component_association_list RIGHTPAR
				|	LEFTPAR choice_list ARROW expression RIGHTPAR
				;
component_association_list	::=	component_association COMMA component_association
				|	component_association_list COMMA component_association
				;
component_association		::=	expression
				|	choice_list ARROW expression
				;
expression			::=	relation
				|	and_expression
				|	or_expression
				|	xor_expression
				|	andthen_expression
				|	orelse_expression
				;
//de p85-persch, pag 91
and_expression			::=	relation AND relation
				|	and_expression AND relation
				;
or_expression			::=	relation OR relation
				|	or_expression OR relation
				;
xor_expression			::=	relation XOR relation
				|	xor_expression XOR relation
				;
andthen_expression		::=	relation AND_THEN relation
				|	andthen_expression AND_THEN relation
				;
orelse_expression		::=	relation OR_ELSE relation
				|	orelse_expression OR_ELSE relation
				;
relation			::=	simple_expression
				|	simple_expression relational_operator simple_expression
				|	simple_expression membership_operator range
				|	simple_expression membership_operator subtype_indication
				;
membership_operator		::=	IN
				|	NOT IN
				;
simple_expression		::=	term_list	
				|	unary_operator term_list
				;
term_list			::=	term
				|	term_list adding_operator term
				;
term				::=	factor
				|	term multiplying_operator factor
				;
factor				::=	primary
				|	primary EXPONENTIATE primary
				;
primary				::=	literal
				|	aggregate
				|	name
				|	allocator
				|	qualified_expression
				|	LEFTPAR expression RIGHTPAR
				;
relational_operator		::=	EQUAL
				|	INEQUALITY
				|	LT	
				|	GT	
				|	GTEQ
				|	LTEQ
				;
adding_operator			::=	PLUS
				|	MINUS
				|	CONCATENATE
				;
unary_operator			::=	PLUS
				|	MINUS
				|	NOT
				;
multiplying_operator		::=	MULTIPLY
				|	DIVIDE
				|	MOD
				|	REM
				;
qualified_expression		::=	name TICK LEFTPAR expression RIGHTPAR
				|	name TICK aggregate
				;
allocator			::=	NEW name
				;
sequence_of_statements		::=	statement
				|	sequence_of_statements statement
				;
//usaremos pragma? De ser así, aquí también produciría pragma:
statement			::=	label_list simple_statement
				|	label_list compound_statement
				|	error SEMICOLON 
				;
//de p85-persch, pag 92:
label_list			::=	| label_list label
				;
simple_statement		::=	null_statement
				|	assignment_statement
				|	exit_statement
				|	return_statement
				|	goto_statement
				|	procedure_call
				|	code_statement
				;
compound_statement		::=	if_statement
				|	loop_statement
				|	block
				;
label				::=	LEFTLABEL identifier RIGHTLABEL
				;
null_statement			::=	NULL SEMICOLON
				;
assignment_statement		::=	name ASSIGNMENT expression SEMICOLON
				;
if_statement			::=	IF condition THEN sequence_of_statements elsif_list else_option END IF SEMICOLON
				;
elsif_list			::=	| elsif_list ELSIF condition THEN sequence_of_statements
				;
else_option			::=	| ELSE sequence_of_statements
				;
condition			::=	expression
				;
//acá iría el bloque case, seguido de la alternative_list
loop_statement			::=	iteration_clause_option basic_loop SEMICOLON
				|	identifier COLON iteration_clause_option basic_loop identifier SEMICOLON
				;
basic_loop			::=	LOOP sequence_of_statements END LOOP
				;
//de p85-persch, pag 93
iteration_clause_option		::=
				|	FOR identifier IN discrete_range
				|	FOR identifier IN REVERSE discrete_range
				|	WHILE condition
				;
block				::=	declare_part_option BEGIN sequence_of_statements exception_option END SEMICOLON
				|	identifier COLON declare_part_option BEGIN sequence_of_statements exception_option END identifier SEMICOLON
				;
declare_part_option		::=	
				|	 DECLARE declarative_part
				;
//probablemente quite esto de exceptions:
exception_option		::=	
				|	EXCEPTION exception_handler_list
				;
exception_handler_list		::=	
				|	exception_handler_list exception_handler
				;
exit_statement			::=	EXIT name_option when_option SEMICOLON
				;
name_option			::=	| name
				;
when_option			::=	| WHEN condition
				;
return_statement		::=	RETURN SEMICOLON
				|	RETURN expression SEMICOLON
				;
goto_statement			::=	GOTO name SEMICOLON
				;
//no vamos a usar generics, o sí? En este caso, acá faltarían dos producciones
subprogram_declaration		::=	subprogram_specification SEMICOLON
				;	 
					
subprogram_specification	::=	PROCEDURE identifier formal_part_option
				|	FUNCTION designator formal_part_option RETURN subtype_indication
				;
subprogram_specification_is	::=	PROCEDURE identifier:i IS {:RESULT=i;:}
				|	PROCEDURE identifier:i formal_part IS {:RESULT=i;:}
				|	FUNCTION designator:i formal_part_option RETURN subtype_indication IS {:RESULT=i;:}
				;
//de p85-persch, pag 94
designator			::=	identifier:i {:RESULT=i;:} 
				|	operator_symbol:o {:RESULT=o;:}
				;
operator_symbol			::=	STRING_LITERAL
				;
formal_part			::=	LEFTPAR parameter_declaration_list RIGHTPAR
				|	error
				;
formal_part_option		::=	| formal_part
				;
parameter_declaration_list	::=	parameter_declaration
				|	parameter_declaration_list SEMICOLON parameter_declaration
				;
parameter_declaration		::=	identifier COLON mode subtype_indication initialization_option
				|	identifier_list COLON mode subtype_indication initialization_option
				;
mode				::=	
				|	IN
				|	OUT
				|	IN OUT
				;
subprogram_body			::=	subprogram_specification_is:s 
						declarative_part 
					BEGIN 
						sequence_of_statements 
					exception_option  
					END designator_option:e SEMICOLON
				{:check_coherence(s,sleft, sright, e, eleft, eright);:}
				;
designator_option		::=	| designator:d {:RESULT=d;:}
				;
//estas parecen estar incompletas: cf scc 6.4 (pag 149 del pdf) del ADA-RM
/*N.B todas, excepto las primeras, producciones de procedure y function call las agregué yo, no salen en p85-persch
* y así pasó con actual_parameter_part, parameter_association_list, parameter_association, formal_parameter_option
* y explicit_actual_parameter
*/
procedure_call			::=	name SEMICOLON
				;
function_call			::=	name LEFTPAR RIGHTPAR
				|	name actual_parameter_part
				|	PUT actual_parameter_part
				|	GET actual_parameter_part
				;
semicolon_parameter_part	::=	actual_parameter_part SEMICOLON
				;
/*Esta no me parece tan poderosa:
put_call	::= PUT LEFTPAR actual_parameter_list RIGHTPAR
y simil para get
pero quería sólo dejar que pusieran expresiones booleanas, enteras y float allí...
supongo que queda para el semántico...
*/

//actual_parameter_part		::=	 LEFTPAR parameter_association_list RIGHTPAR	
actual_parameter_part		::=	 LEFTPAR argument_list RIGHTPAR			
				|	 error
				;
/*
parameter_association_list	::=	parameter_association
				|	parameter_association_list COMMA parameter_association
				;
//aquí iría selector_name::= identifier | character_literal |operator_symbol según el RM
parameter_association		::=	formal_parameter_option explicit_actual_parameter
				;
formal_parameter_option		::=	| identifier ARROW
				;
explicit_actual_parameter	::=	expression
				|	name
				;	*/

//si usásemos generic, aquí faltarían dos producciones:
package_declaration		::=	package_specification SEMICOLON 
				;	
package_specification		::=	PACKAGE identifier IS declarative_item_list private_part_option END identifier_option
				;
private_part_option		::=	| PRIVATE declarative_item_list representation_spec_list_empty
				;
identifier_option		::=	| identifier
				;
package_body			::=	PACKAGE BODY identifier IS declarative_part statements_option END identifier_option SEMICOLON
				;
//de p85-persch, pag 95:
statements_option		::=	| BEGIN sequence_of_statements exception_option
				;
private_type_definition		::=	LIMITED PRIVATE
				|	PRIVATE
				;
use_clause			::=	USE name_list SEMICOLON 
				;
name_list			::=  	name
				|	name_list COMMA name
				;
/*acá irían las renaming declaration, y comienza lo relacionado con tasks:
* entry, accept, select y abort
*/
//de p85-persch, pag 96:
/*acá sigue lo de tasks: entry, delay, select y abort*/
compilation			::=	compilation_list
				;
//a esta le falta una tal lista de pragmas, pero como no manejaremos pragmas, no la pongo:
compilation_list		::= 	compilation_unit
				|	compilation_list compilation_unit
				|	error
				;
//de p85-persch, pag 97:
compilation_unit		::=	context_specification subprogram_declaration
				|	context_specification subprogram_body
				|	context_specification package_declaration
				|	context_specification package_body
				|	context_specification subunit
				;
//esto de context specification y las clauses va a desaparecer...
context_specification		::=	| context_specification  with_clause use_clause_option
				;
use_clause_option		::=	| use_clause
				;
with_clause			::=	WITH name_list SEMICOLON
				;
subunit				::=	SEPARATE LEFTPAR name RIGHTPAR body
				;
body_stub			::=	subprogram_specification_is 	SEPARATE SEMICOLON
				|	PACKAGE BODY identifier IS 	SEPARATE SEMICOLON
				;
//hay que quitar todo esto de exceptions!
exception_handler		::=	WHEN exception_choice_list ARROW sequence_of_statements
				;
exception_choice_list		::=	exception_choice 
				|	exception_choice_list VERTICAL_LINE exception_choice
				;
exception_choice		::=	name 
				|	OTHERS
				;
//de p85-persch, pag 98:
representation_specification	::=	length_specification
				|	record_type_representation
				|	address_specification
				;
length_specification		::=	FOR name USE expression SEMICOLON
				;
record_type_representation	::=	FOR name USE
						RECORD alignment_clause_option 
							location_list
						END RECORD SEMICOLON
				;
location_list			::=	| location_list name AT simple_expression RANGE range SEMICOLON
				;
alignment_clause_option		::=	| AT MOD simple_expression SEMICOLON
				;
address_specification		::=	FOR name USE AT simple_expression SEMICOLON
				;
code_statement			::=	qualified_expression SEMICOLON
				;
					
				
	


