/*Gramática del lenguaje de programación ADA95
*Autor: Luis Felipe Borjas @ 26 Agosto 09 (fecha de inicio)
*v. 2009083000
*archivo basado en el artículo  http://www.linuxgazette.com/issue39/sevenich.html
*incluido en los ejemplos de CUP que trae JFlex
*REFERENCIAS:
*==============
*la gramática, basado en el manual de referencia de Ada95(http://www.adahome.com/rm95/)
*y en el BNF de Ada-95 (http://www.seas.gwu.edu/~adagroup/ada95-syntax/)
*
*el paper:    An LALR(1) Grammar  for  (Revised) Ada
 de: G. Persch, G. Winterstein, S. Drossopoulou, M. Dausmann
*al cual me referiré de ahora en adelante como 'p85-persch'

*/

/*SECCIÓN DE DECLARACIONES PRELIMINARES*/

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
import java.util.Stack;
import java.util.ArrayList;
import AdaSemantic.*;
/*Métodos que van en la clase de acciones: Poner acá todo lo que debería ser accesible por la gramática*/
action code{:

/**The current symbol table*/
LinkedSymbolTable currentScope = new LinkedSymbolTable();
//pongo cualquier cosa, sólo para que ya estén en la st (y no deje declarar otras fn con estos nombres):
currentScope.put("put", new IntegerType());
currentScope.put("get", new IntegerType());


 /**Esta función chequea que un subprograma que tiene nombre al principio y final tenga exactamente el mismo nombre
   * @param start la palabra del inicio
     @param sline, scolumn el left y right del símbolo start
     @param end la palabra del final
     @param eline, ecolumn el left y right del símbolo end
 */

 public void check_coherence(Object start, int sline, int scolumn, Object end, int eline, int ecolumn){
	 String s=(String)start;
	 String sInfo="inicio: "+s+" ["+String.valueOf(sline+1)+" , "+String.valueOf((scolumn-s.length()))+"]";
	//la funciones pueden no tener el del final:
	 if(end==null){return;}
	 String e=(String)end;
	 String eInfo=" y fin: "+e+" ["+String.valueOf(eline+1)+" , "+String.valueOf(ecolumn+1)+"]";
	 //ver si son lo mismo:
	if(!s.equals(e)){
		//System.err.println("Error sintáctico  : el nombre del subprograma debe coincidir entre "+sInfo+eInfo);
		parser.errores.add("Error sintáctico  : el nombre del subprograma debe coincidir entre "+sInfo+eInfo);
	}
	

 }
/**Método para comprobar errores semánticos de tipo. Los agrega también a la lista de errores. Se vale del método equals de las clases
   que heredan de Type.
   @param expected el tipo esperado
   @param found el tipo encontrado
   @param foundLine, foundColumn, etc la línea y columna donde se encuentra la declaración.
*/
public boolean compare_types(Object expected, Object found, int foundLine, int foundColumn){
	Type e=(Type)expected;
	Type f=(Type)found;
	if(! e.equals(f)){
		StringBuffer errorMessage=new StringBuffer();
		errorMessage.append("Error semántico  : ");
		errorMessage.append(" Se esperaba el tipo "+e.toString());
		errorMessage.append(" Y se encontró "+f.toString());
		errorMessage.append(" En línea "+String.valueOf(foundLine+1)+", columna "+String.valueOf(foundColumn+1));
		parser.errores.add(errorMessage.toString());
		return false;		
	}
	return true;
}
/**Método para determinar si un símbolo está o no declarado*/
public AdaSymbol findSymbol(Object id, int line, int column){
	AdaSymbol found;
	found=currentScope.get(id);
	if(found == null)){
		parser.errores.add(" No se encuentra el símbolo '"+(String)id+"'. En línea "+(String.valueOf(line+1))+", columna "+String.valueOf(column+1));
		return null;
	}
	return found;
	
}
/*Agrega un error a los errores del parser*/
public void agregarError(String mensaje, int linea, int columna){
	parser.errores.add(mensaje+". En línea "+String.valueOf(linea+1)+", columna "+String.valueOf(columna+1));
}

public boolean validateBuiltIn(String method, Object val, int line, int col){
	if(method.equalsIgnoreCase("put") || method.equalsIgnoreCase("get")){
	//the value must be an arraylist of Parser Results:
		if(!(val instanceof ArrayList<ParserResult>))
			return false;
	//if it is, cast:
		ArrayList<ParserResult> l=(ArrayList<ParserResult>)val;
	//now, check that it has only one parameter:
		if(l.size()!=1){
			agregarError("La función '"+method"' solamente admite 1 parámetro, "+String.valueOf(l.size())+" suministrados.", line, col);
			return false;
		}
	//it has, so, check that the type is valid: it must be one of the primitive types:
		return l.get(0).type.isPrimitive();
		
	}	

	
	//invalid method:
	return false;
}
:};

/* Métodos que van en la clase del parser */
parser code {:
    /**Lista donde se guardan los errores encontrados*/
    public ArrayList<String> errores=new ArrayList<String>();
    /**Método para devolver tanto los errores del parser como los  del lexer, si los hay*/
    public ArrayList<String> getErrores(){
		if(getScanner() instanceof Ada95Lexer){
			errores.addAll(((Ada95Lexer)getScanner()).lexical_errors);		
		}
		return errores;

	}
    /**Método que devuelve las advertencias, hasta esta versión, sólo el lexer tiene advertencias...*/
    public ArrayList<String> getAdvertencias(){
	ArrayList<String> warnings=new ArrayList<String>();
	if(getScanner() instanceof Ada95Lexer){
		warnings.addAll(((Ada95Lexer)getScanner()).lexical_warnings);		
	}
	return warnings;
		
    }
    boolean EOFReported=false;
    Stack<String> unClosed=new Stack<String>();
    public String getUnclosed(){return unClosed.pop();}
    public void setUnclosed(String faltante,String abierto, int line, int col){
	String addToUnClosed="'"+faltante+"'"+" faltante para el '"+abierto+"' abierto en línea "+(line+1)+", columna "+(col+1);
	unClosed.push(addToUnClosed);

    }
    public void emptyLastUnclosed(){String tempUnClosed=unClosed.pop();tempUnClosed=null;}
    	
    /**Guardar los errores en un stringBuffer*/
    //StringBuffer errorMessages=new StringBuffer();
    /* Change the method report_error so it will display the line and
       column of where the error occurred in the input as well as the
       reason for the error which is passed into the method in the
       String 'message'. */
    public void report_error(String message, Object info) {
   	
	/*If the EOF was already reported, just return (to avoid that horrible unexpected EOF...)*/
	if(EOFReported)
		return;
        /* Create a StringBuffer called 'm' with the string 'Error' in it. */
        StringBuffer m = new StringBuffer();
        /* Add to the end of the StringBuffer error message created in
           this method the message that was passed into this method. */
	if(message.equalsIgnoreCase("Syntax error")){
		message="Error Sintáctico  ";
	}else if(message.equalsIgnoreCase("Couldn't repair and continue parse")){
		message="Error ";
	}	
        m.append(message);
   
        /* Check if the information passed to the method is the same
           type as the type java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {
            /* Declare a java_cup.runtime.Symbol object 's' with the
               information in the object info that is being typecasted
               as a java_cup.runtime.Symbol object. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            /* Check if the line number in the input is greater or
               equal to zero. */
            if (s.left >= 0) {                
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(": en línea "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0) {                   
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", columna "+(s.right+1));
		   //ver si se puede sacar el texto:
		   if(getScanner() instanceof Ada95Lexer){
			m.append("; no se esperaba '"+((Ada95Lexer)getScanner()).getCurrentText()+"'");
		   }
		}
	///guardar el error en la variable de errores:
            }else if(s.toString().equals("#0")){
			if(unClosed.empty()){				
				m.append(": final de archivo inesperado");
			}else{
				m.append(": "+getUnclosed());
				EOFReported=true;
			}

		}

        }
   
   
        /* Print the contents of the StringBuffer 'm', which contains
           an error message, out on a line. */
        //System.err.println(m);
	errores.add(m.toString());
	/*Guardar el error en el buffer, mas un salto de línea:*/
	//	errorMessages.append(m+"\n");
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);

        //System.exit(1);
    }
 /**La función que guarda errores para luego ser impresos por el front-end
*@param line, column la línea y columna del error/
public void push_error(int line, int column){
	errores.add(new String(String.valueOf(line)+"_"+String.valueOf(column)));
	System.out.println(errores);
}*/

:};

/*SECCIÓN DE DECLARACIÓN DE TERMINALES Y NO TERMINALES*/
//primero, las terminales sin valor de retorno:
//1. Palabras reservadas (en filas por orden alfabético):
terminal ABORT, ABS, ABSTRACT, ACCEPT, ACCESS, ALIASED, ALL, AND, ARRAY, AT;
terminal BEGIN, BODY;
terminal CASE, CONSTANT;
terminal DECLARE, DELAY, DELTA, DIGITS, DO;
terminal ELSE, ELSIF, END, ENTRY, EXCEPTION, EXIT;
terminal FOR, FUNCTION;
terminal GENERIC, GOTO;
terminal IF, IN, IS;
terminal LIMITED, LOOP;
terminal MOD;
terminal NEW, NOT, NULL;
terminal OF, OR, OTHERS, OUT;
terminal PACKAGE, PRAGMA, PRIVATE,  PROCEDURE, PROTECTED;
terminal RAISE, RANGE, RECORD, REM, RENAMES, REQUEUE, RETURN, REVERSE;
terminal SELECT, SEPARATE, SUBTYPE;
terminal TAGGED, TASK, TERMINATE, THEN, TYPE;
terminal UNTIL, USE;
terminal WHEN, WHILE, WITH;
terminal XOR;
//2. Delimitadores
terminal CONCATENATE;
terminal TICK;
terminal LEFTPAR, RIGHTPAR;
terminal MULTIPLY, DIVIDE;
terminal PLUS, MINUS;
terminal COMMA;
terminal POINT;
terminal COLON;
terminal SEMICOLON;
terminal GT, LT, EQUAL, INEQUALITY, GTEQ, LTEQ;
terminal VERTICAL_LINE;
terminal ARROW;
terminal DOUBLEDOT;
terminal EXPONENTIATE;
terminal ASSIGNMENT;
terminal LEFTLABEL, RIGHTLABEL;
terminal BOX;
//3. Las funciones empotradas:
terminal PUT, GET;
//4. los tipos primitivos:
terminal BOOLEAN, INTEGER, FLOAT;

//los diz-que-operadores:
terminal AND_THEN, OR_ELSE;
//terminal NOT_IN;
//ahora las que sí tienen valores de retorno:
terminal String IDENTIFIER;
//terminal Number	NUMERIC_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal Float	FLOATING_POINT_LITERAL;
terminal String CHARACTER_LITERAL;
terminal String STRING_LITERAL;	
terminal Boolean BOOLEAN_LITERAL;

/*Sección de las no-terminales; iremos en el orden del RM*/
//INICIALES:
non terminal goal, placeholder;
//lexicos y varios
//de p85-persch, pag 87
non terminal constant_option;
non terminal primitive_type,numeric_type;
non terminal identifier, identifier_list, argument_list, argument;
non terminal declaration, object_declaration, initialization_option, number_declaration;
non terminal type_declaration, discriminant_part_option, type_definition;
non terminal subtype_declaration, subtype_indication;
//de p85-persch, pag 88
non terminal subtype_indication_with_constraint, range_constraint, range;
non terminal accuracy_constraint, floating_point_constraint, range_constraint_option, fixed_point_constraint;
non terminal discrete_range;
non terminal record_type_definition, component_list;
//de p85-persch, pag 89
non terminal component_declaration_list, variant_part_option, component_declaration, discriminant_part;
non terminal discriminant_declaration_list, discriminant_declaration;
non terminal variant_part, variant_list;
non terminal choice, choice_list;
non terminal incomplete_type_declaration;
non terminal declarative_part, declarative_item_list, declarative_item;
//de p85-persch, pag 90
non terminal name;
non terminal selected_component, literal, aggregate, component_association_list, component_association;
non terminal expression;
//de p85-persch, pag 91
non terminal and_expression, or_expression, xor_expression, andthen_expression, orelse_expression;
non terminal relation;
non terminal membership_operator;
non terminal simple_expression, term_list, term, factor;
non terminal primary;
non terminal relational_operator, adding_operator, unary_operator, multiplying_operator;
non terminal qualified_expression, allocator;
non terminal sequence_of_statements, statement;
//de p85-persch, pag 92
non terminal label_list;
non terminal simple_statement, compound_statement;
non terminal label;
non terminal null_statement, assignment_statement;
non terminal if_statement, elsif_list, else_option, condition;
non terminal loop_statement, basic_loop;
//de p85-persch, pag 93:
non terminal iteration_clause_option;
non terminal block, declare_part_option;
non terminal exit_statement, name_option, when_option;
non terminal return_statement, goto_statement;
non terminal subprogram_declaration, subprogram_specification, subprogram_specification_is;
//de p85-persch, pag 94:
non terminal designator, operator_symbol;
non terminal formal_part, formal_part_option;
non terminal parameter_declaration_list, parameter_declaration;
non terminal mode;
non terminal subprogram_body;
non terminal designator_option;
non terminal procedure_call,function_call;
non terminal actual_parameter_part;
//de p85-persch, pag 95:
//de p85-persch, pag 96:
non terminal compilation, compilation_list;
//de p85-persch, pag 97:
non terminal compilation_unit;
//de p85-persch, pag 98:
non terminal code_statement;

/*SECCIÓN DE PRECEDENCIA Y ASOCIATIVIDAD DE TERMINALES*/
//ordenados de menor a mayor precedencia:
precedence left AND;
precedence left OR;
precedence left XOR;
precedence left EQUAL;
precedence left INEQUALITY, GT, LT, GTEQ, LTEQ;
precedence left PLUS, MINUS, CONCATENATE;
precedence left MULTIPLY, DIVIDE, MOD, REM;
precedence left EXPONENTIATE, NOT, ABS;
precedence left AND_THEN, OR_ELSE;
//precedence left IN, NOT_IN;

/*SECCIÓN DE LA GRAMÁTICA*/
start with goal;
//elementos opcionales comunes:
constant_option	::=	| CONSTANT;
//empezamos con goal, que será una unidad de compilación:

goal	::=	compilation
	;
//works as a marker, as described in the book, to let action code be executed at otherwise impossible places (like the end)
placeholder ::= ;
//RM-2  LEXICAL ELEMENTS AND COMPILER-SPECIFIC RULES:
numeric_type		::=	INTEGER	{:RESULT=new ParserResult(new IntegerType());:}
			|	FLOAT   {:RESULT=new ParserResult(new FloatType());:}
			;
primitive_type 		::=	BOOLEAN {:RESULT=new ParserResult(new BooleanType());:}
			|	numeric_type:t {:RESULT=(ParserResult)t;:}
			;
identifier	::=	IDENTIFIER:i {:RESULT=i;:}
		;
argument_list	::=	argument:a
			{:ArrayList<ParserResult> r=new ArrayList<ParserResult>();
			  r.add((ParserResult)a);
			  RESULT=r;
			:}
		|	argument_list:l COMMA argument:a
			{:ArrayList<ParserResult> r=new ArrayList<ParserResult>();
			  r.addAll((ArrayList<ParserResult>)l);
			  r.add((ParserResult)a);
			  RESULT=r;
			:}
		;
argument	::=	expression:e 
			{:RESULT=e;:}
/*In subprogram calls, named parameter notation (i.e. the name of the formal parameter followed of the symbol => and then the actual parameter) allows the rearrangement of the parameters in the call: ¡Habría que tener una tabla de símbolos en la función también!*/		
		|	identifier ARROW expression
			/*Habría que, mágicamente, saber el nombre de la función para buscar los ids en la tabla de símbolos...O pasarlos y buscar arriba*/
		; 

//RM-3: DECLARATIONS
declaration	::=	object_declaration
		|	type_declaration
		|	subprogram_declaration
		|	subtype_declaration
		|	number_declaration
		;
//de p85-persch, pag 87
/*si las variables están inicializadas, chequear los tipos, y si concuerdan, ponerla en la tabla de símbolos actual */
object_declaration	::=	identifier:i COLON constant_option subtype_indication:s  initialization_option:o SEMICOLON
				{:ParserResult ps=(ParserResult)s; 
				//if the type is null, there was an error down the tree (and is already reported)
				if (ps.type != null){
				if(o != null){			
					ParserResult po=(ParserResult)o;
					boolean compare=compare_types(ps.type, po.type, oleft, oright);
					Type tipo=compare ? ps.type : new ErrorType(ps.type);					
					if(!currentScope.put(i, new AdaSymbol(tipo)))
						agregarError("Error semántico  : el identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
						
				}else{//there's no initialization expression:
					if(!currentScope.put(i, new AdaSymbol(ps.type)))
						agregarError("Error semántico  : el identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
				}
				}:}
			|	identifier_list:i COLON constant_option subtype_indication:s  initialization_option:o SEMICOLON
				{:
				ParserResult ps=(ParserResult)s; 
				if (ps.type != null){
				ArrayList<String> il=(ArrayList<String>)i;
				if(o != null){				
					ParserResult po=(ParserResult)o;
					boolean compare=compare_types(ps.type, po.type, oleft, oright);
					Type tipo=compare ? ps.type : new ErrorType(ps.type);					
					for(String id:il){
						if(!currentScope.put(id, new AdaSymbol(tipo)))
							agregarError("Error semántico  : el identificador "+id+" ya ha sido declarado", ileft, iright);
					}	
				}else{//there's no initialization expression:
					for(String id:il){
						if(!currentScope.put(id, new AdaSymbol(ps.type)))
							agregarError("Error semántico  : el identificador "+id+" ya ha sido declarado", ileft, iright);
					}	
				}
				}:}
			;
initialization_option	::=	| ASSIGNMENT expression:e {:RESULT=e;:}
			;
number_declaration	::=	identifier:i COLON CONSTANT ASSIGNMENT expression:o SEMICOLON
				{:ParserResult po=(ParserResult)o;
			          if(!currentScope.put(i, new AdaSymbol(po.type)))
					agregarError("Error semántico  : el identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
				  	
				:}
			|	identifier_list:i COLON CONSTANT ASSIGNMENT expression:o SEMICOLON
				{:ParserResult po=(ParserResult)o;ArrayList<String> pi=(ArrayList<String>)i;
				for(String id:pi){
					if(!currentScope.put(id, new AdaSymbol(po.type)))
						agregarError("Error semántico  : el identificador "+id+" ya ha sido declarado", ileft, iright);
				}	
				  		
				:}
			;
identifier_list		::=	identifier:i COMMA identifier:j 
				{:ArrayList<String>r=new ArrayList<String>();
				  r.add((String)i); r.add((String)j);
				  RESULT=r;		
				:}
			|	 identifier_list:i COMMA identifier:j
				{:ArrayList<String> r =new ArrayList<String>();
				  r.addAll((ArrayList<String>)i);r.add((String)j);	
				  RESULT=r;	
				:}
			;
/*TODO: ver qué ondas con la discriminant part: cf. en.wikibooks.org/wiki/Ada_Programming/Types/record */
type_declaration	::=	TYPE identifier:i discriminant_part_option:p IS type_definition:t SEMICOLON 
				{:
				//viene una tabla de símbolos: porque siempre son records
				LinkedSymbolTable table=(LinkedSymbolTable)t;				
				if(!currentScope.put(i, new AdaSymbol(new RecordType(((String)i),table))))
					agregarError("Error semántico  : el tipo '"+((String)i)+"' ya ha sido declarado", ileft, iright);
				:}
			|	incomplete_type_declaration
			;
discriminant_part_option ::=	| discriminant_part
			;
type_definition		::=	record_type_definition:r {:parser.emptyLastUnclosed();RESULT=r;:}
			;
subtype_declaration	::=	SUBTYPE identifier:i IS subtype_indication:s SEMICOLON
				{:
					ParserResult ps=(ParserResult)s;
					if(ps.type!= null){
						if(!currentScope.put(i, s.type)){
							agregarError("Error semántico  : el tipo '"+((String)i)+"' ya ha sido declarado", ileft, iright);
						}
					}
				:}
			;
/*Searching for a name actually checks if the type is declared*/
subtype_indication	::=	name:n {:RESULT=n;:}
			|	subtype_indication_with_constraint:c {:RESULT=c;:}
			|	primitive_type:t {:RESULT=t;:}
			;
//de p85-persch, pag 88
//TODO: define this, the constraints must be of the same type as the name...
subtype_indication_with_constraint ::=	name range_constraint
				   |	name accuracy_constraint
				   |	numeric_type:n range_constraint {:RESULT=n;:}
				   |	FLOAT 	accuracy_constraint {:RESULT=new ParserResult(new FloatType());:}
		         	   ;
range_constraint		   ::= RANGE range
				   ;
range	::=	simple_expression DOUBLEDOT simple_expression
	;
//quité la enumeration type definition
accuracy_constraint		::=	floating_point_constraint
				|	fixed_point_constraint
				;
floating_point_constraint	::=	DIGITS simple_expression range_constraint_option
				;
range_constraint_option		::=	| range_constraint
				;
fixed_point_constraint		::=	DELTA simple_expression range_constraint_option
				;
//no pongo lo de array ni index
discrete_range			::=	name range_constraint_option
				|	numeric_type range_constraint_option
				|	range
				;
record_type_definition		::=	RECORD:r  
					{:parser.setUnclosed("end record;", "record", rleft,rright );:} 
						component_list:l //returns a symbol table
						{:RESULT=l;:}
					END RECORD 
				;
/*TODO: ver qué ondas con la variant part*/
component_list			::=	component_declaration_list:l {:RESULT=l;:} variant_part_option 
				|	NULL {:RESULT=new LinkedSymbolTable();:}SEMICOLON
				;
//de p85-persch, pag 89			
/*TODO: check that this works, having code in a lambda production...*/
component_declaration_list	::=	{:RESULT=new LinkedSymbolTable();:}
				|	 component_declaration_list:l component_declaration:c
					{:LinkedSymbolTable t=(LinkedSymbolTable)l;
					  //the components are parserResults: en el valor viene el nombre.
					//c puede ser una lista o un solo elemento:
					if(c != null){	
					  if(!(c instanceof ArrayList<ParserResult>)){
					 	 ParserResult p=(ParserResult)c;
						  if(!t.put(p.value, p.type)){
							agregarError("El componente '"+((String)p.value)+
							"' ya ha sido declarado en este registro.", cleft, cright);
						  }
					  }else{//sí es una lista:
						ArrayList<ParserResult> lc=(ArrayList<ParserResult>)c;
						for(ParserResult p: lc){
						  if(!t.put(p.value, p.type)){
							agregarError("El componente '"+((String)p.value)+
							"' ya ha sido declarado en este registro.", cleft, cright);
						  }//no se pudo meter el id
							
						}//iterar en c
					  }//c es una lista
				
					}//c existe
					//subir la tabla de símbolos:
					RESULT=t;
					:}
				;
variant_part_option		::=	| variant_part
				;
component_declaration		::=	discriminant_declaration:d {:RESULT=d;:} SEMICOLON 
				|	error 
				;
discriminant_part		::=	LEFTPAR discriminant_declaration_list RIGHTPAR
				;
discriminant_declaration_list	::=	discriminant_declaration
				|	discriminant_declaration_list SEMICOLON discriminant_declaration
				;
/*=Hier*/
discriminant_declaration	::=	identifier:i COLON subtype_indication:s initialization_option:o
					{://ver si el tipo existe. Si existe, ver si coincide con la inicialización.
					  //si algo malo pasa, devolver null.
					  ParserResult ps=(ParserResult)s;
					  if(ps.type != null){//si el tipo sí fue encontrado:
						if(o != null){//ver si el tipo de o coincide con el de s:
							 ParserResult po=(ParserResult)o;
		                                         boolean compare=compare_types(ps.type, po.type, oleft, oright);
                 		                         Type tipo=compare ? ps.type : new ErrorType(ps.type);
							 RESULT=new ParserResult(i, tipo);
						}else{//no hay inicialización:
							RESULT=new ParserResult(i, ps.type);
						}
					  }else{//el tipo no fue encontrado
						RESULT=null;
					  }
					:}
				|	identifier_list:l COLON subtype_indication:s initialization_option:o
					{:
					  ParserResult ps=(ParserResult)s;
					  ArrayList<String> il=(ArrayList<String>)l;
					  if(ps.type != null){//si el tipo sí fue encontrado:
						if(o != null){//ver si el tipo de o coincide con el de s:
							 ParserResult po=(ParserResult)o;
		                                         boolean compare=compare_types(ps.type, po.type, oleft, oright);
                 		                         Type tipo=compare ? ps.type : new ErrorType(ps.type);
							 ArrayList<ParserResult> r=new ArrayList<ParserResult>();
							 for(String id: il){						
							 	r.add(new ParserResult(id, tipo));					
						         }
							 RESULT=r;
						}else{//no hay inicialización:
							 ArrayList<ParserResult> r=new ArrayList<ParserResult>();
							 for(String id: il){						
							 	r.add(new ParserResult(id, tipo));					
						         }
							 RESULT=r;
						}
					  }else{
						RESULT=null;
					  }
						
					:}
				;
variant_part 			::=	CASE name IS variant_list END CASE SEMICOLON
				;
variant_list			::=	| variant_list WHEN choice_list ARROW component_list
				;
choice				::=	simple_expression
				|	OTHERS
				|	name range_constraint
				|	range
				;
choice_list			::=	choice 
				|	choice_list VERTICAL_LINE choice
				;
incomplete_type_declaration	::=	TYPE identifier discriminant_part_option SEMICOLON
				; 
declarative_part		::=	declarative_item_list
				;
declarative_item_list		::=	| declarative_item_list declarative_item
				;
declarative_item		::=	declaration
				|	subprogram_body
				|	error SEMICOLON 
				;
//de p85-persch, pag 90
//"No vamos a manejar atributos", por tanto, quité la regla que produce attribute
//quité la de indexed_component:
/*Siempre que se llama a name se asume que ya está en la tabla de símbolos, por tanto, lo buscaremos aquí. Como un selected component
ya busca en la tabla de símbolos y también una llamada a función, así las dejaremos. (Además, éstas se sirven de name!)*/
name				::=	identifier:i 
					{://buscar el nombre en la tabla de símbolos:
					  AdaSymbol f=findSymbol(i, ileft, iright);
					  if(f!= null)
						RESULT=new ParserResult(i, f.type);						 
					  else
						RESULT=new ParserResult(i);
					:}
				|	selected_component:s {:RESULT=s;:}
				|	function_call:f {:RESULT=f;:}
				|	operator_symbol:o 
					{://buscar el nombre en la tabla de símbolos:
					  AdaSymbol f=findSymbol(i, ileft, iright);
					  if(f!= null)
						RESULT=new ParserResult(i, f.type);						 
					  else
						RESULT=new ParserResult(i);
					:}
				;
/*The only case of this is in records, isn't it?*/
selected_component		::=	name:n POINT identifier:i 
					{:
					//the selected component query:
						ParserResult namen=(ParserResult)n;
						String valex=((String)namen.value)+"."+((String)i);
						Type t=null;
					//query for it in the current scope:
						AdaSymbol f=currentScope.get(valex);		
						if (f !=null)//found:
							t=f.type;
						else
							parser.errores.add("Error Semántico  : No se puede encontrar el componente "+((String)i)+
							" para el prefijo "+((String)namen.value)+ ". En línea "+String.valueOf(nleft+1)+
							", columna "+String.valueOf(nright+1));
						RESULT=new ParserResult(valex, t);
					:}
				/*Actually, all is for referring to the pointed to object by an access name (a pointer?)*/
				|	name:n POINT ALL {:
					AdaSymbol f=findSymbol(n, nleft, nright);
					if(f != null)
						RESULT=new ParserResult(n, f.type);
					else
						RESULT=new ParserResult(n);
					:}
				/*This would have a code similar to the first alternative, BUT this one is not applicable to records...*/
				|	name POINT operator_symbol
				;
//pongo acá los string literals?
literal				::=	INTEGER_LITERAL:i	{:RESULT=new ParserResult(i, new IntegerType());:}
				|	FLOATING_POINT_LITERAL:f	{:RESULT= new ParserResult(f, new FloatType());:}
				|	CHARACTER_LITERAL:c	{:RESULT= new ParserResult(c, new StringType(1));:}
				|	BOOLEAN_LITERAL:b	{:RESULT= new ParserResult(b, new BooleanType());:}
				|	NULL:n		  	{:RESULT= new ParserResult(n);:}
				|	STRING_LITERAL:s {:RESULT=new ParserResult(s, new StringType(((String)s).length());:}
				;
aggregate			::=	LEFTPAR component_association_list RIGHTPAR
				|	LEFTPAR choice_list ARROW expression RIGHTPAR
				;
component_association_list	::=	component_association COMMA component_association
				|	component_association_list COMMA component_association
				;
component_association		::=	expression
				|	choice_list ARROW expression
				;
expression			::=	relation
				|	and_expression
				|	or_expression
				|	xor_expression
				|	andthen_expression
				|	orelse_expression
				;
//de p85-persch, pag 91
and_expression			::=	relation AND relation
				|	and_expression AND relation
				;
or_expression			::=	relation OR relation
				|	or_expression OR relation
				;
xor_expression			::=	relation XOR relation
				|	xor_expression XOR relation
				;
andthen_expression		::=	relation AND_THEN relation
				|	andthen_expression AND_THEN relation
				;
orelse_expression		::=	relation OR_ELSE relation
				|	orelse_expression OR_ELSE relation
				;
relation			::=	simple_expression
				|	simple_expression relational_operator simple_expression
				|	simple_expression membership_operator range
				|	simple_expression membership_operator subtype_indication
				;
membership_operator		::=	IN
				|	NOT IN
				;
simple_expression		::=	term_list	
				|	unary_operator term_list
				;
term_list			::=	term
				|	term_list adding_operator term
				;
term				::=	factor
				|	term multiplying_operator factor
				;
factor				::=	primary
				|	primary EXPONENTIATE primary
				;
primary				::=	literal
				|	aggregate
				|	name
				|	allocator
				|	qualified_expression
				|	LEFTPAR expression RIGHTPAR
				;
relational_operator		::=	EQUAL
				|	INEQUALITY
				|	LT	
				|	GT	
				|	GTEQ
				|	LTEQ
				;
adding_operator			::=	PLUS
				|	MINUS
				|	CONCATENATE
				;
unary_operator			::=	PLUS
				|	MINUS
				|	NOT
				;
multiplying_operator		::=	MULTIPLY
				|	DIVIDE
				|	MOD
				|	REM
				;
qualified_expression		::=	name TICK LEFTPAR expression RIGHTPAR
				|	name TICK aggregate
				;
allocator			::=	NEW name
				;
sequence_of_statements		::=	statement
				|	sequence_of_statements statement
				;
//usaremos pragma? De ser así, aquí también produciría pragma:
statement			::=	label_list simple_statement
				|	label_list compound_statement
				|	error 
				;
//de p85-persch, pag 92:
label_list			::=	| label_list label
				;
simple_statement		::=	null_statement
				|	assignment_statement
				|	exit_statement
				|	return_statement
				|	goto_statement
				|	procedure_call
				|	code_statement
				;
compound_statement		::=	if_statement{:parser.emptyLastUnclosed();:}
				|	loop_statement{:parser.emptyLastUnclosed();:}
				|	block{:parser.emptyLastUnclosed();:}
				;
label				::=	LEFTLABEL identifier RIGHTLABEL
				;
null_statement			::=	NULL SEMICOLON
				;
assignment_statement		::=	name ASSIGNMENT expression SEMICOLON
				;
if_statement			::=	IF:i  condition THEN 
					{:parser.setUnclosed("end if;", "if", ileft, iright);:}
						sequence_of_statements 
						elsif_list 
						else_option 
					END IF SEMICOLON 
				;
elsif_list			::=	| elsif_list ELSIF condition THEN sequence_of_statements
				;
else_option			::=	| ELSE sequence_of_statements
				;
condition			::=	expression
				;
//acá iría el bloque case, seguido de la alternative_list
loop_statement			::=	iteration_clause_option basic_loop SEMICOLON
				|	identifier COLON iteration_clause_option basic_loop identifier SEMICOLON
				;
basic_loop			::=	LOOP:l 
					{:parser.setUnclosed("end loop;", "loop",lleft,lright);:}
						sequence_of_statements 
					END LOOP  
				;
//de p85-persch, pag 93
iteration_clause_option		::=
				|	FOR identifier IN discrete_range
				|	FOR identifier IN REVERSE discrete_range
				|	WHILE condition
				;
block				::=	declare_part_option BEGIN:b 
					{:parser.setUnclosed("end;", "begin del bloque",bleft, bright);:}
						sequence_of_statements 
					END SEMICOLON  
				|	identifier:i  COLON declare_part_option
						 BEGIN 
						 {:parser.setUnclosed((" end "+((String)i)+ ";"), ("begin del bloque "+((String)i)),ileft, iright);:}	
							sequence_of_statements 
						 END identifier SEMICOLON  
				;
declare_part_option		::=	
				|	 DECLARE declarative_part
				;
exit_statement			::=	EXIT name_option when_option SEMICOLON
				;
name_option			::=	| name
				;
when_option			::=	| WHEN condition
				;
return_statement		::=	RETURN SEMICOLON
				|	RETURN expression SEMICOLON
				;
goto_statement			::=	GOTO name SEMICOLON
				;
//no vamos a usar generics, o sí? En este caso, acá faltarían dos producciones
subprogram_declaration		::=	subprogram_specification SEMICOLON
				;	 
					
subprogram_specification	::=	PROCEDURE identifier formal_part_option
				|	FUNCTION designator formal_part_option RETURN subtype_indication
				;
subprogram_specification_is	::=	PROCEDURE identifier:i IS {:RESULT=i;:}
				|	PROCEDURE identifier:i formal_part IS {:RESULT=i;:}
				|	FUNCTION designator:i formal_part_option RETURN subtype_indication IS {:RESULT=i;:}
				;
//de p85-persch, pag 94
designator			::=	identifier:i {:RESULT=i;:} 
				|	operator_symbol:o {:RESULT=o;:}
				;
operator_symbol			::=	STRING_LITERAL:s {:RESULT=s;:}
				;
formal_part			::=	LEFTPAR parameter_declaration_list RIGHTPAR
				;
formal_part_option		::=	| formal_part
				;
parameter_declaration_list	::=	parameter_declaration
				|	parameter_declaration_list SEMICOLON parameter_declaration
				;
parameter_declaration		::=	identifier COLON mode subtype_indication initialization_option
				|	identifier_list COLON mode subtype_indication initialization_option
				;
mode				::=	
				|	IN
				|	OUT
				|	IN OUT
				;
subprogram_body			::=	subprogram_specification_is:s 
						declarative_part 
					BEGIN:b  
					{:parser.setUnclosed((" end "+((String)s)+";"), "begin",bleft, bright);:}
						sequence_of_statements 
					END designator_option:e SEMICOLON  
				{:check_coherence(s,sleft, sright, e, eleft, eright);:}
				;
designator_option		::=	| designator:d {:RESULT=d;:}
				;
//estas parecen estar incompletas: cf scc 6.4 (pag 149 del pdf) del ADA-RM
/*N.B todas, excepto las primeras, producciones de procedure y function call las agregué yo, no salen en p85-persch
* y así pasó con actual_parameter_part, parameter_association_list, parameter_association, formal_parameter_option
* y explicit_actual_parameter
*/
procedure_call			::=	name SEMICOLON
				;
/*Llamadas a funciones: si no tiene parámetros, sólo buscar la función (y que sea una que no tenga parámetros, eh)
Si sí, habrá también que ver que cumplan con el dominio.*/
function_call			::=	name:n LEFTPAR RIGHTPAR
				 	{:	
						AdaSymbol f=findSymbol(n, nleft, nright);	
					        if (f==null)
							RESULT=new ParserResult(n);
					  	else{//found, check if the function complies...
						//check if it IS a function:
							if(!(f.type instanceof FunctionType)){
								agregarError("Error Semántico  : '"+((String)n)+"' no es una función", nleft, nright);
								RESULT=new ParserResult(n);
						//check if it is an empty parameter function:
							}else if(!f.type.getProduct().isEmpty()){
								agregarError("Error Semántico  : la función '"+((String)n)+
								"' recibe "+(f.type.getProduct().size())+" parámetros. O suministrados", nleft, nright);
								RESULT=new ParserResult(n);
						//if it is a function with empty parameters, then return
							}else{
								RESULT=new ParserResult(n, f.type);
							}
						}
					:}
				|	name:n actual_parameter_part:p 
					{:
					AdaSymbol f=findSymbol(n, nleft, nright);
					if(f==null)
						RESULT=new ParserResult(n);
					else{
						if(!(f.type instanceof FunctionType)){
							agregarError("Error Semántico  : '"+((String)n)+"' no es una función", nleft, nright);
							RESULT=new ParserResult(n);
						}else{//la función existe: 
						//ver si está llamado con el número correcto de parámetros:
							if(!(f.type.getProduct().size()==((ArrayList<ParserResult>)p).size())){
								agregarError("Error Semántico  : la función '"+((String)n)+
								"' recibe "+(f.type.getProduct().size())+" parámetros."+
								String.valueOf(((ArrayList<ParserResult>)p).size())
								+"  suministrados", nleft, nright);
								
							}else{//el número de parámetros es correcto, vamos a ver si son iguales:
								int i=0;
								ArrayList<ParserResult> pr=(ArrayList<ParserResult>)p;
								Type found;Type expected;			
								for(;i<f.type.getProduct().size();i++){
									found=p.get(i).type;
									expected=f.type.getProduct().get(i);		
									if(!expected.equals(found)){
										agregarError("Argumento incorrecto para la función '"+((String)n)+"'"+
										" encontrado '"+found.toString()+"', se esperaba '"+expected.toString()+"'",
										nleft, nright);
										break;			
									}
								}//si termina, el tipo de los parámetros es correcto
								if(i==f.type.getProduct().size())
									RESULT=new ParserResult(n, f.type);
								else
									RESULT=new ParserResult(n);
								
							}//el número de parámetros es correcto 
								
						}//es una función
					}//se encontró el id
					//create a new dummy function to compare it with this.
					:}
				//TODO: poner en la tabla de símbolos, inicialmente, todas las sobrecargas de put y get. Y definir una función para sacarlos
				//ya que no se permiten en la ST nombres repetidos...
				|	PUT actual_parameter_part:p
					{://ver si cumple con: sólo un parámetro, el tipo es o String, int, float o boolean
						boolean v=validateBuiltIn("PUT", p, pleft, pright);						
						if(!v){
							RESULT=new ParserResult("put");							
						}else{
							//assume it has only one element:
							ParserResult uP=((ArrayList<ParserResult>)p).get(0);
							RESULT=new ParserResult("put", uP.type);
						}
						
					:}
				|	GET actual_parameter_part:p
					{://mismos criterios que el put...
						boolean v=validateBuiltIn("GET", p, pleft, pright);
						if(!v){
							RESULT=new ParserResult("get");							
						}else{
							//assume it has only one element:
							ParserResult uP=((ArrayList<ParserResult>)p).get(0);
							RESULT=new ParserResult("get", uP.type);
						}
					:}
				;
/*Esta no me parece tan poderosa:
put_call	::= PUT LEFTPAR actual_parameter_list RIGHTPAR
y simil para get
pero quería sólo dejar que pusieran expresiones booleanas, enteras y float allí...
supongo que queda para el semántico...
*/

actual_parameter_part		::=	 LEFTPAR argument_list:a RIGHTPAR {:RESULT=a;:}			
				;
//de p85-persch, pag 95: quité todo

/*acá irían las renaming declaration, y comienza lo relacionado con tasks:
* entry, accept, select y abort
*/
//de p85-persch, pag 96:
/*acá sigue lo de tasks: entry, delay, select y abort*/
compilation			::=	compilation_list
				;
//a esta le falta una tal lista de pragmas, pero como no manejaremos pragmas, no la pongo:
compilation_list		::= 	compilation_unit
				|	compilation_list compilation_unit
				|	error
				;
//de p85-persch, pag 97:
compilation_unit		::=	subprogram_declaration
				|	subprogram_body
				;
//de p85-persch, pag 98:
code_statement			::=	qualified_expression SEMICOLON
				;				
